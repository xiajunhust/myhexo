{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/README.md","hash":"d0732ef226920cafda2b8652464057d12cdc2b27","modified":1468229072000},{"_id":"source/.DS_Store","hash":"f174469f7a5d5d737440b5f8bb55ed186f6c6fb2","modified":1481988303000},{"_id":"themes/landscape/.DS_Store","hash":"8985099d2c7e42ac7d3a10191bd9050b286fd056","modified":1468668175000},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1468227334000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1468227334000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1468227334000},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1468227334000},{"_id":"themes/landscape/_config.yml","hash":"f5794b47f6dac5646c588220bc0c36121c942cc5","modified":1479527293000},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1468227334000},{"_id":"source/_posts/.DS_Store","hash":"8fd10bf4c14d4c10698fabd95380e5fdc6afb839","modified":1479525798000},{"_id":"source/_posts/CopyOnWriteArrayList与JMM.md","hash":"7fefef990412c9efd364049ef41da4b24f5e0675","modified":1473235357000},{"_id":"source/_posts/DbUnit-AmbiguousTableNameException异常解决.md","hash":"73f5fdc5745a1c855186770b6a70b2dbeb53f408","modified":1473235369000},{"_id":"source/_posts/Hexo-GitHub搭建个人博客-增加评论以及访问量统计功能.md","hash":"e12d2266ac251aacd89d33bd0414aa14f0edfbc5","modified":1473235397000},{"_id":"source/_posts/Hexo-GitHub搭建个人博客-添加README.md","hash":"d8f79ed05b0d9f64c335f3890ca43d7f134220c7","modified":1473235388000},{"_id":"source/_posts/MySQL的日期时间类型关于秒以下精度的处理.md","hash":"3e8a8e81d57e64662a59c13200351e0eee3aa01c","modified":1473297096000},{"_id":"source/_posts/RocketMQ源码学习之一-MAC系统单机环境搭建.md","hash":"ccf1d6ba5afba37d40250393a67b05961d0f1007","modified":1479111544000},{"_id":"source/_posts/InfluxDB写入失败-partial-write-max-values-per-tag-limit-exceeded.md","hash":"cebde9dfd6f71ae8a32769530231d1887a447ace","modified":1481988336000},{"_id":"source/_posts/RocketMQ源码学习之三-异步消息发送.md","hash":"b89b16258abfaa1e833490e1d6913acd06020e6c","modified":1479267288000},{"_id":"source/_posts/为什么Java-HashMap、CopyOnWriteArrayList等集合自己实现readObject和writeObject方法.md","hash":"e9d05ce08b69bee4bd62cf50310a6dd8a8f10abf","modified":1473235316000},{"_id":"source/_posts/RocketMQ源码学习之二-同步消息发送.md","hash":"0316dd00b2604303deeae0e78e92ae251ba3b189","modified":1479267269000},{"_id":"source/_posts/RocketMQ源码学习之四-PushConsumer.md","hash":"5fff4a95cc99f060ac9b96e4ec82cbc3fd90566c","modified":1479526398000},{"_id":"source/_posts/《Soft-skills》读书笔记（一）-这本书与其他书籍有何不同.md","hash":"0909e57188bab92ae7927b09164c2acaee8a782a","modified":1473235329000},{"_id":"source/about/index.md","hash":"e2230801f94541914abeb6e017e9a0e53a626abb","modified":1481727906000},{"_id":"source/_posts/从Hystrix-DashboardData看ReativeX的使用.md","hash":"20e6dfdb55aaefb024a59a69952ab11af61e4238","modified":1482045366000},{"_id":"source/_posts/代码中的命名问题-命名太长了！.md","hash":"711aa3771d55fa5e49ca79dac8f59c8899743a89","modified":1473235344000},{"_id":"source/_posts/技术分享-MySQL-InnoDB-locks-and-deadlocks.md","hash":"5f150da53293a1404138e5e807482f8e38d103c1","modified":1473235277000},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1468227334000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1468227334000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1468227334000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1468227334000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1468227334000},{"_id":"themes/landscape/layout/.DS_Store","hash":"9879b0d3f16121e8b5e533430fb94a5c7f904b04","modified":1468668175000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1468227334000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1468227334000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1468227334000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1468227334000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1468227334000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1468227334000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1468227334000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1468227334000},{"_id":"themes/landscape/scripts/CopyRight.js","hash":"652e406c8f255a072817108ab1eff19727c08e2a","modified":1468231154000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1468227334000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1468227334000},{"_id":"themes/landscape/scripts/.DS_Store","hash":"e562b31afa12ea89117671964fd32d1cc2fadfd4","modified":1468231237000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"0a068230f74321c5363773dbf27374d77dbedf2e","modified":1468667749000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"072f9f4a115037928a64a470ce6fbe96048bc318","modified":1468230398000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"71b2dea5d06411475a5d1d1b02beb2b84a439e7f","modified":1468664549000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1468227334000},{"_id":"themes/landscape/layout/_widget/.DS_Store","hash":"aa7d61b47dfdfb36e9bee051542fac886acc706a","modified":1468668275000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1468227334000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1468227334000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1468227334000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1468227334000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1468227334000},{"_id":"themes/landscape/layout/_widget/weibo.ejs","hash":"ad3a8150cf634091ad046842fa78df1782b0e6db","modified":1468668148000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1468227334000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1468227334000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1468227334000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1468227334000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1468227334000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1468227334000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1468227334000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1468227334000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1468227334000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1468227334000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1468227334000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1468227334000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1468227334000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1468227334000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1468227334000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1468227334000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1468227334000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1468227334000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1468227334000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1468227334000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1468227334000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1468227334000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1468227334000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1468227334000},{"_id":"public/about/index.html","hash":"e872fa7234ed2b17ae29d07e243680f0172a2b16","modified":1482045373518},{"_id":"public/archives/index.html","hash":"6166c31d131bca4ae53f6acc16421cc63751eb71","modified":1482045373518},{"_id":"public/archives/page/2/index.html","hash":"a28ec18ed80b7b186d7e695e1eb9464bbe9d65ee","modified":1482045373519},{"_id":"public/archives/2016/index.html","hash":"70c48d38133f7616119963c3da8aa5b56d0fd8b4","modified":1482045373519},{"_id":"public/archives/2016/page/2/index.html","hash":"965ea4b1a70c99df1597aa184a1e7d6e2d9feb67","modified":1482045373519},{"_id":"public/archives/2016/07/index.html","hash":"0716957238ec700601c1eff3375b9d58d1de0301","modified":1482045373519},{"_id":"public/archives/2016/11/index.html","hash":"26d499c2d1d7262e7822c927898331acf034d76b","modified":1482045373519},{"_id":"public/archives/2016/08/index.html","hash":"cc86b0c9feab4fc91e1b8ddd2840ebd763d3ef7d","modified":1482045373519},{"_id":"public/archives/2016/12/index.html","hash":"94c53ab7270483b843cc850d18bdff0cdeaf6269","modified":1482045373519},{"_id":"public/tags/测试技术/index.html","hash":"7a2796388a50ce88599df541c83ce86fffcadf3e","modified":1482045373519},{"_id":"public/tags/Java/index.html","hash":"6b22fb3c4c0ba0f1741124993d58ccf431c69d89","modified":1482045373519},{"_id":"public/tags/开发工具/index.html","hash":"302ace794aa463b4b1ca46ee2b64608f1d27e227","modified":1482045373519},{"_id":"public/tags/MySQL/index.html","hash":"a8a14ab73578c08177f5c4bdde1cfd1a34a81e34","modified":1482045373519},{"_id":"public/tags/RocketMQ/index.html","hash":"906664b1ba98a8e77b2020b9893a3589782b6828","modified":1482045373519},{"_id":"public/tags/InfluxDB/index.html","hash":"225574ec1ca13add71e234ff9c2b40a406887711","modified":1482045373519},{"_id":"public/tags/思考-读书笔记/index.html","hash":"4c61729768e91f32d5e680610ee500a470b42fbf","modified":1482045373519},{"_id":"public/tags/代码设计/index.html","hash":"6e9ce24d6551129c50ab6ec062150a5dc99a59e3","modified":1482045373519},{"_id":"public/tags/ReactiveX/index.html","hash":"315a652cc7d4e2b3ed9aaf17f3507b81ea6196e8","modified":1482045373519},{"_id":"public/tags/Hystrix/index.html","hash":"506abbbf88e3ce580e3b79c93c692dfdfcc5a114","modified":1482045373519},{"_id":"public/2016/12/18/从Hystrix-DashboardData看ReativeX的使用/index.html","hash":"2f0cf6f5a8232b352692b51fddf03233274024dd","modified":1482045373519},{"_id":"public/2016/12/13/InfluxDB写入失败-partial-write-max-values-per-tag-limit-exceeded/index.html","hash":"0a1ddf272336e1741e7e19e55118444d0250fe7f","modified":1482045373519},{"_id":"public/2016/11/17/RocketMQ源码学习之四-PushConsumer/index.html","hash":"e2b09e21ae90860be03bf86aa6038a83aabdde6a","modified":1482045373520},{"_id":"public/2016/11/14/RocketMQ源码学习之三-异步消息发送/index.html","hash":"bb67fc0043e5b98c030c673bae3c771c97a4802b","modified":1482045373520},{"_id":"public/2016/11/12/RocketMQ源码学习之二-同步消息发送/index.html","hash":"e1e1caf5613d59b08d21691dc96e40dc919091d2","modified":1482045373520},{"_id":"public/2016/11/12/RocketMQ源码学习之一-MAC系统单机环境搭建/index.html","hash":"5cfeabb9ea0f66ec47cee737290cbe9c64163c31","modified":1482045373520},{"_id":"public/2016/08/28/MySQL的日期时间类型关于秒以下精度的处理/index.html","hash":"56bf6169ef460cdb2d6d39b288b6fd4cad0cf32f","modified":1482045373520},{"_id":"public/2016/08/27/技术分享-MySQL-InnoDB-locks-and-deadlocks/index.html","hash":"e9cb1253c54041e46faa8543b8b8efdab167fedd","modified":1482045373520},{"_id":"public/2016/08/06/为什么Java-HashMap、CopyOnWriteArrayList等集合自己实现readObject和writeObject方法/index.html","hash":"561c373036b0028a3e58a507e74b8c0f55022773","modified":1482045373520},{"_id":"public/2016/08/06/CopyOnWriteArrayList与JMM/index.html","hash":"325413ee4e4a7fdec055547ee2ef66bee0667bd4","modified":1482045373520},{"_id":"public/2016/07/20/代码中的命名问题-命名太长了！/index.html","hash":"53e755b1f1b2d5d804ac50fa4c5147474939a317","modified":1482045373520},{"_id":"public/2016/07/16/《Soft-skills》读书笔记（一）-这本书与其他书籍有何不同/index.html","hash":"ab18653d5f412cbf97463a47513aeca1fe5b5db3","modified":1482045373520},{"_id":"public/2016/07/14/DbUnit-AmbiguousTableNameException异常解决/index.html","hash":"6318ee4413c942032fff6a21bd2fba91e7ad72ea","modified":1482045373520},{"_id":"public/2016/07/11/Hexo-GitHub搭建个人博客-增加评论以及访问量统计功能/index.html","hash":"f0de19d661e74fd0653d78da6c0bd6c8818099d7","modified":1482045373520},{"_id":"public/2016/07/11/Hexo-GitHub搭建个人博客-添加README/index.html","hash":"35f9f842a1ff5da6159e784e9ade89b96af2268a","modified":1482045373520},{"_id":"public/index.html","hash":"07580f48cd8e471d066b048c783bd0d9fe73eecb","modified":1482045373521},{"_id":"public/page/2/index.html","hash":"b2944cdf63387fdb51796ee150ad0b0d15b67d1a","modified":1482045373521},{"_id":"public/README.md","hash":"d0732ef226920cafda2b8652464057d12cdc2b27","modified":1482045373529},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1482045373529},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1482045373529},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1482045373529},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1482045373529},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1482045373529},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1482045373529},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1482045373529},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1482045373530},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1482045373530},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1482045373530},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1482045374170},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1482045374175},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1482045374175},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1482045374175},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1482045374176},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1482045374176},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1482045374176},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1482045374176},{"_id":"public/css/style.css","hash":"11c9f812d2e2c9f4980553c78844522fa960a413","modified":1482045374176},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1482045374176},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1482045374176},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1482045374179},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1482045374179}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2016-11-19T03:39:31.000Z","_content":"\n# 关于我\n## 基本信息\n- 男\n- 1990年出生\n- 邮箱：xiajun.0706@163.com\n- 在职电商Java开发攻城狮。\n- 现居：杭州\n\n## 教育信息\n- 2014年3月毕业于华中科技大学计算机硕士\n\n## 专业技能\n- Java(集合、并发、内存模型)\n- JVM\n- Reactivex、Reactive Programming\n- Spring(IOC、AOP)\n- Mysql\n- Dubbo\n- RocketMQ\n- Redis\n- HBase\n- 缓存\n- Netty\n- InfluxDB\n- 分布式调度\n- 设计模式\n\n## 兴趣爱好\n- 骑行\n- 旅游\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-11-19 11:39:31\n---\n\n# 关于我\n## 基本信息\n- 男\n- 1990年出生\n- 邮箱：xiajun.0706@163.com\n- 在职电商Java开发攻城狮。\n- 现居：杭州\n\n## 教育信息\n- 2014年3月毕业于华中科技大学计算机硕士\n\n## 专业技能\n- Java(集合、并发、内存模型)\n- JVM\n- Reactivex、Reactive Programming\n- Spring(IOC、AOP)\n- Mysql\n- Dubbo\n- RocketMQ\n- Redis\n- HBase\n- 缓存\n- Netty\n- InfluxDB\n- 分布式调度\n- 设计模式\n\n## 兴趣爱好\n- 骑行\n- 旅游\n","updated":"2016-12-14T15:05:06.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciwubjsaq00012hwfvlt967kx","content":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><ul>\n<li>男</li>\n<li>1990年出生</li>\n<li>邮箱：xiajun.0706@163.com</li>\n<li>在职电商Java开发攻城狮。</li>\n<li>现居：杭州</li>\n</ul>\n<h2 id=\"教育信息\"><a href=\"#教育信息\" class=\"headerlink\" title=\"教育信息\"></a>教育信息</h2><ul>\n<li>2014年3月毕业于华中科技大学计算机硕士</li>\n</ul>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><ul>\n<li>Java(集合、并发、内存模型)</li>\n<li>JVM</li>\n<li>Reactivex、Reactive Programming</li>\n<li>Spring(IOC、AOP)</li>\n<li>Mysql</li>\n<li>Dubbo</li>\n<li>RocketMQ</li>\n<li>Redis</li>\n<li>HBase</li>\n<li>缓存</li>\n<li>Netty</li>\n<li>InfluxDB</li>\n<li>分布式调度</li>\n<li>设计模式</li>\n</ul>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><ul>\n<li>骑行</li>\n<li>旅游</li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/about/index.html\">http://xiajunhust.github.io/about/index.html</a></p>\n","excerpt":"","more":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><ul>\n<li>男</li>\n<li>1990年出生</li>\n<li>邮箱：xiajun.0706@163.com</li>\n<li>在职电商Java开发攻城狮。</li>\n<li>现居：杭州</li>\n</ul>\n<h2 id=\"教育信息\"><a href=\"#教育信息\" class=\"headerlink\" title=\"教育信息\"></a>教育信息</h2><ul>\n<li>2014年3月毕业于华中科技大学计算机硕士</li>\n</ul>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><ul>\n<li>Java(集合、并发、内存模型)</li>\n<li>JVM</li>\n<li>Reactivex、Reactive Programming</li>\n<li>Spring(IOC、AOP)</li>\n<li>Mysql</li>\n<li>Dubbo</li>\n<li>RocketMQ</li>\n<li>Redis</li>\n<li>HBase</li>\n<li>缓存</li>\n<li>Netty</li>\n<li>InfluxDB</li>\n<li>分布式调度</li>\n<li>设计模式</li>\n</ul>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><ul>\n<li>骑行</li>\n<li>旅游</li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/about/index.html\">http://xiajunhust.github.io/about/index.html</a></p>\n"}],"Post":[{"title":"DbUnit AmbiguousTableNameException异常解决","date":"2016-07-14T12:45:12.000Z","_content":"\n# 问题描述  \n今天在用DbUnit写DAO单元测试（使用的是mysql数据库）的时候，抛异常：\n\n<!-- more -->\n\n```\norg.dbunit.database.AmbiguousTableNameException: ACTIVITY\n\n\tat org.dbunit.dataset.OrderedTableNameMap.add(OrderedTableNameMap.java:198)\n\tat org.dbunit.database.DatabaseDataSet.initialize(DatabaseDataSet.java:231)\n\tat org.dbunit.database.DatabaseDataSet.getTableMetaData(DatabaseDataSet.java:281)\n\tat org.dbunit.operation.DeleteAllOperation.execute(DeleteAllOperation.java:109)\n\tat org.dbunit.operation.CompositeOperation.execute(CompositeOperation.java:79)\n\tat org.dbunit.AbstractDatabaseTester.executeOperation(AbstractDatabaseTester.java:190)\n\tat org.dbunit.AbstractDatabaseTester.onSetup(AbstractDatabaseTester.java:103)\n\tat com.youzan.trade.demo.BaseTest.before(BaseTest.java:43)\n\tat com.youzan.trade.demo.BaseDAOTest.before(BaseDAOTest.java:28)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)\n\tat org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)\n\tat org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)\n\tat org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:88)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n\tat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)\n\tat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\n```\n\n# AmbiguousTableNameException的含义\nGoogle搜了下<b>AmbiguousTableNameException</b>关键字，得到如下信息：  \n\n```\nThis exception is thrown by IDataSet when multiple tables having the same name are accessible.This usually occurs when the database connection have access to multiple schemas containing identical table names.\n```\n\n大概意思是这个异常通常在构建IDataSet的时候会抛出，原因是由于数据库连接能访问到超过2个相同名字的数据表。  \n\n一开始并未注意到异常后面的ACTIVITY，而恰巧这个时候我是在做另一个数据表buyer\\_address的测试，因此排查花费了不少时间。使用mysql客户端查看数据库下面的所有数据表，发现具有名字buyer_address的数据表只有1个。无奈只能在DbUnit jar中添加断点:  \n![debug point](http://o8sltkx20.bkt.clouddn.com/0008.png)  \n\ndebug发现，DbUnit会去扫数据库中的所有表，由于数据库中有2个表：activity、Activity，因此就抛出了异常。同时也可以看出，并不会区分大小写。下面我们分析下为什么没有区分大小写。  \n\n看OrderedTableNameMap的getTableName函数：\n\n```\n    /**\n     * Returns the table name in the correct case (for example as upper case string)\n     * @param tableName The input table name to be resolved\n     * @return The table name for the given string in the correct case.\n     */\n    public String getTableName(String tableName) \n    {\n        if(LOGGER.isDebugEnabled())\n            LOGGER.debug(\"getTableName(tableName={}) - start\", tableName);\n        \n        String result = tableName;\n        if(!_caseSensitiveTableNames)\n        {\n            // \"Locale.ENGLISH\" Fixes bug #1537894 when clients have a special\n            // locale like turkish. (for release 2.4.3)\n            result = tableName.toUpperCase(Locale.ENGLISH);\n        }\n\n        if(LOGGER.isDebugEnabled())\n            LOGGER.debug(\"getTableName(tableName={}) - end - result={}\", tableName, result);\n        \n        return result;\n    }\n```\n\n而_caseSensitiveTableNames变量定义默认是false，因此不会区分大小写：  \n\n```\n\t/**\n\t * Whether or not case sensitive table names should be used. Defaults to false.\n\t */\n\tprivate boolean _caseSensitiveTableNames = false;\n```\n\t\n# 解决方法  \n解决方法有如下几种：  \n（1）如果同一个数据库中有2个同名的数据表（不区分大小写），则删除数据库中同名的数据库。  \n（2）如果数据库连接没有指定scheme，则指定数据库连接的schema。\n\n# 参考资料\n- [FAQ-AmbiguousTableNameException](http://dbunit.sourceforge.net/faq.html#AmbiguousTableNameException)\n- [AmbiguousTableNameException](http://dbunit.sourceforge.net/apidocs/org/dbunit/database/AmbiguousTableNameException.html)","source":"_posts/DbUnit-AmbiguousTableNameException异常解决.md","raw":"---\ntitle: DbUnit AmbiguousTableNameException异常解决\ndate: 2016-07-14 20:45:12\ntags: 测试技术\n---\n\n# 问题描述  \n今天在用DbUnit写DAO单元测试（使用的是mysql数据库）的时候，抛异常：\n\n<!-- more -->\n\n```\norg.dbunit.database.AmbiguousTableNameException: ACTIVITY\n\n\tat org.dbunit.dataset.OrderedTableNameMap.add(OrderedTableNameMap.java:198)\n\tat org.dbunit.database.DatabaseDataSet.initialize(DatabaseDataSet.java:231)\n\tat org.dbunit.database.DatabaseDataSet.getTableMetaData(DatabaseDataSet.java:281)\n\tat org.dbunit.operation.DeleteAllOperation.execute(DeleteAllOperation.java:109)\n\tat org.dbunit.operation.CompositeOperation.execute(CompositeOperation.java:79)\n\tat org.dbunit.AbstractDatabaseTester.executeOperation(AbstractDatabaseTester.java:190)\n\tat org.dbunit.AbstractDatabaseTester.onSetup(AbstractDatabaseTester.java:103)\n\tat com.youzan.trade.demo.BaseTest.before(BaseTest.java:43)\n\tat com.youzan.trade.demo.BaseDAOTest.before(BaseDAOTest.java:28)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)\n\tat org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)\n\tat org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)\n\tat org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:88)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n\tat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)\n\tat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\n```\n\n# AmbiguousTableNameException的含义\nGoogle搜了下<b>AmbiguousTableNameException</b>关键字，得到如下信息：  \n\n```\nThis exception is thrown by IDataSet when multiple tables having the same name are accessible.This usually occurs when the database connection have access to multiple schemas containing identical table names.\n```\n\n大概意思是这个异常通常在构建IDataSet的时候会抛出，原因是由于数据库连接能访问到超过2个相同名字的数据表。  \n\n一开始并未注意到异常后面的ACTIVITY，而恰巧这个时候我是在做另一个数据表buyer\\_address的测试，因此排查花费了不少时间。使用mysql客户端查看数据库下面的所有数据表，发现具有名字buyer_address的数据表只有1个。无奈只能在DbUnit jar中添加断点:  \n![debug point](http://o8sltkx20.bkt.clouddn.com/0008.png)  \n\ndebug发现，DbUnit会去扫数据库中的所有表，由于数据库中有2个表：activity、Activity，因此就抛出了异常。同时也可以看出，并不会区分大小写。下面我们分析下为什么没有区分大小写。  \n\n看OrderedTableNameMap的getTableName函数：\n\n```\n    /**\n     * Returns the table name in the correct case (for example as upper case string)\n     * @param tableName The input table name to be resolved\n     * @return The table name for the given string in the correct case.\n     */\n    public String getTableName(String tableName) \n    {\n        if(LOGGER.isDebugEnabled())\n            LOGGER.debug(\"getTableName(tableName={}) - start\", tableName);\n        \n        String result = tableName;\n        if(!_caseSensitiveTableNames)\n        {\n            // \"Locale.ENGLISH\" Fixes bug #1537894 when clients have a special\n            // locale like turkish. (for release 2.4.3)\n            result = tableName.toUpperCase(Locale.ENGLISH);\n        }\n\n        if(LOGGER.isDebugEnabled())\n            LOGGER.debug(\"getTableName(tableName={}) - end - result={}\", tableName, result);\n        \n        return result;\n    }\n```\n\n而_caseSensitiveTableNames变量定义默认是false，因此不会区分大小写：  \n\n```\n\t/**\n\t * Whether or not case sensitive table names should be used. Defaults to false.\n\t */\n\tprivate boolean _caseSensitiveTableNames = false;\n```\n\t\n# 解决方法  \n解决方法有如下几种：  \n（1）如果同一个数据库中有2个同名的数据表（不区分大小写），则删除数据库中同名的数据库。  \n（2）如果数据库连接没有指定scheme，则指定数据库连接的schema。\n\n# 参考资料\n- [FAQ-AmbiguousTableNameException](http://dbunit.sourceforge.net/faq.html#AmbiguousTableNameException)\n- [AmbiguousTableNameException](http://dbunit.sourceforge.net/apidocs/org/dbunit/database/AmbiguousTableNameException.html)","slug":"DbUnit-AmbiguousTableNameException异常解决","published":1,"updated":"2016-09-07T08:02:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsai00002hwfpuouc3kx","content":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>今天在用DbUnit写DAO单元测试（使用的是mysql数据库）的时候，抛异常：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">org.dbunit.database.AmbiguousTableNameException: ACTIVITY</div><div class=\"line\"></div><div class=\"line\">\tat org.dbunit.dataset.OrderedTableNameMap.add(OrderedTableNameMap.java:198)</div><div class=\"line\">\tat org.dbunit.database.DatabaseDataSet.initialize(DatabaseDataSet.java:231)</div><div class=\"line\">\tat org.dbunit.database.DatabaseDataSet.getTableMetaData(DatabaseDataSet.java:281)</div><div class=\"line\">\tat org.dbunit.operation.DeleteAllOperation.execute(DeleteAllOperation.java:109)</div><div class=\"line\">\tat org.dbunit.operation.CompositeOperation.execute(CompositeOperation.java:79)</div><div class=\"line\">\tat org.dbunit.AbstractDatabaseTester.executeOperation(AbstractDatabaseTester.java:190)</div><div class=\"line\">\tat org.dbunit.AbstractDatabaseTester.onSetup(AbstractDatabaseTester.java:103)</div><div class=\"line\">\tat com.youzan.trade.demo.BaseTest.before(BaseTest.java:43)</div><div class=\"line\">\tat com.youzan.trade.demo.BaseDAOTest.before(BaseDAOTest.java:28)</div><div class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:498)</div><div class=\"line\">\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</div><div class=\"line\">\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</div><div class=\"line\">\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</div><div class=\"line\">\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)</div><div class=\"line\">\tat org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)</div><div class=\"line\">\tat org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)</div><div class=\"line\">\tat org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)</div><div class=\"line\">\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)</div><div class=\"line\">\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:88)</div><div class=\"line\">\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</div><div class=\"line\">\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</div><div class=\"line\">\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</div><div class=\"line\">\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</div><div class=\"line\">\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</div><div class=\"line\">\tat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)</div><div class=\"line\">\tat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)</div><div class=\"line\">\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)</div><div class=\"line\">\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)</div><div class=\"line\">\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)</div><div class=\"line\">\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)</div><div class=\"line\">\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)</div><div class=\"line\">\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)</div><div class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:498)</div><div class=\"line\">\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</div></pre></td></tr></table></figure>\n<h1 id=\"AmbiguousTableNameException的含义\"><a href=\"#AmbiguousTableNameException的含义\" class=\"headerlink\" title=\"AmbiguousTableNameException的含义\"></a>AmbiguousTableNameException的含义</h1><p>Google搜了下<b>AmbiguousTableNameException</b>关键字，得到如下信息：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">This exception is thrown by IDataSet when multiple tables having the same name are accessible.This usually occurs when the database connection have access to multiple schemas containing identical table names.</div></pre></td></tr></table></figure>\n<p>大概意思是这个异常通常在构建IDataSet的时候会抛出，原因是由于数据库连接能访问到超过2个相同名字的数据表。  </p>\n<p>一开始并未注意到异常后面的ACTIVITY，而恰巧这个时候我是在做另一个数据表buyer_address的测试，因此排查花费了不少时间。使用mysql客户端查看数据库下面的所有数据表，发现具有名字buyer_address的数据表只有1个。无奈只能在DbUnit jar中添加断点:<br><img src=\"http://o8sltkx20.bkt.clouddn.com/0008.png\" alt=\"debug point\">  </p>\n<p>debug发现，DbUnit会去扫数据库中的所有表，由于数据库中有2个表：activity、Activity，因此就抛出了异常。同时也可以看出，并不会区分大小写。下面我们分析下为什么没有区分大小写。  </p>\n<p>看OrderedTableNameMap的getTableName函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Returns the table name in the correct case (for example as upper case string)</div><div class=\"line\"> * @param tableName The input table name to be resolved</div><div class=\"line\"> * @return The table name for the given string in the correct case.</div><div class=\"line\"> */</div><div class=\"line\">public String getTableName(String tableName) </div><div class=\"line\">&#123;</div><div class=\"line\">    if(LOGGER.isDebugEnabled())</div><div class=\"line\">        LOGGER.debug(&quot;getTableName(tableName=&#123;&#125;) - start&quot;, tableName);</div><div class=\"line\">    </div><div class=\"line\">    String result = tableName;</div><div class=\"line\">    if(!_caseSensitiveTableNames)</div><div class=\"line\">    &#123;</div><div class=\"line\">        // &quot;Locale.ENGLISH&quot; Fixes bug #1537894 when clients have a special</div><div class=\"line\">        // locale like turkish. (for release 2.4.3)</div><div class=\"line\">        result = tableName.toUpperCase(Locale.ENGLISH);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if(LOGGER.isDebugEnabled())</div><div class=\"line\">        LOGGER.debug(&quot;getTableName(tableName=&#123;&#125;) - end - result=&#123;&#125;&quot;, tableName, result);</div><div class=\"line\">    </div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而_caseSensitiveTableNames变量定义默认是false，因此不会区分大小写：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Whether or not case sensitive table names should be used. Defaults to false.</div><div class=\"line\"> */</div><div class=\"line\">private boolean _caseSensitiveTableNames = false;</div></pre></td></tr></table></figure>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>解决方法有如下几种：<br>（1）如果同一个数据库中有2个同名的数据表（不区分大小写），则删除数据库中同名的数据库。<br>（2）如果数据库连接没有指定scheme，则指定数据库连接的schema。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"http://dbunit.sourceforge.net/faq.html#AmbiguousTableNameException\" target=\"_blank\" rel=\"external\">FAQ-AmbiguousTableNameException</a></li>\n<li><a href=\"http://dbunit.sourceforge.net/apidocs/org/dbunit/database/AmbiguousTableNameException.html\" target=\"_blank\" rel=\"external\">AmbiguousTableNameException</a><h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2></li>\n</ul>\n<p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/07/14/DbUnit-AmbiguousTableNameException异常解决/\">http://xiajunhust.github.io/2016/07/14/DbUnit-AmbiguousTableNameException异常解决/</a></p>\n","excerpt":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>今天在用DbUnit写DAO单元测试（使用的是mysql数据库）的时候，抛异常：</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">org.dbunit.database.AmbiguousTableNameException: ACTIVITY</div><div class=\"line\"></div><div class=\"line\">\tat org.dbunit.dataset.OrderedTableNameMap.add(OrderedTableNameMap.java:198)</div><div class=\"line\">\tat org.dbunit.database.DatabaseDataSet.initialize(DatabaseDataSet.java:231)</div><div class=\"line\">\tat org.dbunit.database.DatabaseDataSet.getTableMetaData(DatabaseDataSet.java:281)</div><div class=\"line\">\tat org.dbunit.operation.DeleteAllOperation.execute(DeleteAllOperation.java:109)</div><div class=\"line\">\tat org.dbunit.operation.CompositeOperation.execute(CompositeOperation.java:79)</div><div class=\"line\">\tat org.dbunit.AbstractDatabaseTester.executeOperation(AbstractDatabaseTester.java:190)</div><div class=\"line\">\tat org.dbunit.AbstractDatabaseTester.onSetup(AbstractDatabaseTester.java:103)</div><div class=\"line\">\tat com.youzan.trade.demo.BaseTest.before(BaseTest.java:43)</div><div class=\"line\">\tat com.youzan.trade.demo.BaseDAOTest.before(BaseDAOTest.java:28)</div><div class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:498)</div><div class=\"line\">\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</div><div class=\"line\">\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</div><div class=\"line\">\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</div><div class=\"line\">\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)</div><div class=\"line\">\tat org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)</div><div class=\"line\">\tat org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)</div><div class=\"line\">\tat org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)</div><div class=\"line\">\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)</div><div class=\"line\">\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:88)</div><div class=\"line\">\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</div><div class=\"line\">\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</div><div class=\"line\">\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</div><div class=\"line\">\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</div><div class=\"line\">\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</div><div class=\"line\">\tat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)</div><div class=\"line\">\tat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)</div><div class=\"line\">\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)</div><div class=\"line\">\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)</div><div class=\"line\">\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)</div><div class=\"line\">\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)</div><div class=\"line\">\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)</div><div class=\"line\">\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)</div><div class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:498)</div><div class=\"line\">\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</div></pre></td></tr></table></figure>\n<h1 id=\"AmbiguousTableNameException的含义\"><a href=\"#AmbiguousTableNameException的含义\" class=\"headerlink\" title=\"AmbiguousTableNameException的含义\"></a>AmbiguousTableNameException的含义</h1><p>Google搜了下<b>AmbiguousTableNameException</b>关键字，得到如下信息：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">This exception is thrown by IDataSet when multiple tables having the same name are accessible.This usually occurs when the database connection have access to multiple schemas containing identical table names.</div></pre></td></tr></table></figure>\n<p>大概意思是这个异常通常在构建IDataSet的时候会抛出，原因是由于数据库连接能访问到超过2个相同名字的数据表。  </p>\n<p>一开始并未注意到异常后面的ACTIVITY，而恰巧这个时候我是在做另一个数据表buyer_address的测试，因此排查花费了不少时间。使用mysql客户端查看数据库下面的所有数据表，发现具有名字buyer_address的数据表只有1个。无奈只能在DbUnit jar中添加断点:<br><img src=\"http://o8sltkx20.bkt.clouddn.com/0008.png\" alt=\"debug point\">  </p>\n<p>debug发现，DbUnit会去扫数据库中的所有表，由于数据库中有2个表：activity、Activity，因此就抛出了异常。同时也可以看出，并不会区分大小写。下面我们分析下为什么没有区分大小写。  </p>\n<p>看OrderedTableNameMap的getTableName函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Returns the table name in the correct case (for example as upper case string)</div><div class=\"line\"> * @param tableName The input table name to be resolved</div><div class=\"line\"> * @return The table name for the given string in the correct case.</div><div class=\"line\"> */</div><div class=\"line\">public String getTableName(String tableName) </div><div class=\"line\">&#123;</div><div class=\"line\">    if(LOGGER.isDebugEnabled())</div><div class=\"line\">        LOGGER.debug(&quot;getTableName(tableName=&#123;&#125;) - start&quot;, tableName);</div><div class=\"line\">    </div><div class=\"line\">    String result = tableName;</div><div class=\"line\">    if(!_caseSensitiveTableNames)</div><div class=\"line\">    &#123;</div><div class=\"line\">        // &quot;Locale.ENGLISH&quot; Fixes bug #1537894 when clients have a special</div><div class=\"line\">        // locale like turkish. (for release 2.4.3)</div><div class=\"line\">        result = tableName.toUpperCase(Locale.ENGLISH);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if(LOGGER.isDebugEnabled())</div><div class=\"line\">        LOGGER.debug(&quot;getTableName(tableName=&#123;&#125;) - end - result=&#123;&#125;&quot;, tableName, result);</div><div class=\"line\">    </div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而_caseSensitiveTableNames变量定义默认是false，因此不会区分大小写：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Whether or not case sensitive table names should be used. Defaults to false.</div><div class=\"line\"> */</div><div class=\"line\">private boolean _caseSensitiveTableNames = false;</div></pre></td></tr></table></figure>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>解决方法有如下几种：<br>（1）如果同一个数据库中有2个同名的数据表（不区分大小写），则删除数据库中同名的数据库。<br>（2）如果数据库连接没有指定scheme，则指定数据库连接的schema。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"http://dbunit.sourceforge.net/faq.html#AmbiguousTableNameException\">FAQ-AmbiguousTableNameException</a></li>\n<li><a href=\"http://dbunit.sourceforge.net/apidocs/org/dbunit/database/AmbiguousTableNameException.html\">AmbiguousTableNameException</a><h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2></li>\n</ul>\n<p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/07/14/DbUnit-AmbiguousTableNameException异常解决/\">http://xiajunhust.github.io/2016/07/14/DbUnit-AmbiguousTableNameException异常解决/</a></p>"},{"title":"CopyOnWriteArrayList与JMM","date":"2016-08-06T08:37:02.000Z","_content":"\n说明：本文代码均以JDK1.8的源码为准。\n\n# 1 什么是CopyOnWriteArrayList\n\n关于CopyOnWriteArrayList是什么以及基本用法，在这里不多说，网上可以搜到大量这方面的文章。在这里只做简要说明：CopyOnWriteArrayList相当于线程安全的ArrayList，是一个可变数组。它具有如下特性： \n \n- 是线程安全的\n- 写操作会复制整个基础数组，因此写操作开销很大\n- 适用于如下情况：数组大小较小，并且读操作比写操作多很多的情形\n\n<!-- more -->\n\n# 2 CopyOnWriteArrayList的设计原理与JMM\n\n下面我们分析CopyOnWriteArrayList的设计原理，结合JMM的基础知识，分析CopyOnWriteArrayList是如何保证线程安全的。\n\n首先看用来实际保存数据的数组：\n\n```\n/** The array, accessed only via getArray/setArray. */\nprivate transient volatile Object[] array;\n```\n\n可以看到array数组前面使用了volatile变量来修饰。volatile主要用来解决内存可见性问题。关于volatile的详细实现原理可以参考《[深入理解java内存模型.pdf](http://o8sltkx20.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf)》以及[Java并发编程：volatile关键字解析-博客园-海子](http://www.cnblogs.com/dolphin0520/p/3920373.html)。\n\n## 2.1 CopyOnWriteArrayList的读方法\n\n读方法比较简单，直接从array中获取对应索引的值。\n\n```\n/**\n * {@inheritDoc}\n *\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E get(int index) {\n    return get(getArray(), index);\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n\n/**\n * Gets the array.  Non-private so as to also be accessible\n * from CopyOnWriteArraySet class.\n */\nfinal Object[] getArray() {\n    return array;\n}\n```\n\n## 2.2 CopyOnWriteArrayList的写方法\n\n- set方法  \n源码如下：\n\n```\n/**\n * Replaces the element at the specified position in this list with the\n * specified element.\n *\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E set(int index, E element) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        E oldValue = get(elements, index);\n\n        if (oldValue != element) {\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len);\n            newElements[index] = element;\n            setArray(newElements);\n        } else {\n            // Not quite a no-op; ensures volatile write semantics\n            setArray(elements);\n        }\n        return oldValue;\n    } finally {\n        lock.unlock();\n    }\n}\n\n/**\n * Sets the array.\n */\nfinal void setArray(Object[] a) {\n    array = a;\n}\n```\n\nset方法的功能是将对应索引的元素置为一个新值。执行流程：  \n（1）加锁  \n（2）获取对应索引已有的值  \n（3）比较已有的值和新值，如果不相等，转4，否则转5  \n（4）创建新的数组，复制原数组的元素，并将对应索引置为新值。然后将新数组赋给array（setArray）  \n（5）setArray-将array赋给array\n\n这里有一个比较奇怪的点，为什么已有的值和新值相等的时候，还要执行setArray呢？本质上setArray也没有做什么事情。  \n\n这段代码混合使用了锁以及volatile。锁的用法比较容易理解，它在使用同一个锁的不同线程之间保证内存顺序性，代码结尾的释放锁的操作提供了本线程和其他欲获取相同的锁的线程之间的happens-before语义。但是CopyOnWriteArrayList类中其他代码，不一定会使用到这把锁，因此，前面所述的锁带来的内存模型含义对这部分代码执行是不适用的。\n\n其他没用到这把锁的代码，读写是volatile读和volatile写（因为array前面使用volatile关键字修饰）。由volatile来保证happens-before语义。\n\n---\n\n<b>volatile的特性及原理</b>\n\nvolatile 变量自身具有下列特性:  \r（1）可见性。对一个volatile 变量的读,总是能看到(任意线程)对这个volatile变量最后的写入。  \r（2）原子性:对任意单个volatile 变量的读/写具有原子性,但类似于volatile++这种复合操作不具有原子性。\n\nvolatile 写和锁的释放有相同的内存语义。\n\n为了实现 volatile 的内存语义,编译器在生成字节码时,会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。\n\n---\n\n这里调用setArray的原因是，确保set方法对array执行的永远是volatile写。这就和其他对array执行volatile读的线程之间建立了happens-before语义。非常重要的一点：volatile读/写语义针对的是读写操作，而不是使用volatile修饰的变量本身。这样说更直白一点：在一个volatile写操作之前的对其他非volatile变量的写，happens-before于同一个volatile变量读操作之后的对其他变量的读。这句话比较绕，看下面一个例子就比较易懂了。\n\n```\n// initial conditions\nint nonVolatileField = 0;\nCopyOnWriteArrayList<String> list = /* a single String */\n\n// Thread 1\nnonVolatileField = 1;                 // (1)\nlist.set(0, \"x\");                     // (2)\n\n// Thread 2\nString s = list.get(0);               // (3)\nif (s == \"x\") {\n    int localVar = nonVolatileField;  // (4)\n}\n```\n\n现在假设原始数组中无元素“x”，这样(2)成功设置了元素\"x\"，(3)处可以成功获取到元素\"x\"。这种情况下，(4)一定会读取到(1)处设置的值1.因为(2)处的volatile写以及在此之前的任何写操作都happens-before(3)处的读以及之后的所有读。\n\n但是，假设一开始数组中就有了元素\"x\"，如果else不调用setArray，那么(2)处的写就不是volatile写，(4)处的读就不一定能读到(1)处设置的值！\n\n很显然我们不想让内存可见性依赖于list中已有的值，为了确保任何情况下的内存可见性，set方法必须永远都是一个volatile写，这就是为何要在else代码块中调用setArray的原因。\n\n其他写方法（add、remove）比较易懂，在此不详述。\n\n\n# 3 参考资料\n\n- [Java多线程系列--“JUC集合”02之 CopyOnWriteArrayList](http://www.cnblogs.com/skywang12345/p/3498483.html)\n- [Why setArray() method call required in CopyOnWriteArrayList](http://stackoverflow.com/questions/28772539/why-setarray-method-call-required-in-copyonwritearraylist#)\n- [深入理解java内存模型.pdf](http://o8sltkx20.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf)\n- [Java并发编程：volatile关键字解析-博客园-海子](http://www.cnblogs.com/dolphin0520/p/3920373.html)","source":"_posts/CopyOnWriteArrayList与JMM.md","raw":"---\ntitle: CopyOnWriteArrayList与JMM\ndate: 2016-08-06 16:37:02\ntags: Java\n---\n\n说明：本文代码均以JDK1.8的源码为准。\n\n# 1 什么是CopyOnWriteArrayList\n\n关于CopyOnWriteArrayList是什么以及基本用法，在这里不多说，网上可以搜到大量这方面的文章。在这里只做简要说明：CopyOnWriteArrayList相当于线程安全的ArrayList，是一个可变数组。它具有如下特性： \n \n- 是线程安全的\n- 写操作会复制整个基础数组，因此写操作开销很大\n- 适用于如下情况：数组大小较小，并且读操作比写操作多很多的情形\n\n<!-- more -->\n\n# 2 CopyOnWriteArrayList的设计原理与JMM\n\n下面我们分析CopyOnWriteArrayList的设计原理，结合JMM的基础知识，分析CopyOnWriteArrayList是如何保证线程安全的。\n\n首先看用来实际保存数据的数组：\n\n```\n/** The array, accessed only via getArray/setArray. */\nprivate transient volatile Object[] array;\n```\n\n可以看到array数组前面使用了volatile变量来修饰。volatile主要用来解决内存可见性问题。关于volatile的详细实现原理可以参考《[深入理解java内存模型.pdf](http://o8sltkx20.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf)》以及[Java并发编程：volatile关键字解析-博客园-海子](http://www.cnblogs.com/dolphin0520/p/3920373.html)。\n\n## 2.1 CopyOnWriteArrayList的读方法\n\n读方法比较简单，直接从array中获取对应索引的值。\n\n```\n/**\n * {@inheritDoc}\n *\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E get(int index) {\n    return get(getArray(), index);\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n\n/**\n * Gets the array.  Non-private so as to also be accessible\n * from CopyOnWriteArraySet class.\n */\nfinal Object[] getArray() {\n    return array;\n}\n```\n\n## 2.2 CopyOnWriteArrayList的写方法\n\n- set方法  \n源码如下：\n\n```\n/**\n * Replaces the element at the specified position in this list with the\n * specified element.\n *\n * @throws IndexOutOfBoundsException {@inheritDoc}\n */\npublic E set(int index, E element) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        E oldValue = get(elements, index);\n\n        if (oldValue != element) {\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len);\n            newElements[index] = element;\n            setArray(newElements);\n        } else {\n            // Not quite a no-op; ensures volatile write semantics\n            setArray(elements);\n        }\n        return oldValue;\n    } finally {\n        lock.unlock();\n    }\n}\n\n/**\n * Sets the array.\n */\nfinal void setArray(Object[] a) {\n    array = a;\n}\n```\n\nset方法的功能是将对应索引的元素置为一个新值。执行流程：  \n（1）加锁  \n（2）获取对应索引已有的值  \n（3）比较已有的值和新值，如果不相等，转4，否则转5  \n（4）创建新的数组，复制原数组的元素，并将对应索引置为新值。然后将新数组赋给array（setArray）  \n（5）setArray-将array赋给array\n\n这里有一个比较奇怪的点，为什么已有的值和新值相等的时候，还要执行setArray呢？本质上setArray也没有做什么事情。  \n\n这段代码混合使用了锁以及volatile。锁的用法比较容易理解，它在使用同一个锁的不同线程之间保证内存顺序性，代码结尾的释放锁的操作提供了本线程和其他欲获取相同的锁的线程之间的happens-before语义。但是CopyOnWriteArrayList类中其他代码，不一定会使用到这把锁，因此，前面所述的锁带来的内存模型含义对这部分代码执行是不适用的。\n\n其他没用到这把锁的代码，读写是volatile读和volatile写（因为array前面使用volatile关键字修饰）。由volatile来保证happens-before语义。\n\n---\n\n<b>volatile的特性及原理</b>\n\nvolatile 变量自身具有下列特性:  \r（1）可见性。对一个volatile 变量的读,总是能看到(任意线程)对这个volatile变量最后的写入。  \r（2）原子性:对任意单个volatile 变量的读/写具有原子性,但类似于volatile++这种复合操作不具有原子性。\n\nvolatile 写和锁的释放有相同的内存语义。\n\n为了实现 volatile 的内存语义,编译器在生成字节码时,会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。\n\n---\n\n这里调用setArray的原因是，确保set方法对array执行的永远是volatile写。这就和其他对array执行volatile读的线程之间建立了happens-before语义。非常重要的一点：volatile读/写语义针对的是读写操作，而不是使用volatile修饰的变量本身。这样说更直白一点：在一个volatile写操作之前的对其他非volatile变量的写，happens-before于同一个volatile变量读操作之后的对其他变量的读。这句话比较绕，看下面一个例子就比较易懂了。\n\n```\n// initial conditions\nint nonVolatileField = 0;\nCopyOnWriteArrayList<String> list = /* a single String */\n\n// Thread 1\nnonVolatileField = 1;                 // (1)\nlist.set(0, \"x\");                     // (2)\n\n// Thread 2\nString s = list.get(0);               // (3)\nif (s == \"x\") {\n    int localVar = nonVolatileField;  // (4)\n}\n```\n\n现在假设原始数组中无元素“x”，这样(2)成功设置了元素\"x\"，(3)处可以成功获取到元素\"x\"。这种情况下，(4)一定会读取到(1)处设置的值1.因为(2)处的volatile写以及在此之前的任何写操作都happens-before(3)处的读以及之后的所有读。\n\n但是，假设一开始数组中就有了元素\"x\"，如果else不调用setArray，那么(2)处的写就不是volatile写，(4)处的读就不一定能读到(1)处设置的值！\n\n很显然我们不想让内存可见性依赖于list中已有的值，为了确保任何情况下的内存可见性，set方法必须永远都是一个volatile写，这就是为何要在else代码块中调用setArray的原因。\n\n其他写方法（add、remove）比较易懂，在此不详述。\n\n\n# 3 参考资料\n\n- [Java多线程系列--“JUC集合”02之 CopyOnWriteArrayList](http://www.cnblogs.com/skywang12345/p/3498483.html)\n- [Why setArray() method call required in CopyOnWriteArrayList](http://stackoverflow.com/questions/28772539/why-setarray-method-call-required-in-copyonwritearraylist#)\n- [深入理解java内存模型.pdf](http://o8sltkx20.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf)\n- [Java并发编程：volatile关键字解析-博客园-海子](http://www.cnblogs.com/dolphin0520/p/3920373.html)","slug":"CopyOnWriteArrayList与JMM","published":1,"updated":"2016-09-07T08:02:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsas00022hwfu99jgghz","content":"<p>说明：本文代码均以JDK1.8的源码为准。</p>\n<h1 id=\"1-什么是CopyOnWriteArrayList\"><a href=\"#1-什么是CopyOnWriteArrayList\" class=\"headerlink\" title=\"1 什么是CopyOnWriteArrayList\"></a>1 什么是CopyOnWriteArrayList</h1><p>关于CopyOnWriteArrayList是什么以及基本用法，在这里不多说，网上可以搜到大量这方面的文章。在这里只做简要说明：CopyOnWriteArrayList相当于线程安全的ArrayList，是一个可变数组。它具有如下特性： </p>\n<ul>\n<li>是线程安全的</li>\n<li>写操作会复制整个基础数组，因此写操作开销很大</li>\n<li>适用于如下情况：数组大小较小，并且读操作比写操作多很多的情形</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"2-CopyOnWriteArrayList的设计原理与JMM\"><a href=\"#2-CopyOnWriteArrayList的设计原理与JMM\" class=\"headerlink\" title=\"2 CopyOnWriteArrayList的设计原理与JMM\"></a>2 CopyOnWriteArrayList的设计原理与JMM</h1><p>下面我们分析CopyOnWriteArrayList的设计原理，结合JMM的基础知识，分析CopyOnWriteArrayList是如何保证线程安全的。</p>\n<p>首先看用来实际保存数据的数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** The array, accessed only via getArray/setArray. */</div><div class=\"line\">private transient volatile Object[] array;</div></pre></td></tr></table></figure>\n<p>可以看到array数组前面使用了volatile变量来修饰。volatile主要用来解决内存可见性问题。关于volatile的详细实现原理可以参考《<a href=\"http://o8sltkx20.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf\" target=\"_blank\" rel=\"external\">深入理解java内存模型.pdf</a>》以及<a href=\"http://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"external\">Java并发编程：volatile关键字解析-博客园-海子</a>。</p>\n<h2 id=\"2-1-CopyOnWriteArrayList的读方法\"><a href=\"#2-1-CopyOnWriteArrayList的读方法\" class=\"headerlink\" title=\"2.1 CopyOnWriteArrayList的读方法\"></a>2.1 CopyOnWriteArrayList的读方法</h2><p>读方法比较简单，直接从array中获取对应索引的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * &#123;@inheritDoc&#125;</div><div class=\"line\"> *</div><div class=\"line\"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class=\"line\"> */</div><div class=\"line\">public E get(int index) &#123;</div><div class=\"line\">    return get(getArray(), index);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">private E get(Object[] a, int index) &#123;</div><div class=\"line\">    return (E) a[index];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Gets the array.  Non-private so as to also be accessible</div><div class=\"line\"> * from CopyOnWriteArraySet class.</div><div class=\"line\"> */</div><div class=\"line\">final Object[] getArray() &#123;</div><div class=\"line\">    return array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-CopyOnWriteArrayList的写方法\"><a href=\"#2-2-CopyOnWriteArrayList的写方法\" class=\"headerlink\" title=\"2.2 CopyOnWriteArrayList的写方法\"></a>2.2 CopyOnWriteArrayList的写方法</h2><ul>\n<li>set方法<br>源码如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Replaces the element at the specified position in this list with the</div><div class=\"line\"> * specified element.</div><div class=\"line\"> *</div><div class=\"line\"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class=\"line\"> */</div><div class=\"line\">public E set(int index, E element) &#123;</div><div class=\"line\">    final ReentrantLock lock = this.lock;</div><div class=\"line\">    lock.lock();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Object[] elements = getArray();</div><div class=\"line\">        E oldValue = get(elements, index);</div><div class=\"line\"></div><div class=\"line\">        if (oldValue != element) &#123;</div><div class=\"line\">            int len = elements.length;</div><div class=\"line\">            Object[] newElements = Arrays.copyOf(elements, len);</div><div class=\"line\">            newElements[index] = element;</div><div class=\"line\">            setArray(newElements);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Not quite a no-op; ensures volatile write semantics</div><div class=\"line\">            setArray(elements);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return oldValue;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        lock.unlock();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Sets the array.</div><div class=\"line\"> */</div><div class=\"line\">final void setArray(Object[] a) &#123;</div><div class=\"line\">    array = a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>set方法的功能是将对应索引的元素置为一个新值。执行流程：<br>（1）加锁<br>（2）获取对应索引已有的值<br>（3）比较已有的值和新值，如果不相等，转4，否则转5<br>（4）创建新的数组，复制原数组的元素，并将对应索引置为新值。然后将新数组赋给array（setArray）<br>（5）setArray-将array赋给array</p>\n<p>这里有一个比较奇怪的点，为什么已有的值和新值相等的时候，还要执行setArray呢？本质上setArray也没有做什么事情。  </p>\n<p>这段代码混合使用了锁以及volatile。锁的用法比较容易理解，它在使用同一个锁的不同线程之间保证内存顺序性，代码结尾的释放锁的操作提供了本线程和其他欲获取相同的锁的线程之间的happens-before语义。但是CopyOnWriteArrayList类中其他代码，不一定会使用到这把锁，因此，前面所述的锁带来的内存模型含义对这部分代码执行是不适用的。</p>\n<p>其他没用到这把锁的代码，读写是volatile读和volatile写（因为array前面使用volatile关键字修饰）。由volatile来保证happens-before语义。</p>\n<hr>\n<p><b>volatile的特性及原理</b></p>\n<p>volatile 变量自身具有下列特性:<br>（1）可见性。对一个volatile 变量的读,总是能看到(任意线程)对这个volatile变量最后的写入。<br>（2）原子性:对任意单个volatile 变量的读/写具有原子性,但类似于volatile++这种复合操作不具有原子性。</p>\n<p>volatile 写和锁的释放有相同的内存语义。</p>\n<p>为了实现 volatile 的内存语义,编译器在生成字节码时,会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>\n<hr>\n<p>这里调用setArray的原因是，确保set方法对array执行的永远是volatile写。这就和其他对array执行volatile读的线程之间建立了happens-before语义。非常重要的一点：volatile读/写语义针对的是读写操作，而不是使用volatile修饰的变量本身。这样说更直白一点：在一个volatile写操作之前的对其他非volatile变量的写，happens-before于同一个volatile变量读操作之后的对其他变量的读。这句话比较绕，看下面一个例子就比较易懂了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// initial conditions</div><div class=\"line\">int nonVolatileField = 0;</div><div class=\"line\">CopyOnWriteArrayList&lt;String&gt; list = /* a single String */</div><div class=\"line\"></div><div class=\"line\">// Thread 1</div><div class=\"line\">nonVolatileField = 1;                 // (1)</div><div class=\"line\">list.set(0, &quot;x&quot;);                     // (2)</div><div class=\"line\"></div><div class=\"line\">// Thread 2</div><div class=\"line\">String s = list.get(0);               // (3)</div><div class=\"line\">if (s == &quot;x&quot;) &#123;</div><div class=\"line\">    int localVar = nonVolatileField;  // (4)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在假设原始数组中无元素“x”，这样(2)成功设置了元素”x”，(3)处可以成功获取到元素”x”。这种情况下，(4)一定会读取到(1)处设置的值1.因为(2)处的volatile写以及在此之前的任何写操作都happens-before(3)处的读以及之后的所有读。</p>\n<p>但是，假设一开始数组中就有了元素”x”，如果else不调用setArray，那么(2)处的写就不是volatile写，(4)处的读就不一定能读到(1)处设置的值！</p>\n<p>很显然我们不想让内存可见性依赖于list中已有的值，为了确保任何情况下的内存可见性，set方法必须永远都是一个volatile写，这就是为何要在else代码块中调用setArray的原因。</p>\n<p>其他写方法（add、remove）比较易懂，在此不详述。</p>\n<h1 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3 参考资料\"></a>3 参考资料</h1><ul>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/3498483.html\" target=\"_blank\" rel=\"external\">Java多线程系列–“JUC集合”02之 CopyOnWriteArrayList</a></li>\n<li><a href=\"http://stackoverflow.com/questions/28772539/why-setarray-method-call-required-in-copyonwritearraylist#\" target=\"_blank\" rel=\"external\">Why setArray() method call required in CopyOnWriteArrayList</a></li>\n<li><a href=\"http://o8sltkx20.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf\" target=\"_blank\" rel=\"external\">深入理解java内存模型.pdf</a></li>\n<li><a href=\"http://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"external\">Java并发编程：volatile关键字解析-博客园-海子</a><h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2></li>\n</ul>\n<p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/08/06/CopyOnWriteArrayList与JMM/\">http://xiajunhust.github.io/2016/08/06/CopyOnWriteArrayList与JMM/</a></p>\n","excerpt":"<p>说明：本文代码均以JDK1.8的源码为准。</p>\n<h1 id=\"1-什么是CopyOnWriteArrayList\"><a href=\"#1-什么是CopyOnWriteArrayList\" class=\"headerlink\" title=\"1 什么是CopyOnWriteArrayList\"></a>1 什么是CopyOnWriteArrayList</h1><p>关于CopyOnWriteArrayList是什么以及基本用法，在这里不多说，网上可以搜到大量这方面的文章。在这里只做简要说明：CopyOnWriteArrayList相当于线程安全的ArrayList，是一个可变数组。它具有如下特性： </p>\n<ul>\n<li>是线程安全的</li>\n<li>写操作会复制整个基础数组，因此写操作开销很大</li>\n<li>适用于如下情况：数组大小较小，并且读操作比写操作多很多的情形</li>\n</ul>","more":"<h1 id=\"2-CopyOnWriteArrayList的设计原理与JMM\"><a href=\"#2-CopyOnWriteArrayList的设计原理与JMM\" class=\"headerlink\" title=\"2 CopyOnWriteArrayList的设计原理与JMM\"></a>2 CopyOnWriteArrayList的设计原理与JMM</h1><p>下面我们分析CopyOnWriteArrayList的设计原理，结合JMM的基础知识，分析CopyOnWriteArrayList是如何保证线程安全的。</p>\n<p>首先看用来实际保存数据的数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** The array, accessed only via getArray/setArray. */</div><div class=\"line\">private transient volatile Object[] array;</div></pre></td></tr></table></figure>\n<p>可以看到array数组前面使用了volatile变量来修饰。volatile主要用来解决内存可见性问题。关于volatile的详细实现原理可以参考《<a href=\"http://o8sltkx20.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf\">深入理解java内存模型.pdf</a>》以及<a href=\"http://www.cnblogs.com/dolphin0520/p/3920373.html\">Java并发编程：volatile关键字解析-博客园-海子</a>。</p>\n<h2 id=\"2-1-CopyOnWriteArrayList的读方法\"><a href=\"#2-1-CopyOnWriteArrayList的读方法\" class=\"headerlink\" title=\"2.1 CopyOnWriteArrayList的读方法\"></a>2.1 CopyOnWriteArrayList的读方法</h2><p>读方法比较简单，直接从array中获取对应索引的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * &#123;@inheritDoc&#125;</div><div class=\"line\"> *</div><div class=\"line\"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class=\"line\"> */</div><div class=\"line\">public E get(int index) &#123;</div><div class=\"line\">    return get(getArray(), index);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">private E get(Object[] a, int index) &#123;</div><div class=\"line\">    return (E) a[index];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Gets the array.  Non-private so as to also be accessible</div><div class=\"line\"> * from CopyOnWriteArraySet class.</div><div class=\"line\"> */</div><div class=\"line\">final Object[] getArray() &#123;</div><div class=\"line\">    return array;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-CopyOnWriteArrayList的写方法\"><a href=\"#2-2-CopyOnWriteArrayList的写方法\" class=\"headerlink\" title=\"2.2 CopyOnWriteArrayList的写方法\"></a>2.2 CopyOnWriteArrayList的写方法</h2><ul>\n<li>set方法<br>源码如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Replaces the element at the specified position in this list with the</div><div class=\"line\"> * specified element.</div><div class=\"line\"> *</div><div class=\"line\"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class=\"line\"> */</div><div class=\"line\">public E set(int index, E element) &#123;</div><div class=\"line\">    final ReentrantLock lock = this.lock;</div><div class=\"line\">    lock.lock();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Object[] elements = getArray();</div><div class=\"line\">        E oldValue = get(elements, index);</div><div class=\"line\"></div><div class=\"line\">        if (oldValue != element) &#123;</div><div class=\"line\">            int len = elements.length;</div><div class=\"line\">            Object[] newElements = Arrays.copyOf(elements, len);</div><div class=\"line\">            newElements[index] = element;</div><div class=\"line\">            setArray(newElements);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // Not quite a no-op; ensures volatile write semantics</div><div class=\"line\">            setArray(elements);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return oldValue;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        lock.unlock();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Sets the array.</div><div class=\"line\"> */</div><div class=\"line\">final void setArray(Object[] a) &#123;</div><div class=\"line\">    array = a;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>set方法的功能是将对应索引的元素置为一个新值。执行流程：<br>（1）加锁<br>（2）获取对应索引已有的值<br>（3）比较已有的值和新值，如果不相等，转4，否则转5<br>（4）创建新的数组，复制原数组的元素，并将对应索引置为新值。然后将新数组赋给array（setArray）<br>（5）setArray-将array赋给array</p>\n<p>这里有一个比较奇怪的点，为什么已有的值和新值相等的时候，还要执行setArray呢？本质上setArray也没有做什么事情。  </p>\n<p>这段代码混合使用了锁以及volatile。锁的用法比较容易理解，它在使用同一个锁的不同线程之间保证内存顺序性，代码结尾的释放锁的操作提供了本线程和其他欲获取相同的锁的线程之间的happens-before语义。但是CopyOnWriteArrayList类中其他代码，不一定会使用到这把锁，因此，前面所述的锁带来的内存模型含义对这部分代码执行是不适用的。</p>\n<p>其他没用到这把锁的代码，读写是volatile读和volatile写（因为array前面使用volatile关键字修饰）。由volatile来保证happens-before语义。</p>\n<hr>\n<p><b>volatile的特性及原理</b></p>\n<p>volatile 变量自身具有下列特性:<br>（1）可见性。对一个volatile 变量的读,总是能看到(任意线程)对这个volatile变量最后的写入。<br>（2）原子性:对任意单个volatile 变量的读/写具有原子性,但类似于volatile++这种复合操作不具有原子性。</p>\n<p>volatile 写和锁的释放有相同的内存语义。</p>\n<p>为了实现 volatile 的内存语义,编译器在生成字节码时,会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>\n<hr>\n<p>这里调用setArray的原因是，确保set方法对array执行的永远是volatile写。这就和其他对array执行volatile读的线程之间建立了happens-before语义。非常重要的一点：volatile读/写语义针对的是读写操作，而不是使用volatile修饰的变量本身。这样说更直白一点：在一个volatile写操作之前的对其他非volatile变量的写，happens-before于同一个volatile变量读操作之后的对其他变量的读。这句话比较绕，看下面一个例子就比较易懂了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// initial conditions</div><div class=\"line\">int nonVolatileField = 0;</div><div class=\"line\">CopyOnWriteArrayList&lt;String&gt; list = /* a single String */</div><div class=\"line\"></div><div class=\"line\">// Thread 1</div><div class=\"line\">nonVolatileField = 1;                 // (1)</div><div class=\"line\">list.set(0, &quot;x&quot;);                     // (2)</div><div class=\"line\"></div><div class=\"line\">// Thread 2</div><div class=\"line\">String s = list.get(0);               // (3)</div><div class=\"line\">if (s == &quot;x&quot;) &#123;</div><div class=\"line\">    int localVar = nonVolatileField;  // (4)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在假设原始数组中无元素“x”，这样(2)成功设置了元素”x”，(3)处可以成功获取到元素”x”。这种情况下，(4)一定会读取到(1)处设置的值1.因为(2)处的volatile写以及在此之前的任何写操作都happens-before(3)处的读以及之后的所有读。</p>\n<p>但是，假设一开始数组中就有了元素”x”，如果else不调用setArray，那么(2)处的写就不是volatile写，(4)处的读就不一定能读到(1)处设置的值！</p>\n<p>很显然我们不想让内存可见性依赖于list中已有的值，为了确保任何情况下的内存可见性，set方法必须永远都是一个volatile写，这就是为何要在else代码块中调用setArray的原因。</p>\n<p>其他写方法（add、remove）比较易懂，在此不详述。</p>\n<h1 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3 参考资料\"></a>3 参考资料</h1><ul>\n<li><a href=\"http://www.cnblogs.com/skywang12345/p/3498483.html\">Java多线程系列–“JUC集合”02之 CopyOnWriteArrayList</a></li>\n<li><a href=\"http://stackoverflow.com/questions/28772539/why-setarray-method-call-required-in-copyonwritearraylist#\">Why setArray() method call required in CopyOnWriteArrayList</a></li>\n<li><a href=\"http://o8sltkx20.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf\">深入理解java内存模型.pdf</a></li>\n<li><a href=\"http://www.cnblogs.com/dolphin0520/p/3920373.html\">Java并发编程：volatile关键字解析-博客园-海子</a><h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2></li>\n</ul>\n<p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/08/06/CopyOnWriteArrayList与JMM/\">http://xiajunhust.github.io/2016/08/06/CopyOnWriteArrayList与JMM/</a></p>"},{"title":"Hexo GitHub搭建个人博客-增加评论以及访问量统计功能","date":"2016-07-11T10:52:47.000Z","_content":"# 内容概要\n\n本文主要介绍如何为Hexo搭建的博客增加评论功能，采用了多说插件，以及访问量统计功能。\n\n<!-- more -->\n\n# 增加评论功能的步骤\n\n## 注册多说\n\n进入多说官网，点击我要安装，注册账号。填入多说域名（后续会用到）、要使用多说插件的站点地址等信息。\n\n## 修改hexo配置文件\n\n- 在根目录下_config.yml中增加如下内容：\n\n```\nduoshuo_shortname: 你站点的short_name(xiajun)\n```\n\n这里的short_name也就是前面注册多说填入的多说域名。\n\n- 然后将themes\\landscape\\layout_partial\\article.ejs（如果使用的其他主题，文件路径类似）中的如下内容：\n\n```\n<% if (!index && post.comments && config.disqus_shortname){ %>\n\n<section id=\"comments\">\n  <div id=\"disqus_thread\">\n    <noscript>Please enable JavaScript to view the <a href=\"//disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n  </div>\n</section>\n<% } %>\n```\n\n替换为：\n\n```\n<% if (!index && post.comments && config.duoshuo_shortname){ %>\n\n  <section id=\"comments\">\n  <!-- 多说评论框 start -->\n<div id=\"ds-thread\" class=\"ds-thread\" data-thread-key=\"<%= post.path %>\" data-title=\"<%= post.title %>\" data-url=\"<%= post.permalink %>\"></div>\n<!-- 多说评论框 end -->\n<!-- 多说公共JS代码 start (一个网页只需插入一次) -->\n<script type=\"text/javascript\">\nvar duoshuoQuery = {short_name:\"xiajun\"};\n  (function() {\n          var ds = document.createElement('script');\n              ds.type = 'text/javascript';ds.async = true;\n            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';\n              ds.charset = 'UTF-8';\n          (document.getElementsByTagName('head')[0]\n              || document.getElementsByTagName('body')[0]).appendChild(ds);\n  })();\n  </script>\n<!-- 多说公共JS代码 end -->\n  </section>\n  <% } %>\n  \n```\n\n然后将修改部署到github。这个时候刷新博文，就可以发现文章下面多出来的评论窗口。\n发现评论内容会自动刷新，但是评论数量不会更新，不知道是否是多说的一个bug。\n\n# 增加访问量统计功能\n\n- 修改themes/landscape/layout/_partial/after_footer.ejs文件，引入js文件\n\n```\n<script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\">\n</script>\n```\n\n- 然后在我们要展示访问量统计信息的地方添加如下代码\n\n```\n本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n```\n\n部署到github，这个时候就发现对应的地方展示出来了访问量统计信息：\n\n# 参考链接\n- [在hexo中加入多说评论](http://www.lichanglin.cn/%E5%9C%A8hexo%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA/)\n","source":"_posts/Hexo-GitHub搭建个人博客-增加评论以及访问量统计功能.md","raw":"---\ntitle: Hexo GitHub搭建个人博客-增加评论以及访问量统计功能\ndate: 2016-07-11 18:52:47\ntags: 开发工具\n---\n# 内容概要\n\n本文主要介绍如何为Hexo搭建的博客增加评论功能，采用了多说插件，以及访问量统计功能。\n\n<!-- more -->\n\n# 增加评论功能的步骤\n\n## 注册多说\n\n进入多说官网，点击我要安装，注册账号。填入多说域名（后续会用到）、要使用多说插件的站点地址等信息。\n\n## 修改hexo配置文件\n\n- 在根目录下_config.yml中增加如下内容：\n\n```\nduoshuo_shortname: 你站点的short_name(xiajun)\n```\n\n这里的short_name也就是前面注册多说填入的多说域名。\n\n- 然后将themes\\landscape\\layout_partial\\article.ejs（如果使用的其他主题，文件路径类似）中的如下内容：\n\n```\n<% if (!index && post.comments && config.disqus_shortname){ %>\n\n<section id=\"comments\">\n  <div id=\"disqus_thread\">\n    <noscript>Please enable JavaScript to view the <a href=\"//disqus.com/?ref_noscript\">comments powered by Disqus.</a></noscript>\n  </div>\n</section>\n<% } %>\n```\n\n替换为：\n\n```\n<% if (!index && post.comments && config.duoshuo_shortname){ %>\n\n  <section id=\"comments\">\n  <!-- 多说评论框 start -->\n<div id=\"ds-thread\" class=\"ds-thread\" data-thread-key=\"<%= post.path %>\" data-title=\"<%= post.title %>\" data-url=\"<%= post.permalink %>\"></div>\n<!-- 多说评论框 end -->\n<!-- 多说公共JS代码 start (一个网页只需插入一次) -->\n<script type=\"text/javascript\">\nvar duoshuoQuery = {short_name:\"xiajun\"};\n  (function() {\n          var ds = document.createElement('script');\n              ds.type = 'text/javascript';ds.async = true;\n            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';\n              ds.charset = 'UTF-8';\n          (document.getElementsByTagName('head')[0]\n              || document.getElementsByTagName('body')[0]).appendChild(ds);\n  })();\n  </script>\n<!-- 多说公共JS代码 end -->\n  </section>\n  <% } %>\n  \n```\n\n然后将修改部署到github。这个时候刷新博文，就可以发现文章下面多出来的评论窗口。\n发现评论内容会自动刷新，但是评论数量不会更新，不知道是否是多说的一个bug。\n\n# 增加访问量统计功能\n\n- 修改themes/landscape/layout/_partial/after_footer.ejs文件，引入js文件\n\n```\n<script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\">\n</script>\n```\n\n- 然后在我们要展示访问量统计信息的地方添加如下代码\n\n```\n本站总访问量<span id=\"busuanzi_value_site_pv\"></span>次\n本站访客数<span id=\"busuanzi_value_site_uv\"></span>人次\n本文总阅读量<span id=\"busuanzi_value_page_pv\"></span>次\n```\n\n部署到github，这个时候就发现对应的地方展示出来了访问量统计信息：\n\n# 参考链接\n- [在hexo中加入多说评论](http://www.lichanglin.cn/%E5%9C%A8hexo%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA/)\n","slug":"Hexo-GitHub搭建个人博客-增加评论以及访问量统计功能","published":1,"updated":"2016-09-07T08:03:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsbb00042hwf30piewaw","content":"<h1 id=\"内容概要\"><a href=\"#内容概要\" class=\"headerlink\" title=\"内容概要\"></a>内容概要</h1><p>本文主要介绍如何为Hexo搭建的博客增加评论功能，采用了多说插件，以及访问量统计功能。</p>\n<a id=\"more\"></a>\n<h1 id=\"增加评论功能的步骤\"><a href=\"#增加评论功能的步骤\" class=\"headerlink\" title=\"增加评论功能的步骤\"></a>增加评论功能的步骤</h1><h2 id=\"注册多说\"><a href=\"#注册多说\" class=\"headerlink\" title=\"注册多说\"></a>注册多说</h2><p>进入多说官网，点击我要安装，注册账号。填入多说域名（后续会用到）、要使用多说插件的站点地址等信息。</p>\n<h2 id=\"修改hexo配置文件\"><a href=\"#修改hexo配置文件\" class=\"headerlink\" title=\"修改hexo配置文件\"></a>修改hexo配置文件</h2><ul>\n<li>在根目录下_config.yml中增加如下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">duoshuo_shortname: 你站点的short_name(xiajun)</div></pre></td></tr></table></figure>\n<p>这里的short_name也就是前面注册多说填入的多说域名。</p>\n<ul>\n<li>然后将themes\\landscape\\layout_partial\\article.ejs（如果使用的其他主题，文件路径类似）中的如下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;section id=&quot;comments&quot;&gt;</div><div class=\"line\">  &lt;div id=&quot;disqus_thread&quot;&gt;</div><div class=\"line\">    &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">&lt;/section&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<p>替换为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;section id=&quot;comments&quot;&gt;</div><div class=\"line\">  &lt;!-- 多说评论框 start --&gt;</div><div class=\"line\">&lt;div id=&quot;ds-thread&quot; class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.path %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= post.permalink %&gt;&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;!-- 多说评论框 end --&gt;</div><div class=\"line\">&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">var duoshuoQuery = &#123;short_name:&quot;xiajun&quot;&#125;;</div><div class=\"line\">  (function() &#123;</div><div class=\"line\">          var ds = document.createElement(&apos;script&apos;);</div><div class=\"line\">              ds.type = &apos;text/javascript&apos;;ds.async = true;</div><div class=\"line\">            ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;;</div><div class=\"line\">              ds.charset = &apos;UTF-8&apos;;</div><div class=\"line\">          (document.getElementsByTagName(&apos;head&apos;)[0]</div><div class=\"line\">              || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);</div><div class=\"line\">  &#125;)();</div><div class=\"line\">  &lt;/script&gt;</div><div class=\"line\">&lt;!-- 多说公共JS代码 end --&gt;</div><div class=\"line\">  &lt;/section&gt;</div><div class=\"line\">  &lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<p>然后将修改部署到github。这个时候刷新博文，就可以发现文章下面多出来的评论窗口。<br>发现评论内容会自动刷新，但是评论数量不会更新，不知道是否是多说的一个bug。</p>\n<h1 id=\"增加访问量统计功能\"><a href=\"#增加访问量统计功能\" class=\"headerlink\" title=\"增加访问量统计功能\"></a>增加访问量统计功能</h1><ul>\n<li>修改themes/landscape/layout/_partial/after_footer.ejs文件，引入js文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>然后在我们要展示访问量统计信息的地方添加如下代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</div><div class=\"line\">本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次</div><div class=\"line\">本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次</div></pre></td></tr></table></figure>\n<p>部署到github，这个时候就发现对应的地方展示出来了访问量统计信息：</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"http://www.lichanglin.cn/%E5%9C%A8hexo%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA/\" target=\"_blank\" rel=\"external\">在hexo中加入多说评论</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/07/11/Hexo-GitHub搭建个人博客-增加评论以及访问量统计功能/\">http://xiajunhust.github.io/2016/07/11/Hexo-GitHub搭建个人博客-增加评论以及访问量统计功能/</a></p>\n","excerpt":"<h1 id=\"内容概要\"><a href=\"#内容概要\" class=\"headerlink\" title=\"内容概要\"></a>内容概要</h1><p>本文主要介绍如何为Hexo搭建的博客增加评论功能，采用了多说插件，以及访问量统计功能。</p>","more":"<h1 id=\"增加评论功能的步骤\"><a href=\"#增加评论功能的步骤\" class=\"headerlink\" title=\"增加评论功能的步骤\"></a>增加评论功能的步骤</h1><h2 id=\"注册多说\"><a href=\"#注册多说\" class=\"headerlink\" title=\"注册多说\"></a>注册多说</h2><p>进入多说官网，点击我要安装，注册账号。填入多说域名（后续会用到）、要使用多说插件的站点地址等信息。</p>\n<h2 id=\"修改hexo配置文件\"><a href=\"#修改hexo配置文件\" class=\"headerlink\" title=\"修改hexo配置文件\"></a>修改hexo配置文件</h2><ul>\n<li>在根目录下_config.yml中增加如下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">duoshuo_shortname: 你站点的short_name(xiajun)</div></pre></td></tr></table></figure>\n<p>这里的short_name也就是前面注册多说填入的多说域名。</p>\n<ul>\n<li>然后将themes\\landscape\\layout_partial\\article.ejs（如果使用的其他主题，文件路径类似）中的如下内容：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;section id=&quot;comments&quot;&gt;</div><div class=\"line\">  &lt;div id=&quot;disqus_thread&quot;&gt;</div><div class=\"line\">    &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">&lt;/section&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<p>替换为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;section id=&quot;comments&quot;&gt;</div><div class=\"line\">  &lt;!-- 多说评论框 start --&gt;</div><div class=\"line\">&lt;div id=&quot;ds-thread&quot; class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.path %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= post.permalink %&gt;&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;!-- 多说评论框 end --&gt;</div><div class=\"line\">&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">var duoshuoQuery = &#123;short_name:&quot;xiajun&quot;&#125;;</div><div class=\"line\">  (function() &#123;</div><div class=\"line\">          var ds = document.createElement(&apos;script&apos;);</div><div class=\"line\">              ds.type = &apos;text/javascript&apos;;ds.async = true;</div><div class=\"line\">            ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;;</div><div class=\"line\">              ds.charset = &apos;UTF-8&apos;;</div><div class=\"line\">          (document.getElementsByTagName(&apos;head&apos;)[0]</div><div class=\"line\">              || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds);</div><div class=\"line\">  &#125;)();</div><div class=\"line\">  &lt;/script&gt;</div><div class=\"line\">&lt;!-- 多说公共JS代码 end --&gt;</div><div class=\"line\">  &lt;/section&gt;</div><div class=\"line\">  &lt;% &#125; %&gt;</div></pre></td></tr></table></figure>\n<p>然后将修改部署到github。这个时候刷新博文，就可以发现文章下面多出来的评论窗口。<br>发现评论内容会自动刷新，但是评论数量不会更新，不知道是否是多说的一个bug。</p>\n<h1 id=\"增加访问量统计功能\"><a href=\"#增加访问量统计功能\" class=\"headerlink\" title=\"增加访问量统计功能\"></a>增加访问量统计功能</h1><ul>\n<li>修改themes/landscape/layout/_partial/after_footer.ejs文件，引入js文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>然后在我们要展示访问量统计信息的地方添加如下代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</div><div class=\"line\">本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次</div><div class=\"line\">本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次</div></pre></td></tr></table></figure>\n<p>部署到github，这个时候就发现对应的地方展示出来了访问量统计信息：</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"http://www.lichanglin.cn/%E5%9C%A8hexo%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA/\">在hexo中加入多说评论</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/07/11/Hexo-GitHub搭建个人博客-增加评论以及访问量统计功能/\">http://xiajunhust.github.io/2016/07/11/Hexo-GitHub搭建个人博客-增加评论以及访问量统计功能/</a></p>"},{"title":"Hexo GitHub搭建个人博客-添加README","date":"2016-07-11T10:05:12.000Z","_content":"# 概要\n\n当我们使用Hexo+Github搭建好个人博客环境之后，默认Github上repository中是没有Readme的。本文主要介绍如何添加Readme。\n\n<!-- more -->\n\n# 如何添加Readme\n\n如果我们直接在Github上增加Readme文件，在执行了hexo d部署命令之后，Readme文件会自动消失。\n\n# 解决办法\n将我们要添加的Readme.md文件放入本地hexo工作目录的source根目录下，然后修改_config.yml文件，在skip_render后增加我们添加的文件名README.md：\n\n```\nskip_render: [README.md](http://README.md)  \n```\n\n需要注意的是，冒号后一定要有空格， 否则运行hexo g命令的时候会出现莫名其妙的错误：\n\n```\nxiajundeMacBook-Pro:hexo xiajun$ sudo hexo d  \nFATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 30, column 1:  \n    # Writing  \n    ^  \nYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 30, column 1:  \n    # Writing  \n    ^  \n    at generateError (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:162:10)  \n    at throwError (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:168:9)  \n    at readBlockMapping (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1040:9)  \n    at composeNode (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1326:12)  \n    at readDocument (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1488:3)  \n    at loadDocuments (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1544:5)  \n    at Object.load (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1561:19)  \n    at Hexo.yamlHelper (/Users/xiajun/hexo/node_modules/hexo/lib/plugins/renderer/yaml.js:7:15)  \n    at Hexo.tryCatcher (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/util.js:16:23)  \n    at Hexo.&lt;anonymous&gt; (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/method.js:15:34)  \n    at /Users/xiajun/hexo/node_modules/hexo/lib/hexo/render.js:59:21  \n    at tryCatcher (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/util.js:16:23)  \n    at Promise._settlePromiseFromHandler (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:502:31)  \n    at Promise._settlePromise (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:559:18)  \n    at Promise._settlePromise0 (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:604:10)  \n    at Promise._settlePromises (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:683:18)  \n    at Async._drainQueue (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:138:16)  \n    at Async._drainQueues (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:148:10)  \n    at Immediate.Async.drainQueues [as _onImmediate] (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:17:14)  \n    at processImmediate [as _immediateCallback] (timers.js:368:17)  \n```\n\n然后我们执行部署命令部署到github，就可以看到repository中有了Readme文件，并且下次再次部署的时候，依然存在。\n\n关于skip_render的含义，官方文档解释是：  \n跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\n# 参考链接\n\n[How can I tell Hexo to ignore a file when creating posts?-StackOverflow](http://stackoverflow.com/questions/31494145/how-can-i-tell-hexo-to-ignore-a-file-when-creating-posts)  \n[Hexo \\_posts目录, skip_render 的说明](http://www.yczmm.com/hexo-skip_render.html)  \n[Hexo官方文档](https://hexo.io/zh-cn/docs/configuration.html)","source":"_posts/Hexo-GitHub搭建个人博客-添加README.md","raw":"---\ntitle: Hexo GitHub搭建个人博客-添加README\ndate: 2016-07-11 18:05:12\ntags: 开发工具\n---\n# 概要\n\n当我们使用Hexo+Github搭建好个人博客环境之后，默认Github上repository中是没有Readme的。本文主要介绍如何添加Readme。\n\n<!-- more -->\n\n# 如何添加Readme\n\n如果我们直接在Github上增加Readme文件，在执行了hexo d部署命令之后，Readme文件会自动消失。\n\n# 解决办法\n将我们要添加的Readme.md文件放入本地hexo工作目录的source根目录下，然后修改_config.yml文件，在skip_render后增加我们添加的文件名README.md：\n\n```\nskip_render: [README.md](http://README.md)  \n```\n\n需要注意的是，冒号后一定要有空格， 否则运行hexo g命令的时候会出现莫名其妙的错误：\n\n```\nxiajundeMacBook-Pro:hexo xiajun$ sudo hexo d  \nFATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 30, column 1:  \n    # Writing  \n    ^  \nYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 30, column 1:  \n    # Writing  \n    ^  \n    at generateError (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:162:10)  \n    at throwError (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:168:9)  \n    at readBlockMapping (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1040:9)  \n    at composeNode (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1326:12)  \n    at readDocument (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1488:3)  \n    at loadDocuments (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1544:5)  \n    at Object.load (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1561:19)  \n    at Hexo.yamlHelper (/Users/xiajun/hexo/node_modules/hexo/lib/plugins/renderer/yaml.js:7:15)  \n    at Hexo.tryCatcher (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/util.js:16:23)  \n    at Hexo.&lt;anonymous&gt; (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/method.js:15:34)  \n    at /Users/xiajun/hexo/node_modules/hexo/lib/hexo/render.js:59:21  \n    at tryCatcher (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/util.js:16:23)  \n    at Promise._settlePromiseFromHandler (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:502:31)  \n    at Promise._settlePromise (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:559:18)  \n    at Promise._settlePromise0 (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:604:10)  \n    at Promise._settlePromises (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:683:18)  \n    at Async._drainQueue (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:138:16)  \n    at Async._drainQueues (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:148:10)  \n    at Immediate.Async.drainQueues [as _onImmediate] (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:17:14)  \n    at processImmediate [as _immediateCallback] (timers.js:368:17)  \n```\n\n然后我们执行部署命令部署到github，就可以看到repository中有了Readme文件，并且下次再次部署的时候，依然存在。\n\n关于skip_render的含义，官方文档解释是：  \n跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\n# 参考链接\n\n[How can I tell Hexo to ignore a file when creating posts?-StackOverflow](http://stackoverflow.com/questions/31494145/how-can-i-tell-hexo-to-ignore-a-file-when-creating-posts)  \n[Hexo \\_posts目录, skip_render 的说明](http://www.yczmm.com/hexo-skip_render.html)  \n[Hexo官方文档](https://hexo.io/zh-cn/docs/configuration.html)","slug":"Hexo-GitHub搭建个人博客-添加README","published":1,"updated":"2016-09-07T08:03:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsbh00052hwf9favs0fs","content":"<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><p>当我们使用Hexo+Github搭建好个人博客环境之后，默认Github上repository中是没有Readme的。本文主要介绍如何添加Readme。</p>\n<a id=\"more\"></a>\n<h1 id=\"如何添加Readme\"><a href=\"#如何添加Readme\" class=\"headerlink\" title=\"如何添加Readme\"></a>如何添加Readme</h1><p>如果我们直接在Github上增加Readme文件，在执行了hexo d部署命令之后，Readme文件会自动消失。</p>\n<h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><p>将我们要添加的Readme.md文件放入本地hexo工作目录的source根目录下，然后修改_config.yml文件，在skip_render后增加我们添加的文件名README.md：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">skip_render: [README.md](http://README.md)</div></pre></td></tr></table></figure>\n<p>需要注意的是，冒号后一定要有空格， 否则运行hexo g命令的时候会出现莫名其妙的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiajundeMacBook-Pro:hexo xiajun$ sudo hexo d  </div><div class=\"line\">FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 30, column 1:  </div><div class=\"line\">    # Writing  </div><div class=\"line\">    ^  </div><div class=\"line\">YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 30, column 1:  </div><div class=\"line\">    # Writing  </div><div class=\"line\">    ^  </div><div class=\"line\">    at generateError (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:162:10)  </div><div class=\"line\">    at throwError (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:168:9)  </div><div class=\"line\">    at readBlockMapping (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1040:9)  </div><div class=\"line\">    at composeNode (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1326:12)  </div><div class=\"line\">    at readDocument (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1488:3)  </div><div class=\"line\">    at loadDocuments (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1544:5)  </div><div class=\"line\">    at Object.load (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1561:19)  </div><div class=\"line\">    at Hexo.yamlHelper (/Users/xiajun/hexo/node_modules/hexo/lib/plugins/renderer/yaml.js:7:15)  </div><div class=\"line\">    at Hexo.tryCatcher (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/util.js:16:23)  </div><div class=\"line\">    at Hexo.&amp;lt;anonymous&amp;gt; (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/method.js:15:34)  </div><div class=\"line\">    at /Users/xiajun/hexo/node_modules/hexo/lib/hexo/render.js:59:21  </div><div class=\"line\">    at tryCatcher (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/util.js:16:23)  </div><div class=\"line\">    at Promise._settlePromiseFromHandler (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:502:31)  </div><div class=\"line\">    at Promise._settlePromise (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:559:18)  </div><div class=\"line\">    at Promise._settlePromise0 (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:604:10)  </div><div class=\"line\">    at Promise._settlePromises (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:683:18)  </div><div class=\"line\">    at Async._drainQueue (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:138:16)  </div><div class=\"line\">    at Async._drainQueues (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:148:10)  </div><div class=\"line\">    at Immediate.Async.drainQueues [as _onImmediate] (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:17:14)  </div><div class=\"line\">    at processImmediate [as _immediateCallback] (timers.js:368:17)</div></pre></td></tr></table></figure>\n<p>然后我们执行部署命令部署到github，就可以看到repository中有了Readme文件，并且下次再次部署的时候，依然存在。</p>\n<p>关于skip_render的含义，官方文档解释是：<br>跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"http://stackoverflow.com/questions/31494145/how-can-i-tell-hexo-to-ignore-a-file-when-creating-posts\" target=\"_blank\" rel=\"external\">How can I tell Hexo to ignore a file when creating posts?-StackOverflow</a><br><a href=\"http://www.yczmm.com/hexo-skip_render.html\" target=\"_blank\" rel=\"external\">Hexo _posts目录, skip_render 的说明</a><br><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"external\">Hexo官方文档</a></p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/07/11/Hexo-GitHub搭建个人博客-添加README/\">http://xiajunhust.github.io/2016/07/11/Hexo-GitHub搭建个人博客-添加README/</a></p>\n","excerpt":"<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><p>当我们使用Hexo+Github搭建好个人博客环境之后，默认Github上repository中是没有Readme的。本文主要介绍如何添加Readme。</p>","more":"<h1 id=\"如何添加Readme\"><a href=\"#如何添加Readme\" class=\"headerlink\" title=\"如何添加Readme\"></a>如何添加Readme</h1><p>如果我们直接在Github上增加Readme文件，在执行了hexo d部署命令之后，Readme文件会自动消失。</p>\n<h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><p>将我们要添加的Readme.md文件放入本地hexo工作目录的source根目录下，然后修改_config.yml文件，在skip_render后增加我们添加的文件名README.md：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">skip_render: [README.md](http://README.md)</div></pre></td></tr></table></figure>\n<p>需要注意的是，冒号后一定要有空格， 否则运行hexo g命令的时候会出现莫名其妙的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiajundeMacBook-Pro:hexo xiajun$ sudo hexo d  </div><div class=\"line\">FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 30, column 1:  </div><div class=\"line\">    # Writing  </div><div class=\"line\">    ^  </div><div class=\"line\">YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 30, column 1:  </div><div class=\"line\">    # Writing  </div><div class=\"line\">    ^  </div><div class=\"line\">    at generateError (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:162:10)  </div><div class=\"line\">    at throwError (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:168:9)  </div><div class=\"line\">    at readBlockMapping (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1040:9)  </div><div class=\"line\">    at composeNode (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1326:12)  </div><div class=\"line\">    at readDocument (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1488:3)  </div><div class=\"line\">    at loadDocuments (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1544:5)  </div><div class=\"line\">    at Object.load (/Users/xiajun/hexo/node_modules/hexo/node_modules/js-yaml/lib/js-yaml/loader.js:1561:19)  </div><div class=\"line\">    at Hexo.yamlHelper (/Users/xiajun/hexo/node_modules/hexo/lib/plugins/renderer/yaml.js:7:15)  </div><div class=\"line\">    at Hexo.tryCatcher (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/util.js:16:23)  </div><div class=\"line\">    at Hexo.&amp;lt;anonymous&amp;gt; (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/method.js:15:34)  </div><div class=\"line\">    at /Users/xiajun/hexo/node_modules/hexo/lib/hexo/render.js:59:21  </div><div class=\"line\">    at tryCatcher (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/util.js:16:23)  </div><div class=\"line\">    at Promise._settlePromiseFromHandler (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:502:31)  </div><div class=\"line\">    at Promise._settlePromise (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:559:18)  </div><div class=\"line\">    at Promise._settlePromise0 (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:604:10)  </div><div class=\"line\">    at Promise._settlePromises (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/promise.js:683:18)  </div><div class=\"line\">    at Async._drainQueue (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:138:16)  </div><div class=\"line\">    at Async._drainQueues (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:148:10)  </div><div class=\"line\">    at Immediate.Async.drainQueues [as _onImmediate] (/Users/xiajun/hexo/node_modules/hexo/node_modules/bluebird/js/release/async.js:17:14)  </div><div class=\"line\">    at processImmediate [as _immediateCallback] (timers.js:368:17)</div></pre></td></tr></table></figure>\n<p>然后我们执行部署命令部署到github，就可以看到repository中有了Readme文件，并且下次再次部署的时候，依然存在。</p>\n<p>关于skip_render的含义，官方文档解释是：<br>跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"http://stackoverflow.com/questions/31494145/how-can-i-tell-hexo-to-ignore-a-file-when-creating-posts\">How can I tell Hexo to ignore a file when creating posts?-StackOverflow</a><br><a href=\"http://www.yczmm.com/hexo-skip_render.html\">Hexo _posts目录, skip_render 的说明</a><br><a href=\"https://hexo.io/zh-cn/docs/configuration.html\">Hexo官方文档</a></p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/07/11/Hexo-GitHub搭建个人博客-添加README/\">http://xiajunhust.github.io/2016/07/11/Hexo-GitHub搭建个人博客-添加README/</a></p>"},{"title":"MySQL的日期时间类型关于秒以下精度的处理","date":"2016-08-28T12:58:10.000Z","_content":"\n# 1 MySQL中日期和时间的表示\n\nMySQL中有多种数据类型可以用于日期和时间的表示：\n\n![](http://o8sltkx20.bkt.clouddn.com/MySQL-base-001.png)\n\n<!-- more -->\n\n常用的是如下三种：  \n（1）DATE：表示年月日  \n（2）DATETIME：表示年月日时分秒  \n（3）TIME：只需要表示时分秒  \n\nDATETIME和TIMESTAMP很类似，但是有如下区别：  \n（1）TIMESTAMP支持的时间范围较小  \n（2）在插入或者更新时不明确指定TIMESTAMP列的值时，系统将会设置为当前日期和时间。当值超出最大值值，将会使用默认值“0000-00-00 00:00”  \n（3）TIMESTAMP的插入和更新都受到当地时区的影响  \n（4）TIMESTAMP受MySQL版本和服务器SQLMode的影响很大  \n\n# 2 MySQL日期时间对秒以下精度的支持\n\n<b>MySQL在5.6.4以及更高版本提供了对秒以下精度时间的存储支持，在以前的版本是会将秒以下的精度忽略掉的。</b>TIME、TIMESTAMP、DATETIME均提供了小数点后6位的支持（微秒）。如果我们想定义一个能存储秒以下精度的日期时间字段，可以如下做，在类型字段后面指定小数点后的精度位数：\n\n```\nCREATE TABLE t1 (t TIME(3), dt DATETIME(6));\n```\n\n如果我们朝数据库中插入一条记录，时间的精度位数大于表字段能表示的位数，则会造成四舍五入：\n\n```\nmysql> CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );\nQuery OK, 0 rows affected (0.33 sec)\n\nmysql> INSERT INTO fractest VALUES\n     > ('17:51:04.777', '2014-09-08 17:51:04.777', '2014-09-08 17:51:04.777');\nQuery OK, 1 row affected (0.03 sec)\n\nmysql> SELECT * FROM fractest;\n+-------------+------------------------+------------------------+\n| c1          | c2                     | c3                     |\n+-------------+------------------------+------------------------+\n| 17:51:04.78 | 2014-09-08 17:51:04.78 | 2014-09-08 17:51:04.78 |\n+-------------+------------------------+------------------------+\n1 row in set (0.00 sec)\n```\n\n<b>并且不会有任何警告，这点尤其要注意。</b>\n\n截断在数据库server端，connector是会将毫秒部分一并提交给server的。我们可以看下mysql-connector-java jar中的源码：\n\n```\n\n/**\n * Set a parameter to a java.sql.Timestamp value. The driver converts this\n * to a SQL TIMESTAMP value when it sends it to the database.\n * \n * @param parameterIndex\n *            the first parameter is 1, the second is 2, ...\n * @param x\n *            the parameter value\n * @param tz\n *            the timezone to use\n * \n * @throws SQLException\n *             if a database-access error occurs.\n */\nprivate void setTimestampInternal(int parameterIndex,\n\t\tTimestamp x, Calendar targetCalendar,\n\t\tTimeZone tz, boolean rollForward) throws SQLException {\n\tsynchronized (checkClosed().getConnectionMutex()) {\n\t\tif (x == null) {\n\t\t\tsetNull(parameterIndex, java.sql.Types.TIMESTAMP);\n\t\t} else {\n\t\t\tcheckClosed();\n\t\t\t\n\t\t\tif (!this.useLegacyDatetimeCode) {\n\t\t\t\tnewSetTimestampInternal(parameterIndex, x, targetCalendar);\n\t\t\t} else {\n\t\t\t\tCalendar sessionCalendar = this.connection.getUseJDBCCompliantTimezoneShift() ?\n\t\t\t\t\t\tthis.connection.getUtcCalendar() : \n\t\t\t\t\t\t\tgetCalendarInstanceForSessionOrNew();\n\t\t\t\t\t\n\t\t\t\tsynchronized (sessionCalendar) {\n\t\t\t\t\tx = TimeUtil.changeTimezone(this.connection, \n\t\t\t\t\t\t\tsessionCalendar,\n\t\t\t\t\t\t\ttargetCalendar,\n\t\t\t\t\t\t\tx, tz, this.connection\n\t\t\t\t\t\t.getServerTimezoneTZ(), rollForward);\n\t\t\t\t}\n\t\n\t\t\t\tif (this.connection.getUseSSPSCompatibleTimezoneShift()) {\n\t\t\t\t\tdoSSPSCompatibleTimezoneShift(parameterIndex, x, sessionCalendar);\n\t\t\t\t} else {\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tif (this.tsdf == null) {\n\t\t\t\t\t\t\tthis.tsdf = new SimpleDateFormat(\"''yyyy-MM-dd HH:mm:ss\", Locale.US); //$NON-NLS-1$\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tStringBuffer buf = new StringBuffer();\n\t\t\t\t\t\tbuf.append(this.tsdf.format(x));\n\n\t\t\t\t\t\tif (this.serverSupportsFracSecs) {\n\t\t\t\t\t\t\tint nanos = x.getNanos();\n\t\t\t\t\t\t\t//精确到了纳秒\n\t\t\t\t\t\t\tif (nanos != 0) {\n\t\t\t\t\t\t\t\tbuf.append('.');\n\t\t\t\t\t\t\t\tbuf.append(TimeUtil.formatNanos(nanos, this.serverSupportsFracSecs, true));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbuf.append('\\'');\n\n\t\t\t\t\t\tsetInternal(parameterIndex, buf.toString()); // SimpleDateFormat is not\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // thread-safe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.parameterTypes[parameterIndex - 1 + getParameterIndexOffset()] = Types.TIMESTAMP;\n\t\t}\n\t}\n}\n```\n\n如果使用的是mysql 5.6以下的版本，可以增加一个字段专门用来存储秒以下的精度：\n\n```\nCREATE TABLE your_table (\n  dt datetime,\n  us int\n);\n\nINSERT INTO your_table VALUES\n('2011-11-11 11:11:11.111111', MICROSECOND('2011-11-11 11:11:11.111111'));\n```\n\n# 3 参考资料\n\n(1)[MySQL Reference Manual](https://dev.mysql.com/doc/refman/5.6/en/fractional-seconds.html)  \n(2)[http://www.yufengof.com/2015/08/17/mysql-datetime-type-millisecond-rounding/](http://www.yufengof.com/2015/08/17/mysql-datetime-type-millisecond-rounding/)  \n(3)[how-to-insert-a-microsecond-precision-datetime-into-mysql](http://stackoverflow.com/questions/14038746/how-to-insert-a-microsecond-precision-datetime-into-mysql)","source":"_posts/MySQL的日期时间类型关于秒以下精度的处理.md","raw":"---\ntitle: MySQL的日期时间类型关于秒以下精度的处理\ndate: 2016-08-28 20:58:10\ntags: MySQL\n---\n\n# 1 MySQL中日期和时间的表示\n\nMySQL中有多种数据类型可以用于日期和时间的表示：\n\n![](http://o8sltkx20.bkt.clouddn.com/MySQL-base-001.png)\n\n<!-- more -->\n\n常用的是如下三种：  \n（1）DATE：表示年月日  \n（2）DATETIME：表示年月日时分秒  \n（3）TIME：只需要表示时分秒  \n\nDATETIME和TIMESTAMP很类似，但是有如下区别：  \n（1）TIMESTAMP支持的时间范围较小  \n（2）在插入或者更新时不明确指定TIMESTAMP列的值时，系统将会设置为当前日期和时间。当值超出最大值值，将会使用默认值“0000-00-00 00:00”  \n（3）TIMESTAMP的插入和更新都受到当地时区的影响  \n（4）TIMESTAMP受MySQL版本和服务器SQLMode的影响很大  \n\n# 2 MySQL日期时间对秒以下精度的支持\n\n<b>MySQL在5.6.4以及更高版本提供了对秒以下精度时间的存储支持，在以前的版本是会将秒以下的精度忽略掉的。</b>TIME、TIMESTAMP、DATETIME均提供了小数点后6位的支持（微秒）。如果我们想定义一个能存储秒以下精度的日期时间字段，可以如下做，在类型字段后面指定小数点后的精度位数：\n\n```\nCREATE TABLE t1 (t TIME(3), dt DATETIME(6));\n```\n\n如果我们朝数据库中插入一条记录，时间的精度位数大于表字段能表示的位数，则会造成四舍五入：\n\n```\nmysql> CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );\nQuery OK, 0 rows affected (0.33 sec)\n\nmysql> INSERT INTO fractest VALUES\n     > ('17:51:04.777', '2014-09-08 17:51:04.777', '2014-09-08 17:51:04.777');\nQuery OK, 1 row affected (0.03 sec)\n\nmysql> SELECT * FROM fractest;\n+-------------+------------------------+------------------------+\n| c1          | c2                     | c3                     |\n+-------------+------------------------+------------------------+\n| 17:51:04.78 | 2014-09-08 17:51:04.78 | 2014-09-08 17:51:04.78 |\n+-------------+------------------------+------------------------+\n1 row in set (0.00 sec)\n```\n\n<b>并且不会有任何警告，这点尤其要注意。</b>\n\n截断在数据库server端，connector是会将毫秒部分一并提交给server的。我们可以看下mysql-connector-java jar中的源码：\n\n```\n\n/**\n * Set a parameter to a java.sql.Timestamp value. The driver converts this\n * to a SQL TIMESTAMP value when it sends it to the database.\n * \n * @param parameterIndex\n *            the first parameter is 1, the second is 2, ...\n * @param x\n *            the parameter value\n * @param tz\n *            the timezone to use\n * \n * @throws SQLException\n *             if a database-access error occurs.\n */\nprivate void setTimestampInternal(int parameterIndex,\n\t\tTimestamp x, Calendar targetCalendar,\n\t\tTimeZone tz, boolean rollForward) throws SQLException {\n\tsynchronized (checkClosed().getConnectionMutex()) {\n\t\tif (x == null) {\n\t\t\tsetNull(parameterIndex, java.sql.Types.TIMESTAMP);\n\t\t} else {\n\t\t\tcheckClosed();\n\t\t\t\n\t\t\tif (!this.useLegacyDatetimeCode) {\n\t\t\t\tnewSetTimestampInternal(parameterIndex, x, targetCalendar);\n\t\t\t} else {\n\t\t\t\tCalendar sessionCalendar = this.connection.getUseJDBCCompliantTimezoneShift() ?\n\t\t\t\t\t\tthis.connection.getUtcCalendar() : \n\t\t\t\t\t\t\tgetCalendarInstanceForSessionOrNew();\n\t\t\t\t\t\n\t\t\t\tsynchronized (sessionCalendar) {\n\t\t\t\t\tx = TimeUtil.changeTimezone(this.connection, \n\t\t\t\t\t\t\tsessionCalendar,\n\t\t\t\t\t\t\ttargetCalendar,\n\t\t\t\t\t\t\tx, tz, this.connection\n\t\t\t\t\t\t.getServerTimezoneTZ(), rollForward);\n\t\t\t\t}\n\t\n\t\t\t\tif (this.connection.getUseSSPSCompatibleTimezoneShift()) {\n\t\t\t\t\tdoSSPSCompatibleTimezoneShift(parameterIndex, x, sessionCalendar);\n\t\t\t\t} else {\n\t\t\t\t\tsynchronized (this) {\n\t\t\t\t\t\tif (this.tsdf == null) {\n\t\t\t\t\t\t\tthis.tsdf = new SimpleDateFormat(\"''yyyy-MM-dd HH:mm:ss\", Locale.US); //$NON-NLS-1$\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tStringBuffer buf = new StringBuffer();\n\t\t\t\t\t\tbuf.append(this.tsdf.format(x));\n\n\t\t\t\t\t\tif (this.serverSupportsFracSecs) {\n\t\t\t\t\t\t\tint nanos = x.getNanos();\n\t\t\t\t\t\t\t//精确到了纳秒\n\t\t\t\t\t\t\tif (nanos != 0) {\n\t\t\t\t\t\t\t\tbuf.append('.');\n\t\t\t\t\t\t\t\tbuf.append(TimeUtil.formatNanos(nanos, this.serverSupportsFracSecs, true));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbuf.append('\\'');\n\n\t\t\t\t\t\tsetInternal(parameterIndex, buf.toString()); // SimpleDateFormat is not\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // thread-safe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.parameterTypes[parameterIndex - 1 + getParameterIndexOffset()] = Types.TIMESTAMP;\n\t\t}\n\t}\n}\n```\n\n如果使用的是mysql 5.6以下的版本，可以增加一个字段专门用来存储秒以下的精度：\n\n```\nCREATE TABLE your_table (\n  dt datetime,\n  us int\n);\n\nINSERT INTO your_table VALUES\n('2011-11-11 11:11:11.111111', MICROSECOND('2011-11-11 11:11:11.111111'));\n```\n\n# 3 参考资料\n\n(1)[MySQL Reference Manual](https://dev.mysql.com/doc/refman/5.6/en/fractional-seconds.html)  \n(2)[http://www.yufengof.com/2015/08/17/mysql-datetime-type-millisecond-rounding/](http://www.yufengof.com/2015/08/17/mysql-datetime-type-millisecond-rounding/)  \n(3)[how-to-insert-a-microsecond-precision-datetime-into-mysql](http://stackoverflow.com/questions/14038746/how-to-insert-a-microsecond-precision-datetime-into-mysql)","slug":"MySQL的日期时间类型关于秒以下精度的处理","published":1,"updated":"2016-09-08T01:11:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsbl00072hwfihn9cegj","content":"<h1 id=\"1-MySQL中日期和时间的表示\"><a href=\"#1-MySQL中日期和时间的表示\" class=\"headerlink\" title=\"1 MySQL中日期和时间的表示\"></a>1 MySQL中日期和时间的表示</h1><p>MySQL中有多种数据类型可以用于日期和时间的表示：</p>\n<p><img src=\"http://o8sltkx20.bkt.clouddn.com/MySQL-base-001.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>常用的是如下三种：<br>（1）DATE：表示年月日<br>（2）DATETIME：表示年月日时分秒<br>（3）TIME：只需要表示时分秒  </p>\n<p>DATETIME和TIMESTAMP很类似，但是有如下区别：<br>（1）TIMESTAMP支持的时间范围较小<br>（2）在插入或者更新时不明确指定TIMESTAMP列的值时，系统将会设置为当前日期和时间。当值超出最大值值，将会使用默认值“0000-00-00 00:00”<br>（3）TIMESTAMP的插入和更新都受到当地时区的影响<br>（4）TIMESTAMP受MySQL版本和服务器SQLMode的影响很大  </p>\n<h1 id=\"2-MySQL日期时间对秒以下精度的支持\"><a href=\"#2-MySQL日期时间对秒以下精度的支持\" class=\"headerlink\" title=\"2 MySQL日期时间对秒以下精度的支持\"></a>2 MySQL日期时间对秒以下精度的支持</h1><p><b>MySQL在5.6.4以及更高版本提供了对秒以下精度时间的存储支持，在以前的版本是会将秒以下的精度忽略掉的。</b>TIME、TIMESTAMP、DATETIME均提供了小数点后6位的支持（微秒）。如果我们想定义一个能存储秒以下精度的日期时间字段，可以如下做，在类型字段后面指定小数点后的精度位数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE TABLE t1 (t TIME(3), dt DATETIME(6));</div></pre></td></tr></table></figure>\n<p>如果我们朝数据库中插入一条记录，时间的精度位数大于表字段能表示的位数，则会造成四舍五入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">mysql&gt; CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );</div><div class=\"line\">Query OK, 0 rows affected (0.33 sec)</div><div class=\"line\"></div><div class=\"line\">mysql&gt; INSERT INTO fractest VALUES</div><div class=\"line\">     &gt; (&apos;17:51:04.777&apos;, &apos;2014-09-08 17:51:04.777&apos;, &apos;2014-09-08 17:51:04.777&apos;);</div><div class=\"line\">Query OK, 1 row affected (0.03 sec)</div><div class=\"line\"></div><div class=\"line\">mysql&gt; SELECT * FROM fractest;</div><div class=\"line\">+-------------+------------------------+------------------------+</div><div class=\"line\">| c1          | c2                     | c3                     |</div><div class=\"line\">+-------------+------------------------+------------------------+</div><div class=\"line\">| 17:51:04.78 | 2014-09-08 17:51:04.78 | 2014-09-08 17:51:04.78 |</div><div class=\"line\">+-------------+------------------------+------------------------+</div><div class=\"line\">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>\n<p><b>并且不会有任何警告，这点尤其要注意。</b></p>\n<p>截断在数据库server端，connector是会将毫秒部分一并提交给server的。我们可以看下mysql-connector-java jar中的源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Set a parameter to a java.sql.Timestamp value. The driver converts this</div><div class=\"line\"> * to a SQL TIMESTAMP value when it sends it to the database.</div><div class=\"line\"> * </div><div class=\"line\"> * @param parameterIndex</div><div class=\"line\"> *            the first parameter is 1, the second is 2, ...</div><div class=\"line\"> * @param x</div><div class=\"line\"> *            the parameter value</div><div class=\"line\"> * @param tz</div><div class=\"line\"> *            the timezone to use</div><div class=\"line\"> * </div><div class=\"line\"> * @throws SQLException</div><div class=\"line\"> *             if a database-access error occurs.</div><div class=\"line\"> */</div><div class=\"line\">private void setTimestampInternal(int parameterIndex,</div><div class=\"line\">\t\tTimestamp x, Calendar targetCalendar,</div><div class=\"line\">\t\tTimeZone tz, boolean rollForward) throws SQLException &#123;</div><div class=\"line\">\tsynchronized (checkClosed().getConnectionMutex()) &#123;</div><div class=\"line\">\t\tif (x == null) &#123;</div><div class=\"line\">\t\t\tsetNull(parameterIndex, java.sql.Types.TIMESTAMP);</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tcheckClosed();</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\tif (!this.useLegacyDatetimeCode) &#123;</div><div class=\"line\">\t\t\t\tnewSetTimestampInternal(parameterIndex, x, targetCalendar);</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\tCalendar sessionCalendar = this.connection.getUseJDBCCompliantTimezoneShift() ?</div><div class=\"line\">\t\t\t\t\t\tthis.connection.getUtcCalendar() : </div><div class=\"line\">\t\t\t\t\t\t\tgetCalendarInstanceForSessionOrNew();</div><div class=\"line\">\t\t\t\t\t</div><div class=\"line\">\t\t\t\tsynchronized (sessionCalendar) &#123;</div><div class=\"line\">\t\t\t\t\tx = TimeUtil.changeTimezone(this.connection, </div><div class=\"line\">\t\t\t\t\t\t\tsessionCalendar,</div><div class=\"line\">\t\t\t\t\t\t\ttargetCalendar,</div><div class=\"line\">\t\t\t\t\t\t\tx, tz, this.connection</div><div class=\"line\">\t\t\t\t\t\t.getServerTimezoneTZ(), rollForward);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t\t\t\tif (this.connection.getUseSSPSCompatibleTimezoneShift()) &#123;</div><div class=\"line\">\t\t\t\t\tdoSSPSCompatibleTimezoneShift(parameterIndex, x, sessionCalendar);</div><div class=\"line\">\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t\tsynchronized (this) &#123;</div><div class=\"line\">\t\t\t\t\t\tif (this.tsdf == null) &#123;</div><div class=\"line\">\t\t\t\t\t\t\tthis.tsdf = new SimpleDateFormat(&quot;&apos;&apos;yyyy-MM-dd HH:mm:ss&quot;, Locale.US); //$NON-NLS-1$</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\t\tStringBuffer buf = new StringBuffer();</div><div class=\"line\">\t\t\t\t\t\tbuf.append(this.tsdf.format(x));</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\tif (this.serverSupportsFracSecs) &#123;</div><div class=\"line\">\t\t\t\t\t\t\tint nanos = x.getNanos();</div><div class=\"line\">\t\t\t\t\t\t\t//精确到了纳秒</div><div class=\"line\">\t\t\t\t\t\t\tif (nanos != 0) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\tbuf.append(&apos;.&apos;);</div><div class=\"line\">\t\t\t\t\t\t\t\tbuf.append(TimeUtil.formatNanos(nanos, this.serverSupportsFracSecs, true));</div><div class=\"line\">\t\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\tbuf.append(&apos;\\&apos;&apos;);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\tsetInternal(parameterIndex, buf.toString()); // SimpleDateFormat is not</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // thread-safe</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\tthis.parameterTypes[parameterIndex - 1 + getParameterIndexOffset()] = Types.TIMESTAMP;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果使用的是mysql 5.6以下的版本，可以增加一个字段专门用来存储秒以下的精度：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE TABLE your_table (</div><div class=\"line\">  dt datetime,</div><div class=\"line\">  us int</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">INSERT INTO your_table VALUES</div><div class=\"line\">(&apos;2011-11-11 11:11:11.111111&apos;, MICROSECOND(&apos;2011-11-11 11:11:11.111111&apos;));</div></pre></td></tr></table></figure>\n<h1 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3 参考资料\"></a>3 参考资料</h1><p>(1)<a href=\"https://dev.mysql.com/doc/refman/5.6/en/fractional-seconds.html\" target=\"_blank\" rel=\"external\">MySQL Reference Manual</a><br>(2)<a href=\"http://www.yufengof.com/2015/08/17/mysql-datetime-type-millisecond-rounding/\" target=\"_blank\" rel=\"external\">http://www.yufengof.com/2015/08/17/mysql-datetime-type-millisecond-rounding/</a><br>(3)<a href=\"http://stackoverflow.com/questions/14038746/how-to-insert-a-microsecond-precision-datetime-into-mysql\" target=\"_blank\" rel=\"external\">how-to-insert-a-microsecond-precision-datetime-into-mysql</a></p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/08/28/MySQL的日期时间类型关于秒以下精度的处理/\">http://xiajunhust.github.io/2016/08/28/MySQL的日期时间类型关于秒以下精度的处理/</a></p>\n","excerpt":"<h1 id=\"1-MySQL中日期和时间的表示\"><a href=\"#1-MySQL中日期和时间的表示\" class=\"headerlink\" title=\"1 MySQL中日期和时间的表示\"></a>1 MySQL中日期和时间的表示</h1><p>MySQL中有多种数据类型可以用于日期和时间的表示：</p>\n<p><img src=\"http://o8sltkx20.bkt.clouddn.com/MySQL-base-001.png\" alt=\"\"></p>","more":"<p>常用的是如下三种：<br>（1）DATE：表示年月日<br>（2）DATETIME：表示年月日时分秒<br>（3）TIME：只需要表示时分秒  </p>\n<p>DATETIME和TIMESTAMP很类似，但是有如下区别：<br>（1）TIMESTAMP支持的时间范围较小<br>（2）在插入或者更新时不明确指定TIMESTAMP列的值时，系统将会设置为当前日期和时间。当值超出最大值值，将会使用默认值“0000-00-00 00:00”<br>（3）TIMESTAMP的插入和更新都受到当地时区的影响<br>（4）TIMESTAMP受MySQL版本和服务器SQLMode的影响很大  </p>\n<h1 id=\"2-MySQL日期时间对秒以下精度的支持\"><a href=\"#2-MySQL日期时间对秒以下精度的支持\" class=\"headerlink\" title=\"2 MySQL日期时间对秒以下精度的支持\"></a>2 MySQL日期时间对秒以下精度的支持</h1><p><b>MySQL在5.6.4以及更高版本提供了对秒以下精度时间的存储支持，在以前的版本是会将秒以下的精度忽略掉的。</b>TIME、TIMESTAMP、DATETIME均提供了小数点后6位的支持（微秒）。如果我们想定义一个能存储秒以下精度的日期时间字段，可以如下做，在类型字段后面指定小数点后的精度位数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE TABLE t1 (t TIME(3), dt DATETIME(6));</div></pre></td></tr></table></figure>\n<p>如果我们朝数据库中插入一条记录，时间的精度位数大于表字段能表示的位数，则会造成四舍五入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">mysql&gt; CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );</div><div class=\"line\">Query OK, 0 rows affected (0.33 sec)</div><div class=\"line\"></div><div class=\"line\">mysql&gt; INSERT INTO fractest VALUES</div><div class=\"line\">     &gt; (&apos;17:51:04.777&apos;, &apos;2014-09-08 17:51:04.777&apos;, &apos;2014-09-08 17:51:04.777&apos;);</div><div class=\"line\">Query OK, 1 row affected (0.03 sec)</div><div class=\"line\"></div><div class=\"line\">mysql&gt; SELECT * FROM fractest;</div><div class=\"line\">+-------------+------------------------+------------------------+</div><div class=\"line\">| c1          | c2                     | c3                     |</div><div class=\"line\">+-------------+------------------------+------------------------+</div><div class=\"line\">| 17:51:04.78 | 2014-09-08 17:51:04.78 | 2014-09-08 17:51:04.78 |</div><div class=\"line\">+-------------+------------------------+------------------------+</div><div class=\"line\">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>\n<p><b>并且不会有任何警告，这点尤其要注意。</b></p>\n<p>截断在数据库server端，connector是会将毫秒部分一并提交给server的。我们可以看下mysql-connector-java jar中的源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Set a parameter to a java.sql.Timestamp value. The driver converts this</div><div class=\"line\"> * to a SQL TIMESTAMP value when it sends it to the database.</div><div class=\"line\"> * </div><div class=\"line\"> * @param parameterIndex</div><div class=\"line\"> *            the first parameter is 1, the second is 2, ...</div><div class=\"line\"> * @param x</div><div class=\"line\"> *            the parameter value</div><div class=\"line\"> * @param tz</div><div class=\"line\"> *            the timezone to use</div><div class=\"line\"> * </div><div class=\"line\"> * @throws SQLException</div><div class=\"line\"> *             if a database-access error occurs.</div><div class=\"line\"> */</div><div class=\"line\">private void setTimestampInternal(int parameterIndex,</div><div class=\"line\">\t\tTimestamp x, Calendar targetCalendar,</div><div class=\"line\">\t\tTimeZone tz, boolean rollForward) throws SQLException &#123;</div><div class=\"line\">\tsynchronized (checkClosed().getConnectionMutex()) &#123;</div><div class=\"line\">\t\tif (x == null) &#123;</div><div class=\"line\">\t\t\tsetNull(parameterIndex, java.sql.Types.TIMESTAMP);</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tcheckClosed();</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\tif (!this.useLegacyDatetimeCode) &#123;</div><div class=\"line\">\t\t\t\tnewSetTimestampInternal(parameterIndex, x, targetCalendar);</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\tCalendar sessionCalendar = this.connection.getUseJDBCCompliantTimezoneShift() ?</div><div class=\"line\">\t\t\t\t\t\tthis.connection.getUtcCalendar() : </div><div class=\"line\">\t\t\t\t\t\t\tgetCalendarInstanceForSessionOrNew();</div><div class=\"line\">\t\t\t\t\t</div><div class=\"line\">\t\t\t\tsynchronized (sessionCalendar) &#123;</div><div class=\"line\">\t\t\t\t\tx = TimeUtil.changeTimezone(this.connection, </div><div class=\"line\">\t\t\t\t\t\t\tsessionCalendar,</div><div class=\"line\">\t\t\t\t\t\t\ttargetCalendar,</div><div class=\"line\">\t\t\t\t\t\t\tx, tz, this.connection</div><div class=\"line\">\t\t\t\t\t\t.getServerTimezoneTZ(), rollForward);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t\t\t\tif (this.connection.getUseSSPSCompatibleTimezoneShift()) &#123;</div><div class=\"line\">\t\t\t\t\tdoSSPSCompatibleTimezoneShift(parameterIndex, x, sessionCalendar);</div><div class=\"line\">\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t\tsynchronized (this) &#123;</div><div class=\"line\">\t\t\t\t\t\tif (this.tsdf == null) &#123;</div><div class=\"line\">\t\t\t\t\t\t\tthis.tsdf = new SimpleDateFormat(&quot;&apos;&apos;yyyy-MM-dd HH:mm:ss&quot;, Locale.US); //$NON-NLS-1$</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\t\tStringBuffer buf = new StringBuffer();</div><div class=\"line\">\t\t\t\t\t\tbuf.append(this.tsdf.format(x));</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\tif (this.serverSupportsFracSecs) &#123;</div><div class=\"line\">\t\t\t\t\t\t\tint nanos = x.getNanos();</div><div class=\"line\">\t\t\t\t\t\t\t//精确到了纳秒</div><div class=\"line\">\t\t\t\t\t\t\tif (nanos != 0) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\tbuf.append(&apos;.&apos;);</div><div class=\"line\">\t\t\t\t\t\t\t\tbuf.append(TimeUtil.formatNanos(nanos, this.serverSupportsFracSecs, true));</div><div class=\"line\">\t\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\tbuf.append(&apos;\\&apos;&apos;);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\tsetInternal(parameterIndex, buf.toString()); // SimpleDateFormat is not</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // thread-safe</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\tthis.parameterTypes[parameterIndex - 1 + getParameterIndexOffset()] = Types.TIMESTAMP;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果使用的是mysql 5.6以下的版本，可以增加一个字段专门用来存储秒以下的精度：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE TABLE your_table (</div><div class=\"line\">  dt datetime,</div><div class=\"line\">  us int</div><div class=\"line\">);</div><div class=\"line\"></div><div class=\"line\">INSERT INTO your_table VALUES</div><div class=\"line\">(&apos;2011-11-11 11:11:11.111111&apos;, MICROSECOND(&apos;2011-11-11 11:11:11.111111&apos;));</div></pre></td></tr></table></figure>\n<h1 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3 参考资料\"></a>3 参考资料</h1><p>(1)<a href=\"https://dev.mysql.com/doc/refman/5.6/en/fractional-seconds.html\">MySQL Reference Manual</a><br>(2)<a href=\"http://www.yufengof.com/2015/08/17/mysql-datetime-type-millisecond-rounding/\">http://www.yufengof.com/2015/08/17/mysql-datetime-type-millisecond-rounding/</a><br>(3)<a href=\"http://stackoverflow.com/questions/14038746/how-to-insert-a-microsecond-precision-datetime-into-mysql\">how-to-insert-a-microsecond-precision-datetime-into-mysql</a></p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/08/28/MySQL的日期时间类型关于秒以下精度的处理/\">http://xiajunhust.github.io/2016/08/28/MySQL的日期时间类型关于秒以下精度的处理/</a></p>"},{"title":"RocketMQ源码学习之一-MAC单机环境搭建","date":"2016-11-12T02:48:59.000Z","_content":"\n本文讲述如何在单机（MAC）上搭建RocketMQ环境，实现正常收发消息。\n\n# 1 安装JDK、maven等工具  \n忽略。\n\n# 2 部署RocketMQ服务端  \n从[https://github.com/alibaba/RocketMQ](https://github.com/alibaba/RocketMQ)下载压缩包，并解压。\n\n<!-- more -->\n\n执行如下命令安装：  \nsh install.sh  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-1.png)\n\n进入devenv/bin目录修改相关文件的执行权限：  \ncd /root/RocketMQ-3.4.6/devenv/bin  \nchmod +x mqadmin mqbroker mqfiltersrv mqshutdown mqnamesrv\n\n设置nameserver地址的环境变量：  \nexport NAMESRV_ADDR=192.168.2.101:9876(改为自己的机器的IP)  \n\n然后接下来启动nameserver以及broker（注意一定要先启动nameserver，然后再启动broker）：  \nnohup ./mqnamesrv >/var/log/mqname.log &  \nnohup ./mqbroker >/var/log/mqbroker.log &  \n\n相应的关闭命令如下：  \nsh mqshutdown broker  \nsh mqshutdown namesrv\n\n观察/var/log/下的启动日志mqname.log、mqbroker.log发现有如下异常：  \n```\nERROR: Please set the JAVA_HOME variable in your environment, We need Java(x64)! !!\n```\n\n打开启动脚本runserver.sh以及runbroker.sh文件，发现有如下三行： \n \n```\n[ ! -e \"$JAVA_HOME/bin/java\" ] && JAVA_HOME=$HOME/jdk/java\n\n[ ! -e \"$JAVA_HOME/bin/java\" ] && JAVA_HOME=/opt/taobao/java\n\n[ ! -e \"$JAVA_HOME/bin/java\" ] && error_exit \"Please set the JAVA_HOME variable in your environment, We need java(x64)!\"\n\n```\n\n其中第二行是阿里巴巴集团内部服务器上的java目录，将这一行注释掉。然后第一行的JAVA_HOME的值改为自己机器的Java安装目录。然后再次起送mqnameserver以及mqbroker，观察日志发现启动成功：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-2.png)\n\n可以通过jps查看进程运行状态：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-3.png)\n\n# 3 运行Producer发送消息  \n新建java maven工程，pom.xml需要增加对RocketMQ的如下依赖:  \n\n```\n      <dependency>\n          <groupId>com.alibaba.rocketmq</groupId>\n          <artifactId>rocketmq-client</artifactId>\n          <version>3.5.9</version>\n      </dependency>\n\n      <dependency>\n          <groupId>com.alibaba.rocketmq</groupId>\n          <artifactId>rocketmq-srvutil</artifactId>\n          <version>3.2.6</version>\n      </dependency>\n      \n```\n\nProducer.java:  \n\n```\npublic class Producer {\n  public static void main(String[] args) throws MQClientException, InterruptedException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\");\n    producer.setNamesrvAddr(\"192.168.2.101:9876\");\n    producer.setInstanceName(\"Producer\");\n    producer.start();\n    for (int i = 0; i < 1; i++)\n      try {\n        {\n          Message msg = new Message(\"TopicTest\",// topic\n                                    \"TagA\",// tag\n                                    \"OrderID188\",// key\n                                    (\"Hello MetaQ\").getBytes());// body\n          SendResult sendResult = producer.send(msg);\n          System.out.println(sendResult);\n        }\n\n      }\n      catch (Exception e) {\n        e.printStackTrace();\n      }\n\n    producer.shutdown();\n  }\n}\n\n```\n\n运行消息生产者，报错找不到对应topic的路由信息：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-4.png)\n\n原因因为需要先正确设置nameserver，然后启动mqnamesrv，最后启动mqbroker。  \n\n之后再次运行消息producer，依然报错：消息发送失败，原因是连接失败。  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-5.png)  \n\n发现连接的地址是ifonfig中的这个地址：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-6.png)  \n\n查看pid，发现是VPN应用进程：   \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-7.png)  \n\n杀掉进程。\n\n然后重启mqsrv以及mqbroker，发现恢复正常：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-8.png)  \n\n\n再次运行Producer，消息发送成功：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-9.png)\n\n# 4 运行Consumer消费消息  \nconsumer.java:  \n\n```\npublic class Consumer {\n\n  public static void main(String[] args) throws InterruptedException, MQClientException {\n    DefaultMQPushConsumer\n        consumer = new DefaultMQPushConsumer(\"please_rename_unique_group_name_4\");\n    consumer.setVipChannelEnabled(false);\n    consumer.setNamesrvAddr(\"192.168.2.101:9876\");\n\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n    consumer.subscribe(\"TopicTest\", \"*\");\n\n    consumer.registerMessageListener(new MessageListenerConcurrently() {\n\n      public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                                                      ConsumeConcurrentlyContext context) {\n        System.out.println(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs);\n        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n      }\n    });\n\n    consumer.start();\n\n    System.out.println(\"Consumer Started.\");\n  }\n```\n\n运行consumer，消费消息成功：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-10.jpeg)\n\n\n# 5 一些有用的运维命令\n\n- 查看集群情况  \n/usr/local/alibaba-rocketmq/bin/mqadmin clusterList -n 127.0.0.1:9876\n- 查看broker状态  \n/usr/local/alibaba-rocketmq/bin/mqadmin brokerStatus -n 127.0.0.1:9876 -b 192.168.162.10:10911  \n- 查看topic列表  \n/usr/local/alibaba-rocketmq/bin/mqadmin topicList -n 127.0.0.1:9876\n- 查看topic状态  \n/usr/local/alibaba-rocketmq/bin/mqadmin topicStatus -n 127.0.0.1:9876 -t PushTopic\n- 查看topic路由  \n/usr/local/alibaba-rocketmq/bin/mqadmin topicRoute  -n 127.0.0.1:9876 -t PushTopic\n\n# 6 参考资料\n\n- [https://my.oschina.net/lenglingx/blog/734558](https://my.oschina.net/lenglingx/blog/734558)\n- [https://github.com/alibaba/RocketMQ/issues/44](https://github.com/alibaba/RocketMQ/issues/44)\n- [http://blog.chinaunix.net/uid-26111972-id-5750397.html](http://blog.chinaunix.net/uid-26111972-id-5750397.html)\n- [http://www.tuicool.com/articles/mEBVneB](http://www.tuicool.com/articles/mEBVneB)\n  \n","source":"_posts/RocketMQ源码学习之一-MAC系统单机环境搭建.md","raw":"---\ntitle: RocketMQ源码学习之一-MAC单机环境搭建\ndate: 2016-11-12 10:48:59\ntags: RocketMQ\n---\n\n本文讲述如何在单机（MAC）上搭建RocketMQ环境，实现正常收发消息。\n\n# 1 安装JDK、maven等工具  \n忽略。\n\n# 2 部署RocketMQ服务端  \n从[https://github.com/alibaba/RocketMQ](https://github.com/alibaba/RocketMQ)下载压缩包，并解压。\n\n<!-- more -->\n\n执行如下命令安装：  \nsh install.sh  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-1.png)\n\n进入devenv/bin目录修改相关文件的执行权限：  \ncd /root/RocketMQ-3.4.6/devenv/bin  \nchmod +x mqadmin mqbroker mqfiltersrv mqshutdown mqnamesrv\n\n设置nameserver地址的环境变量：  \nexport NAMESRV_ADDR=192.168.2.101:9876(改为自己的机器的IP)  \n\n然后接下来启动nameserver以及broker（注意一定要先启动nameserver，然后再启动broker）：  \nnohup ./mqnamesrv >/var/log/mqname.log &  \nnohup ./mqbroker >/var/log/mqbroker.log &  \n\n相应的关闭命令如下：  \nsh mqshutdown broker  \nsh mqshutdown namesrv\n\n观察/var/log/下的启动日志mqname.log、mqbroker.log发现有如下异常：  \n```\nERROR: Please set the JAVA_HOME variable in your environment, We need Java(x64)! !!\n```\n\n打开启动脚本runserver.sh以及runbroker.sh文件，发现有如下三行： \n \n```\n[ ! -e \"$JAVA_HOME/bin/java\" ] && JAVA_HOME=$HOME/jdk/java\n\n[ ! -e \"$JAVA_HOME/bin/java\" ] && JAVA_HOME=/opt/taobao/java\n\n[ ! -e \"$JAVA_HOME/bin/java\" ] && error_exit \"Please set the JAVA_HOME variable in your environment, We need java(x64)!\"\n\n```\n\n其中第二行是阿里巴巴集团内部服务器上的java目录，将这一行注释掉。然后第一行的JAVA_HOME的值改为自己机器的Java安装目录。然后再次起送mqnameserver以及mqbroker，观察日志发现启动成功：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-2.png)\n\n可以通过jps查看进程运行状态：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-3.png)\n\n# 3 运行Producer发送消息  \n新建java maven工程，pom.xml需要增加对RocketMQ的如下依赖:  \n\n```\n      <dependency>\n          <groupId>com.alibaba.rocketmq</groupId>\n          <artifactId>rocketmq-client</artifactId>\n          <version>3.5.9</version>\n      </dependency>\n\n      <dependency>\n          <groupId>com.alibaba.rocketmq</groupId>\n          <artifactId>rocketmq-srvutil</artifactId>\n          <version>3.2.6</version>\n      </dependency>\n      \n```\n\nProducer.java:  \n\n```\npublic class Producer {\n  public static void main(String[] args) throws MQClientException, InterruptedException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\");\n    producer.setNamesrvAddr(\"192.168.2.101:9876\");\n    producer.setInstanceName(\"Producer\");\n    producer.start();\n    for (int i = 0; i < 1; i++)\n      try {\n        {\n          Message msg = new Message(\"TopicTest\",// topic\n                                    \"TagA\",// tag\n                                    \"OrderID188\",// key\n                                    (\"Hello MetaQ\").getBytes());// body\n          SendResult sendResult = producer.send(msg);\n          System.out.println(sendResult);\n        }\n\n      }\n      catch (Exception e) {\n        e.printStackTrace();\n      }\n\n    producer.shutdown();\n  }\n}\n\n```\n\n运行消息生产者，报错找不到对应topic的路由信息：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-4.png)\n\n原因因为需要先正确设置nameserver，然后启动mqnamesrv，最后启动mqbroker。  \n\n之后再次运行消息producer，依然报错：消息发送失败，原因是连接失败。  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-5.png)  \n\n发现连接的地址是ifonfig中的这个地址：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-6.png)  \n\n查看pid，发现是VPN应用进程：   \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-7.png)  \n\n杀掉进程。\n\n然后重启mqsrv以及mqbroker，发现恢复正常：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-8.png)  \n\n\n再次运行Producer，消息发送成功：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-9.png)\n\n# 4 运行Consumer消费消息  \nconsumer.java:  \n\n```\npublic class Consumer {\n\n  public static void main(String[] args) throws InterruptedException, MQClientException {\n    DefaultMQPushConsumer\n        consumer = new DefaultMQPushConsumer(\"please_rename_unique_group_name_4\");\n    consumer.setVipChannelEnabled(false);\n    consumer.setNamesrvAddr(\"192.168.2.101:9876\");\n\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n    consumer.subscribe(\"TopicTest\", \"*\");\n\n    consumer.registerMessageListener(new MessageListenerConcurrently() {\n\n      public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                                                      ConsumeConcurrentlyContext context) {\n        System.out.println(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs);\n        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n      }\n    });\n\n    consumer.start();\n\n    System.out.println(\"Consumer Started.\");\n  }\n```\n\n运行consumer，消费消息成功：  \n![](http://o8sltkx20.bkt.clouddn.com/rocketmq-install-10.jpeg)\n\n\n# 5 一些有用的运维命令\n\n- 查看集群情况  \n/usr/local/alibaba-rocketmq/bin/mqadmin clusterList -n 127.0.0.1:9876\n- 查看broker状态  \n/usr/local/alibaba-rocketmq/bin/mqadmin brokerStatus -n 127.0.0.1:9876 -b 192.168.162.10:10911  \n- 查看topic列表  \n/usr/local/alibaba-rocketmq/bin/mqadmin topicList -n 127.0.0.1:9876\n- 查看topic状态  \n/usr/local/alibaba-rocketmq/bin/mqadmin topicStatus -n 127.0.0.1:9876 -t PushTopic\n- 查看topic路由  \n/usr/local/alibaba-rocketmq/bin/mqadmin topicRoute  -n 127.0.0.1:9876 -t PushTopic\n\n# 6 参考资料\n\n- [https://my.oschina.net/lenglingx/blog/734558](https://my.oschina.net/lenglingx/blog/734558)\n- [https://github.com/alibaba/RocketMQ/issues/44](https://github.com/alibaba/RocketMQ/issues/44)\n- [http://blog.chinaunix.net/uid-26111972-id-5750397.html](http://blog.chinaunix.net/uid-26111972-id-5750397.html)\n- [http://www.tuicool.com/articles/mEBVneB](http://www.tuicool.com/articles/mEBVneB)\n  \n","slug":"RocketMQ源码学习之一-MAC系统单机环境搭建","published":1,"updated":"2016-11-14T08:19:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsbn00092hwfbni7qztt","content":"<p>本文讲述如何在单机（MAC）上搭建RocketMQ环境，实现正常收发消息。</p>\n<h1 id=\"1-安装JDK、maven等工具\"><a href=\"#1-安装JDK、maven等工具\" class=\"headerlink\" title=\"1 安装JDK、maven等工具\"></a>1 安装JDK、maven等工具</h1><p>忽略。</p>\n<h1 id=\"2-部署RocketMQ服务端\"><a href=\"#2-部署RocketMQ服务端\" class=\"headerlink\" title=\"2 部署RocketMQ服务端\"></a>2 部署RocketMQ服务端</h1><p>从<a href=\"https://github.com/alibaba/RocketMQ\" target=\"_blank\" rel=\"external\">https://github.com/alibaba/RocketMQ</a>下载压缩包，并解压。</p>\n<a id=\"more\"></a>\n<p>执行如下命令安装：<br>sh install.sh<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-1.png\" alt=\"\"></p>\n<p>进入devenv/bin目录修改相关文件的执行权限：<br>cd /root/RocketMQ-3.4.6/devenv/bin<br>chmod +x mqadmin mqbroker mqfiltersrv mqshutdown mqnamesrv</p>\n<p>设置nameserver地址的环境变量：<br>export NAMESRV_ADDR=192.168.2.101:9876(改为自己的机器的IP)  </p>\n<p>然后接下来启动nameserver以及broker（注意一定要先启动nameserver，然后再启动broker）：<br>nohup ./mqnamesrv &gt;/var/log/mqname.log &amp;<br>nohup ./mqbroker &gt;/var/log/mqbroker.log &amp;  </p>\n<p>相应的关闭命令如下：<br>sh mqshutdown broker<br>sh mqshutdown namesrv</p>\n<p>观察/var/log/下的启动日志mqname.log、mqbroker.log发现有如下异常：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR: Please set the JAVA_HOME variable in your environment, We need Java(x64)! !!</div></pre></td></tr></table></figure></p>\n<p>打开启动脚本runserver.sh以及runbroker.sh文件，发现有如下三行： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; JAVA_HOME=$HOME/jdk/java</div><div class=\"line\"></div><div class=\"line\">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; JAVA_HOME=/opt/taobao/java</div><div class=\"line\"></div><div class=\"line\">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; error_exit &quot;Please set the JAVA_HOME variable in your environment, We need java(x64)!&quot;</div></pre></td></tr></table></figure>\n<p>其中第二行是阿里巴巴集团内部服务器上的java目录，将这一行注释掉。然后第一行的JAVA_HOME的值改为自己机器的Java安装目录。然后再次起送mqnameserver以及mqbroker，观察日志发现启动成功：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-2.png\" alt=\"\"></p>\n<p>可以通过jps查看进程运行状态：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-3.png\" alt=\"\"></p>\n<h1 id=\"3-运行Producer发送消息\"><a href=\"#3-运行Producer发送消息\" class=\"headerlink\" title=\"3 运行Producer发送消息\"></a>3 运行Producer发送消息</h1><p>新建java maven工程，pom.xml需要增加对RocketMQ的如下依赖:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;3.5.9&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;rocketmq-srvutil&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;3.2.6&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<p>Producer.java:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Producer &#123;</div><div class=\"line\">  public static void main(String[] args) throws MQClientException, InterruptedException &#123;</div><div class=\"line\">    DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;);</div><div class=\"line\">    producer.setNamesrvAddr(&quot;192.168.2.101:9876&quot;);</div><div class=\"line\">    producer.setInstanceName(&quot;Producer&quot;);</div><div class=\"line\">    producer.start();</div><div class=\"line\">    for (int i = 0; i &lt; 1; i++)</div><div class=\"line\">      try &#123;</div><div class=\"line\">        &#123;</div><div class=\"line\">          Message msg = new Message(&quot;TopicTest&quot;,// topic</div><div class=\"line\">                                    &quot;TagA&quot;,// tag</div><div class=\"line\">                                    &quot;OrderID188&quot;,// key</div><div class=\"line\">                                    (&quot;Hello MetaQ&quot;).getBytes());// body</div><div class=\"line\">          SendResult sendResult = producer.send(msg);</div><div class=\"line\">          System.out.println(sendResult);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">      &#125;</div><div class=\"line\">      catch (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    producer.shutdown();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行消息生产者，报错找不到对应topic的路由信息：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-4.png\" alt=\"\"></p>\n<p>原因因为需要先正确设置nameserver，然后启动mqnamesrv，最后启动mqbroker。  </p>\n<p>之后再次运行消息producer，依然报错：消息发送失败，原因是连接失败。<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-5.png\" alt=\"\">  </p>\n<p>发现连接的地址是ifonfig中的这个地址：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-6.png\" alt=\"\">  </p>\n<p>查看pid，发现是VPN应用进程：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-7.png\" alt=\"\">  </p>\n<p>杀掉进程。</p>\n<p>然后重启mqsrv以及mqbroker，发现恢复正常：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-8.png\" alt=\"\">  </p>\n<p>再次运行Producer，消息发送成功：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-9.png\" alt=\"\"></p>\n<h1 id=\"4-运行Consumer消费消息\"><a href=\"#4-运行Consumer消费消息\" class=\"headerlink\" title=\"4 运行Consumer消费消息\"></a>4 运行Consumer消费消息</h1><p>consumer.java:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Consumer &#123;</div><div class=\"line\"></div><div class=\"line\">  public static void main(String[] args) throws InterruptedException, MQClientException &#123;</div><div class=\"line\">    DefaultMQPushConsumer</div><div class=\"line\">        consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;);</div><div class=\"line\">    consumer.setVipChannelEnabled(false);</div><div class=\"line\">    consumer.setNamesrvAddr(&quot;192.168.2.101:9876&quot;);</div><div class=\"line\"></div><div class=\"line\">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</div><div class=\"line\"></div><div class=\"line\">    consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;);</div><div class=\"line\"></div><div class=\"line\">    consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</div><div class=\"line\"></div><div class=\"line\">      public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,</div><div class=\"line\">                                                      ConsumeConcurrentlyContext context) &#123;</div><div class=\"line\">        System.out.println(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; + msgs);</div><div class=\"line\">        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    consumer.start();</div><div class=\"line\"></div><div class=\"line\">    System.out.println(&quot;Consumer Started.&quot;);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>运行consumer，消费消息成功：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-10.jpeg\" alt=\"\"></p>\n<h1 id=\"5-一些有用的运维命令\"><a href=\"#5-一些有用的运维命令\" class=\"headerlink\" title=\"5 一些有用的运维命令\"></a>5 一些有用的运维命令</h1><ul>\n<li>查看集群情况<br>/usr/local/alibaba-rocketmq/bin/mqadmin clusterList -n 127.0.0.1:9876</li>\n<li>查看broker状态<br>/usr/local/alibaba-rocketmq/bin/mqadmin brokerStatus -n 127.0.0.1:9876 -b 192.168.162.10:10911  </li>\n<li>查看topic列表<br>/usr/local/alibaba-rocketmq/bin/mqadmin topicList -n 127.0.0.1:9876</li>\n<li>查看topic状态<br>/usr/local/alibaba-rocketmq/bin/mqadmin topicStatus -n 127.0.0.1:9876 -t PushTopic</li>\n<li>查看topic路由<br>/usr/local/alibaba-rocketmq/bin/mqadmin topicRoute  -n 127.0.0.1:9876 -t PushTopic</li>\n</ul>\n<h1 id=\"6-参考资料\"><a href=\"#6-参考资料\" class=\"headerlink\" title=\"6 参考资料\"></a>6 参考资料</h1><ul>\n<li><a href=\"https://my.oschina.net/lenglingx/blog/734558\" target=\"_blank\" rel=\"external\">https://my.oschina.net/lenglingx/blog/734558</a></li>\n<li><a href=\"https://github.com/alibaba/RocketMQ/issues/44\" target=\"_blank\" rel=\"external\">https://github.com/alibaba/RocketMQ/issues/44</a></li>\n<li><a href=\"http://blog.chinaunix.net/uid-26111972-id-5750397.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-26111972-id-5750397.html</a></li>\n<li><a href=\"http://www.tuicool.com/articles/mEBVneB\" target=\"_blank\" rel=\"external\">http://www.tuicool.com/articles/mEBVneB</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/11/12/RocketMQ源码学习之一-MAC系统单机环境搭建/\">http://xiajunhust.github.io/2016/11/12/RocketMQ源码学习之一-MAC系统单机环境搭建/</a></p>\n","excerpt":"<p>本文讲述如何在单机（MAC）上搭建RocketMQ环境，实现正常收发消息。</p>\n<h1 id=\"1-安装JDK、maven等工具\"><a href=\"#1-安装JDK、maven等工具\" class=\"headerlink\" title=\"1 安装JDK、maven等工具\"></a>1 安装JDK、maven等工具</h1><p>忽略。</p>\n<h1 id=\"2-部署RocketMQ服务端\"><a href=\"#2-部署RocketMQ服务端\" class=\"headerlink\" title=\"2 部署RocketMQ服务端\"></a>2 部署RocketMQ服务端</h1><p>从<a href=\"https://github.com/alibaba/RocketMQ\">https://github.com/alibaba/RocketMQ</a>下载压缩包，并解压。</p>","more":"<p>执行如下命令安装：<br>sh install.sh<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-1.png\" alt=\"\"></p>\n<p>进入devenv/bin目录修改相关文件的执行权限：<br>cd /root/RocketMQ-3.4.6/devenv/bin<br>chmod +x mqadmin mqbroker mqfiltersrv mqshutdown mqnamesrv</p>\n<p>设置nameserver地址的环境变量：<br>export NAMESRV_ADDR=192.168.2.101:9876(改为自己的机器的IP)  </p>\n<p>然后接下来启动nameserver以及broker（注意一定要先启动nameserver，然后再启动broker）：<br>nohup ./mqnamesrv &gt;/var/log/mqname.log &amp;<br>nohup ./mqbroker &gt;/var/log/mqbroker.log &amp;  </p>\n<p>相应的关闭命令如下：<br>sh mqshutdown broker<br>sh mqshutdown namesrv</p>\n<p>观察/var/log/下的启动日志mqname.log、mqbroker.log发现有如下异常：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR: Please set the JAVA_HOME variable in your environment, We need Java(x64)! !!</div></pre></td></tr></table></figure></p>\n<p>打开启动脚本runserver.sh以及runbroker.sh文件，发现有如下三行： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; JAVA_HOME=$HOME/jdk/java</div><div class=\"line\"></div><div class=\"line\">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; JAVA_HOME=/opt/taobao/java</div><div class=\"line\"></div><div class=\"line\">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; error_exit &quot;Please set the JAVA_HOME variable in your environment, We need java(x64)!&quot;</div></pre></td></tr></table></figure>\n<p>其中第二行是阿里巴巴集团内部服务器上的java目录，将这一行注释掉。然后第一行的JAVA_HOME的值改为自己机器的Java安装目录。然后再次起送mqnameserver以及mqbroker，观察日志发现启动成功：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-2.png\" alt=\"\"></p>\n<p>可以通过jps查看进程运行状态：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-3.png\" alt=\"\"></p>\n<h1 id=\"3-运行Producer发送消息\"><a href=\"#3-运行Producer发送消息\" class=\"headerlink\" title=\"3 运行Producer发送消息\"></a>3 运行Producer发送消息</h1><p>新建java maven工程，pom.xml需要增加对RocketMQ的如下依赖:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;3.5.9&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;rocketmq-srvutil&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;3.2.6&lt;/version&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure>\n<p>Producer.java:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Producer &#123;</div><div class=\"line\">  public static void main(String[] args) throws MQClientException, InterruptedException &#123;</div><div class=\"line\">    DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;);</div><div class=\"line\">    producer.setNamesrvAddr(&quot;192.168.2.101:9876&quot;);</div><div class=\"line\">    producer.setInstanceName(&quot;Producer&quot;);</div><div class=\"line\">    producer.start();</div><div class=\"line\">    for (int i = 0; i &lt; 1; i++)</div><div class=\"line\">      try &#123;</div><div class=\"line\">        &#123;</div><div class=\"line\">          Message msg = new Message(&quot;TopicTest&quot;,// topic</div><div class=\"line\">                                    &quot;TagA&quot;,// tag</div><div class=\"line\">                                    &quot;OrderID188&quot;,// key</div><div class=\"line\">                                    (&quot;Hello MetaQ&quot;).getBytes());// body</div><div class=\"line\">          SendResult sendResult = producer.send(msg);</div><div class=\"line\">          System.out.println(sendResult);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">      &#125;</div><div class=\"line\">      catch (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    producer.shutdown();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行消息生产者，报错找不到对应topic的路由信息：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-4.png\" alt=\"\"></p>\n<p>原因因为需要先正确设置nameserver，然后启动mqnamesrv，最后启动mqbroker。  </p>\n<p>之后再次运行消息producer，依然报错：消息发送失败，原因是连接失败。<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-5.png\" alt=\"\">  </p>\n<p>发现连接的地址是ifonfig中的这个地址：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-6.png\" alt=\"\">  </p>\n<p>查看pid，发现是VPN应用进程：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-7.png\" alt=\"\">  </p>\n<p>杀掉进程。</p>\n<p>然后重启mqsrv以及mqbroker，发现恢复正常：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-8.png\" alt=\"\">  </p>\n<p>再次运行Producer，消息发送成功：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-9.png\" alt=\"\"></p>\n<h1 id=\"4-运行Consumer消费消息\"><a href=\"#4-运行Consumer消费消息\" class=\"headerlink\" title=\"4 运行Consumer消费消息\"></a>4 运行Consumer消费消息</h1><p>consumer.java:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Consumer &#123;</div><div class=\"line\"></div><div class=\"line\">  public static void main(String[] args) throws InterruptedException, MQClientException &#123;</div><div class=\"line\">    DefaultMQPushConsumer</div><div class=\"line\">        consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;);</div><div class=\"line\">    consumer.setVipChannelEnabled(false);</div><div class=\"line\">    consumer.setNamesrvAddr(&quot;192.168.2.101:9876&quot;);</div><div class=\"line\"></div><div class=\"line\">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</div><div class=\"line\"></div><div class=\"line\">    consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;);</div><div class=\"line\"></div><div class=\"line\">    consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</div><div class=\"line\"></div><div class=\"line\">      public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,</div><div class=\"line\">                                                      ConsumeConcurrentlyContext context) &#123;</div><div class=\"line\">        System.out.println(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; + msgs);</div><div class=\"line\">        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    consumer.start();</div><div class=\"line\"></div><div class=\"line\">    System.out.println(&quot;Consumer Started.&quot;);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>运行consumer，消费消息成功：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-install-10.jpeg\" alt=\"\"></p>\n<h1 id=\"5-一些有用的运维命令\"><a href=\"#5-一些有用的运维命令\" class=\"headerlink\" title=\"5 一些有用的运维命令\"></a>5 一些有用的运维命令</h1><ul>\n<li>查看集群情况<br>/usr/local/alibaba-rocketmq/bin/mqadmin clusterList -n 127.0.0.1:9876</li>\n<li>查看broker状态<br>/usr/local/alibaba-rocketmq/bin/mqadmin brokerStatus -n 127.0.0.1:9876 -b 192.168.162.10:10911  </li>\n<li>查看topic列表<br>/usr/local/alibaba-rocketmq/bin/mqadmin topicList -n 127.0.0.1:9876</li>\n<li>查看topic状态<br>/usr/local/alibaba-rocketmq/bin/mqadmin topicStatus -n 127.0.0.1:9876 -t PushTopic</li>\n<li>查看topic路由<br>/usr/local/alibaba-rocketmq/bin/mqadmin topicRoute  -n 127.0.0.1:9876 -t PushTopic</li>\n</ul>\n<h1 id=\"6-参考资料\"><a href=\"#6-参考资料\" class=\"headerlink\" title=\"6 参考资料\"></a>6 参考资料</h1><ul>\n<li><a href=\"https://my.oschina.net/lenglingx/blog/734558\">https://my.oschina.net/lenglingx/blog/734558</a></li>\n<li><a href=\"https://github.com/alibaba/RocketMQ/issues/44\">https://github.com/alibaba/RocketMQ/issues/44</a></li>\n<li><a href=\"http://blog.chinaunix.net/uid-26111972-id-5750397.html\">http://blog.chinaunix.net/uid-26111972-id-5750397.html</a></li>\n<li><a href=\"http://www.tuicool.com/articles/mEBVneB\">http://www.tuicool.com/articles/mEBVneB</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/11/12/RocketMQ源码学习之一-MAC系统单机环境搭建/\">http://xiajunhust.github.io/2016/11/12/RocketMQ源码学习之一-MAC系统单机环境搭建/</a></p>"},{"title":"InfluxDB写入失败-partial write: max-values-per-tag limit exceeded","date":"2016-12-13T03:05:46.000Z","_content":"\n最近线上向InfluxDB写入数据突然报错，大概意思是tag的值超限，详细错误信息：\n\n```\n2016-12-02 20:47:11.485 [] [] [] ERROR c.y.t.p.m.m.i.OrderCreateMonitorManageImpl - InfluxDB写入异常!influxDO=InfluxDO(measurement=com.XXX.trade.create.request.result, timeStamp=1480682831481, tagKeyList=[cluster, host, count_time, count, count_type], tagValList=[DEFAULT_CLUSTER, xxx-inc.com, 1480682831481, 3, bill_new], fieldKeyList=[result, cost], fieldValList=[true, 112]), exception={}\njava.lang.RuntimeException: {\"error\":\"partial write: max-values-per-tag limit exceeded (100000/100000): measurement=\\\"com.XXX.trade.create.request.result\\\" tag=\\\"count_time\\\" value=\\\"count_time\\\" dropped=1\"}\n\n    at org.influxdb.impl.InfluxDBImpl.execute(InfluxDBImpl.java:266) ~[influxdb-java-2.4.jar:na]\n    at org.influxdb.impl.InfluxDBImpl.write(InfluxDBImpl.java:167) ~[influxdb-java-2.4.jar:na]\n    at org.influxdb.impl.InfluxDBImpl.write(InfluxDBImpl.java:157) ~[influxdb-java-2.4.jar:na]\n    at com.XXX.trade.process.monitor.dal.impl.InfluxDBDAOImpl.insert(InfluxDBDAOImpl.java:104) ~[trade-process-service-1.0.0-SNAPSHOT.jar:na]\n    at com.XXX.trade.process.monitor.manage.impl.OrderCreateMonitorManageImpl.save(OrderCreateMonitorManageImpl.java:40) ~[trade-process-service-1.0.0-SNAPSHOT.jar:na]\n    at com.XXX.trade.process.nsq.processor.impl.MonitorProcessor.process(MonitorProcessor.java:69) [trade-process-service-1.0.0-SNAPSHOT.jar:na]\n    at com.XXX.trade.process.nsq.NSQSubscriber.lambda$init$0(NSQSubscriber.java:71) [trade-process-service-1.0.0-SNAPSHOT.jar:na]\n    at com.XXX.trade.process.nsq.NSQSubscriber$$Lambda$8/1829287142.process(Unknown Source) [trade-process-service-1.0.0-SNAPSHOT.jar:na]\n```\n\nGoogle搜索了下，这是InfluxDB v1.1.0 [2016-11-14]版本新加的一个特性([CHANGELOG.md](https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md))：\n\n<!-- more -->\n\n<I>\nmax-values-per-tag was added with a default of 100,000, but can be disabled by setting it to 0. Existing measurements with tags that exceed this limit will continue to load, but writes that would cause the tags cardinality to increase will be dropped and a partial write error will be returned to the caller. This limit can be used to prevent high cardinality tag values from being written to a measurement.\n</I>\n\n增加了对tag的值的大小的校验，最大值是10000.若写入的数据的tag的值超限，则调用方会收到报错。用来防止写入到measurement的数据的series-cardinality([series-cardinality](https://docs.influxdata.com/influxdb/v1.1/concepts/glossary/#series-cardinality))过大。\n\n<I>\n关于series cardinality：  \nThe number of unique database, measurement, and tag set combinations in an InfluxDB instance.\n</I>\n\n<B>这样做的用意是什么呢？</B>  \n[issue-7146：Add option max-tags-per-database to limit high cardinality data](https://github.com/influxdata/influxdb/issues/7146)  \n\n<I>\nMuch as max-series-per-database in [#7095](https://github.com/influxdata/influxdb/pull/7095), add a max-tags-per-database to limit high cardinality data.\n\nWrites beyond that should be dropped and logged with a rate limit on the log (one summary log per minute or something saying x writes dropped).\n\nThis is important because if you accidentally load in a huge amount of high cardinality data, you can easily get into a place that InfluxDB will OOM if you attempt to delete the data, so your only choice is to try to move the files on disk out the way which deletes other data.\n\n---\n\nConfiguration setting for managing series cardinality\n\nLimiting your series cardinality is an essential part of working with InfluxDB. The new max-values-per-tag configuration setting can help you do just that.\n\nThe setting limits the number of tag values allowed per tag key. The default setting is 10,000 (so 10,000 tag values allowed per tag key). If a write causes the number of tag values for a tag key to exceed 10,000, InfluxDB will not write the point and it returns a partial write error.\n</I>\n\n如果我们写入了大量的series-cardinality很高的数据，那么当我们删除数据的时候，InfluxDB会OOM。\n\n<b>为什么我们需要关注series cardility？</b>  \n原因是InfluxDB在内存中维护了系统中每个series数据的索引。随着具有唯一性的series数据数量的增长，RAM的使用也会增长。过高的series cardinality会导致操作系统kill掉InfluxDB进程，抛出OOM异常。  \n\n<I>\nInfluxDB maintains an in-memory index of every series in the system. As the number of unique series grows, so does the RAM usage. High series cardinality can lead to the operating system killing the InfluxDB process with an out of memory (OOM) exception. See Querying for series cardinality to learn how to query for series cardinality.\n</I>\n\n\n\n## 参考资料\n\n- [https://github.com/influxdata/influxdb/issues/7146](https://github.com/influxdata/influxdb/issues/7146)\n- [https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md](https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md)\n- [https://www.influxdata.com/tldr-influxdb-tech-tips-november-15-2016/](https://www.influxdata.com/tldr-influxdb-tech-tips-november-15-2016/)\n- [FAQ-how-can-i-query-for-series-cardinality](https://docs.influxdata.com/influxdb/v1.1/troubleshooting/frequently-asked-questions/#how-can-i-query-for-series-cardinality)","source":"_posts/InfluxDB写入失败-partial-write-max-values-per-tag-limit-exceeded.md","raw":"---\ntitle: 'InfluxDB写入失败-partial write: max-values-per-tag limit exceeded'\ndate: 2016-12-13 11:05:46\ntags: InfluxDB\n---\n\n最近线上向InfluxDB写入数据突然报错，大概意思是tag的值超限，详细错误信息：\n\n```\n2016-12-02 20:47:11.485 [] [] [] ERROR c.y.t.p.m.m.i.OrderCreateMonitorManageImpl - InfluxDB写入异常!influxDO=InfluxDO(measurement=com.XXX.trade.create.request.result, timeStamp=1480682831481, tagKeyList=[cluster, host, count_time, count, count_type], tagValList=[DEFAULT_CLUSTER, xxx-inc.com, 1480682831481, 3, bill_new], fieldKeyList=[result, cost], fieldValList=[true, 112]), exception={}\njava.lang.RuntimeException: {\"error\":\"partial write: max-values-per-tag limit exceeded (100000/100000): measurement=\\\"com.XXX.trade.create.request.result\\\" tag=\\\"count_time\\\" value=\\\"count_time\\\" dropped=1\"}\n\n    at org.influxdb.impl.InfluxDBImpl.execute(InfluxDBImpl.java:266) ~[influxdb-java-2.4.jar:na]\n    at org.influxdb.impl.InfluxDBImpl.write(InfluxDBImpl.java:167) ~[influxdb-java-2.4.jar:na]\n    at org.influxdb.impl.InfluxDBImpl.write(InfluxDBImpl.java:157) ~[influxdb-java-2.4.jar:na]\n    at com.XXX.trade.process.monitor.dal.impl.InfluxDBDAOImpl.insert(InfluxDBDAOImpl.java:104) ~[trade-process-service-1.0.0-SNAPSHOT.jar:na]\n    at com.XXX.trade.process.monitor.manage.impl.OrderCreateMonitorManageImpl.save(OrderCreateMonitorManageImpl.java:40) ~[trade-process-service-1.0.0-SNAPSHOT.jar:na]\n    at com.XXX.trade.process.nsq.processor.impl.MonitorProcessor.process(MonitorProcessor.java:69) [trade-process-service-1.0.0-SNAPSHOT.jar:na]\n    at com.XXX.trade.process.nsq.NSQSubscriber.lambda$init$0(NSQSubscriber.java:71) [trade-process-service-1.0.0-SNAPSHOT.jar:na]\n    at com.XXX.trade.process.nsq.NSQSubscriber$$Lambda$8/1829287142.process(Unknown Source) [trade-process-service-1.0.0-SNAPSHOT.jar:na]\n```\n\nGoogle搜索了下，这是InfluxDB v1.1.0 [2016-11-14]版本新加的一个特性([CHANGELOG.md](https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md))：\n\n<!-- more -->\n\n<I>\nmax-values-per-tag was added with a default of 100,000, but can be disabled by setting it to 0. Existing measurements with tags that exceed this limit will continue to load, but writes that would cause the tags cardinality to increase will be dropped and a partial write error will be returned to the caller. This limit can be used to prevent high cardinality tag values from being written to a measurement.\n</I>\n\n增加了对tag的值的大小的校验，最大值是10000.若写入的数据的tag的值超限，则调用方会收到报错。用来防止写入到measurement的数据的series-cardinality([series-cardinality](https://docs.influxdata.com/influxdb/v1.1/concepts/glossary/#series-cardinality))过大。\n\n<I>\n关于series cardinality：  \nThe number of unique database, measurement, and tag set combinations in an InfluxDB instance.\n</I>\n\n<B>这样做的用意是什么呢？</B>  \n[issue-7146：Add option max-tags-per-database to limit high cardinality data](https://github.com/influxdata/influxdb/issues/7146)  \n\n<I>\nMuch as max-series-per-database in [#7095](https://github.com/influxdata/influxdb/pull/7095), add a max-tags-per-database to limit high cardinality data.\n\nWrites beyond that should be dropped and logged with a rate limit on the log (one summary log per minute or something saying x writes dropped).\n\nThis is important because if you accidentally load in a huge amount of high cardinality data, you can easily get into a place that InfluxDB will OOM if you attempt to delete the data, so your only choice is to try to move the files on disk out the way which deletes other data.\n\n---\n\nConfiguration setting for managing series cardinality\n\nLimiting your series cardinality is an essential part of working with InfluxDB. The new max-values-per-tag configuration setting can help you do just that.\n\nThe setting limits the number of tag values allowed per tag key. The default setting is 10,000 (so 10,000 tag values allowed per tag key). If a write causes the number of tag values for a tag key to exceed 10,000, InfluxDB will not write the point and it returns a partial write error.\n</I>\n\n如果我们写入了大量的series-cardinality很高的数据，那么当我们删除数据的时候，InfluxDB会OOM。\n\n<b>为什么我们需要关注series cardility？</b>  \n原因是InfluxDB在内存中维护了系统中每个series数据的索引。随着具有唯一性的series数据数量的增长，RAM的使用也会增长。过高的series cardinality会导致操作系统kill掉InfluxDB进程，抛出OOM异常。  \n\n<I>\nInfluxDB maintains an in-memory index of every series in the system. As the number of unique series grows, so does the RAM usage. High series cardinality can lead to the operating system killing the InfluxDB process with an out of memory (OOM) exception. See Querying for series cardinality to learn how to query for series cardinality.\n</I>\n\n\n\n## 参考资料\n\n- [https://github.com/influxdata/influxdb/issues/7146](https://github.com/influxdata/influxdb/issues/7146)\n- [https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md](https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md)\n- [https://www.influxdata.com/tldr-influxdb-tech-tips-november-15-2016/](https://www.influxdata.com/tldr-influxdb-tech-tips-november-15-2016/)\n- [FAQ-how-can-i-query-for-series-cardinality](https://docs.influxdata.com/influxdb/v1.1/troubleshooting/frequently-asked-questions/#how-can-i-query-for-series-cardinality)","slug":"InfluxDB写入失败-partial-write-max-values-per-tag-limit-exceeded","published":1,"updated":"2016-12-17T15:25:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsbs000a2hwfoqhkplop","content":"<p>最近线上向InfluxDB写入数据突然报错，大概意思是tag的值超限，详细错误信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-12-02 20:47:11.485 [] [] [] ERROR c.y.t.p.m.m.i.OrderCreateMonitorManageImpl - InfluxDB写入异常!influxDO=InfluxDO(measurement=com.XXX.trade.create.request.result, timeStamp=1480682831481, tagKeyList=[cluster, host, count_time, count, count_type], tagValList=[DEFAULT_CLUSTER, xxx-inc.com, 1480682831481, 3, bill_new], fieldKeyList=[result, cost], fieldValList=[true, 112]), exception=&#123;&#125;</div><div class=\"line\">java.lang.RuntimeException: &#123;&quot;error&quot;:&quot;partial write: max-values-per-tag limit exceeded (100000/100000): measurement=\\&quot;com.XXX.trade.create.request.result\\&quot; tag=\\&quot;count_time\\&quot; value=\\&quot;count_time\\&quot; dropped=1&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">    at org.influxdb.impl.InfluxDBImpl.execute(InfluxDBImpl.java:266) ~[influxdb-java-2.4.jar:na]</div><div class=\"line\">    at org.influxdb.impl.InfluxDBImpl.write(InfluxDBImpl.java:167) ~[influxdb-java-2.4.jar:na]</div><div class=\"line\">    at org.influxdb.impl.InfluxDBImpl.write(InfluxDBImpl.java:157) ~[influxdb-java-2.4.jar:na]</div><div class=\"line\">    at com.XXX.trade.process.monitor.dal.impl.InfluxDBDAOImpl.insert(InfluxDBDAOImpl.java:104) ~[trade-process-service-1.0.0-SNAPSHOT.jar:na]</div><div class=\"line\">    at com.XXX.trade.process.monitor.manage.impl.OrderCreateMonitorManageImpl.save(OrderCreateMonitorManageImpl.java:40) ~[trade-process-service-1.0.0-SNAPSHOT.jar:na]</div><div class=\"line\">    at com.XXX.trade.process.nsq.processor.impl.MonitorProcessor.process(MonitorProcessor.java:69) [trade-process-service-1.0.0-SNAPSHOT.jar:na]</div><div class=\"line\">    at com.XXX.trade.process.nsq.NSQSubscriber.lambda$init$0(NSQSubscriber.java:71) [trade-process-service-1.0.0-SNAPSHOT.jar:na]</div><div class=\"line\">    at com.XXX.trade.process.nsq.NSQSubscriber$$Lambda$8/1829287142.process(Unknown Source) [trade-process-service-1.0.0-SNAPSHOT.jar:na]</div></pre></td></tr></table></figure>\n<p>Google搜索了下，这是InfluxDB v1.1.0 [2016-11-14]版本新加的一个特性(<a href=\"https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md\" target=\"_blank\" rel=\"external\">CHANGELOG.md</a>)：</p>\n<a id=\"more\"></a>\n<i><br>max-values-per-tag was added with a default of 100,000, but can be disabled by setting it to 0. Existing measurements with tags that exceed this limit will continue to load, but writes that would cause the tags cardinality to increase will be dropped and a partial write error will be returned to the caller. This limit can be used to prevent high cardinality tag values from being written to a measurement.<br></i>\n\n<p>增加了对tag的值的大小的校验，最大值是10000.若写入的数据的tag的值超限，则调用方会收到报错。用来防止写入到measurement的数据的series-cardinality(<a href=\"https://docs.influxdata.com/influxdb/v1.1/concepts/glossary/#series-cardinality\" target=\"_blank\" rel=\"external\">series-cardinality</a>)过大。</p>\n<i><br>关于series cardinality：<br>The number of unique database, measurement, and tag set combinations in an InfluxDB instance.<br></i>\n\n<p><b>这样做的用意是什么呢？</b><br><a href=\"https://github.com/influxdata/influxdb/issues/7146\" target=\"_blank\" rel=\"external\">issue-7146：Add option max-tags-per-database to limit high cardinality data</a>  </p>\n<i><br>Much as max-series-per-database in <a href=\"https://github.com/influxdata/influxdb/pull/7095\" target=\"_blank\" rel=\"external\">#7095</a>, add a max-tags-per-database to limit high cardinality data.<br><br>Writes beyond that should be dropped and logged with a rate limit on the log (one summary log per minute or something saying x writes dropped).<br><br>This is important because if you accidentally load in a huge amount of high cardinality data, you can easily get into a place that InfluxDB will OOM if you attempt to delete the data, so your only choice is to try to move the files on disk out the way which deletes other data.<br><br>—<br><br>Configuration setting for managing series cardinality<br><br>Limiting your series cardinality is an essential part of working with InfluxDB. The new max-values-per-tag configuration setting can help you do just that.<br><br>The setting limits the number of tag values allowed per tag key. The default setting is 10,000 (so 10,000 tag values allowed per tag key). If a write causes the number of tag values for a tag key to exceed 10,000, InfluxDB will not write the point and it returns a partial write error.<br></i>\n\n<p>如果我们写入了大量的series-cardinality很高的数据，那么当我们删除数据的时候，InfluxDB会OOM。</p>\n<p><b>为什么我们需要关注series cardility？</b><br>原因是InfluxDB在内存中维护了系统中每个series数据的索引。随着具有唯一性的series数据数量的增长，RAM的使用也会增长。过高的series cardinality会导致操作系统kill掉InfluxDB进程，抛出OOM异常。  </p>\n<i><br>InfluxDB maintains an in-memory index of every series in the system. As the number of unique series grows, so does the RAM usage. High series cardinality can lead to the operating system killing the InfluxDB process with an out of memory (OOM) exception. See Querying for series cardinality to learn how to query for series cardinality.<br></i>\n\n\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/influxdata/influxdb/issues/7146\" target=\"_blank\" rel=\"external\">https://github.com/influxdata/influxdb/issues/7146</a></li>\n<li><a href=\"https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md\" target=\"_blank\" rel=\"external\">https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md</a></li>\n<li><a href=\"https://www.influxdata.com/tldr-influxdb-tech-tips-november-15-2016/\" target=\"_blank\" rel=\"external\">https://www.influxdata.com/tldr-influxdb-tech-tips-november-15-2016/</a></li>\n<li><a href=\"https://docs.influxdata.com/influxdb/v1.1/troubleshooting/frequently-asked-questions/#how-can-i-query-for-series-cardinality\" target=\"_blank\" rel=\"external\">FAQ-how-can-i-query-for-series-cardinality</a><h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2></li>\n</ul>\n<p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/12/13/InfluxDB写入失败-partial-write-max-values-per-tag-limit-exceeded/\">http://xiajunhust.github.io/2016/12/13/InfluxDB写入失败-partial-write-max-values-per-tag-limit-exceeded/</a></p>\n","excerpt":"<p>最近线上向InfluxDB写入数据突然报错，大概意思是tag的值超限，详细错误信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-12-02 20:47:11.485 [] [] [] ERROR c.y.t.p.m.m.i.OrderCreateMonitorManageImpl - InfluxDB写入异常!influxDO=InfluxDO(measurement=com.XXX.trade.create.request.result, timeStamp=1480682831481, tagKeyList=[cluster, host, count_time, count, count_type], tagValList=[DEFAULT_CLUSTER, xxx-inc.com, 1480682831481, 3, bill_new], fieldKeyList=[result, cost], fieldValList=[true, 112]), exception=&#123;&#125;</div><div class=\"line\">java.lang.RuntimeException: &#123;&quot;error&quot;:&quot;partial write: max-values-per-tag limit exceeded (100000/100000): measurement=\\&quot;com.XXX.trade.create.request.result\\&quot; tag=\\&quot;count_time\\&quot; value=\\&quot;count_time\\&quot; dropped=1&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">    at org.influxdb.impl.InfluxDBImpl.execute(InfluxDBImpl.java:266) ~[influxdb-java-2.4.jar:na]</div><div class=\"line\">    at org.influxdb.impl.InfluxDBImpl.write(InfluxDBImpl.java:167) ~[influxdb-java-2.4.jar:na]</div><div class=\"line\">    at org.influxdb.impl.InfluxDBImpl.write(InfluxDBImpl.java:157) ~[influxdb-java-2.4.jar:na]</div><div class=\"line\">    at com.XXX.trade.process.monitor.dal.impl.InfluxDBDAOImpl.insert(InfluxDBDAOImpl.java:104) ~[trade-process-service-1.0.0-SNAPSHOT.jar:na]</div><div class=\"line\">    at com.XXX.trade.process.monitor.manage.impl.OrderCreateMonitorManageImpl.save(OrderCreateMonitorManageImpl.java:40) ~[trade-process-service-1.0.0-SNAPSHOT.jar:na]</div><div class=\"line\">    at com.XXX.trade.process.nsq.processor.impl.MonitorProcessor.process(MonitorProcessor.java:69) [trade-process-service-1.0.0-SNAPSHOT.jar:na]</div><div class=\"line\">    at com.XXX.trade.process.nsq.NSQSubscriber.lambda$init$0(NSQSubscriber.java:71) [trade-process-service-1.0.0-SNAPSHOT.jar:na]</div><div class=\"line\">    at com.XXX.trade.process.nsq.NSQSubscriber$$Lambda$8/1829287142.process(Unknown Source) [trade-process-service-1.0.0-SNAPSHOT.jar:na]</div></pre></td></tr></table></figure>\n<p>Google搜索了下，这是InfluxDB v1.1.0 [2016-11-14]版本新加的一个特性(<a href=\"https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md\">CHANGELOG.md</a>)：</p>","more":"<I><br>max-values-per-tag was added with a default of 100,000, but can be disabled by setting it to 0. Existing measurements with tags that exceed this limit will continue to load, but writes that would cause the tags cardinality to increase will be dropped and a partial write error will be returned to the caller. This limit can be used to prevent high cardinality tag values from being written to a measurement.<br></I>\n\n<p>增加了对tag的值的大小的校验，最大值是10000.若写入的数据的tag的值超限，则调用方会收到报错。用来防止写入到measurement的数据的series-cardinality(<a href=\"https://docs.influxdata.com/influxdb/v1.1/concepts/glossary/#series-cardinality\">series-cardinality</a>)过大。</p>\n<I><br>关于series cardinality：<br>The number of unique database, measurement, and tag set combinations in an InfluxDB instance.<br></I>\n\n<p><B>这样做的用意是什么呢？</B><br><a href=\"https://github.com/influxdata/influxdb/issues/7146\">issue-7146：Add option max-tags-per-database to limit high cardinality data</a>  </p>\n<I><br>Much as max-series-per-database in <a href=\"https://github.com/influxdata/influxdb/pull/7095\">#7095</a>, add a max-tags-per-database to limit high cardinality data.<br><br>Writes beyond that should be dropped and logged with a rate limit on the log (one summary log per minute or something saying x writes dropped).<br><br>This is important because if you accidentally load in a huge amount of high cardinality data, you can easily get into a place that InfluxDB will OOM if you attempt to delete the data, so your only choice is to try to move the files on disk out the way which deletes other data.<br><br>—<br><br>Configuration setting for managing series cardinality<br><br>Limiting your series cardinality is an essential part of working with InfluxDB. The new max-values-per-tag configuration setting can help you do just that.<br><br>The setting limits the number of tag values allowed per tag key. The default setting is 10,000 (so 10,000 tag values allowed per tag key). If a write causes the number of tag values for a tag key to exceed 10,000, InfluxDB will not write the point and it returns a partial write error.<br></I>\n\n<p>如果我们写入了大量的series-cardinality很高的数据，那么当我们删除数据的时候，InfluxDB会OOM。</p>\n<p><b>为什么我们需要关注series cardility？</b><br>原因是InfluxDB在内存中维护了系统中每个series数据的索引。随着具有唯一性的series数据数量的增长，RAM的使用也会增长。过高的series cardinality会导致操作系统kill掉InfluxDB进程，抛出OOM异常。  </p>\n<I><br>InfluxDB maintains an in-memory index of every series in the system. As the number of unique series grows, so does the RAM usage. High series cardinality can lead to the operating system killing the InfluxDB process with an out of memory (OOM) exception. See Querying for series cardinality to learn how to query for series cardinality.<br></I>\n\n\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/influxdata/influxdb/issues/7146\">https://github.com/influxdata/influxdb/issues/7146</a></li>\n<li><a href=\"https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md\">https://github.com/influxdata/influxdb/blob/master/CHANGELOG.md</a></li>\n<li><a href=\"https://www.influxdata.com/tldr-influxdb-tech-tips-november-15-2016/\">https://www.influxdata.com/tldr-influxdb-tech-tips-november-15-2016/</a></li>\n<li><a href=\"https://docs.influxdata.com/influxdb/v1.1/troubleshooting/frequently-asked-questions/#how-can-i-query-for-series-cardinality\">FAQ-how-can-i-query-for-series-cardinality</a><h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2></li>\n</ul>\n<p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/12/13/InfluxDB写入失败-partial-write-max-values-per-tag-limit-exceeded/\">http://xiajunhust.github.io/2016/12/13/InfluxDB写入失败-partial-write-max-values-per-tag-limit-exceeded/</a></p>"},{"title":"RocketMQ源码学习之三-异步消息发送","date":"2016-11-14T14:05:07.000Z","_content":"\n本文主要介绍RocketMQ异步消息发送的原理。\n\n# 1 异步消息发送Demo  \n首先看一段RocketMQ异步消息发送的Demo代码：  \n消息生产者：  \n\n```\nimport com.alibaba.rocketmq.client.exception.MQClientException;\nimport com.alibaba.rocketmq.client.producer.DefaultMQProducer;\nimport com.alibaba.rocketmq.common.message.Message;\nimport com.SpringTest.rocketmq.callback.MySendCallback;\n\npublic class Producer3 {\n  public static void main(String[] args) throws MQClientException, InterruptedException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\");\n    producer.setNamesrvAddr(\"192.168.2.104:9876\");\n    producer.setInstanceName(\"Producer3\");\n    producer.start();\n    for (int i = 0; i < 1; i++)\n      try {\n        {\n          Message msg = new Message(\"TopicTest\",// topic\n                                    \"TagA\",// tag\n                                    \"OrderID188\",// key\n                                    (\"Hello MetaQ\").getBytes());// body\n\n          producer.send(msg, new MySendCallback());\n        }\n\n      }\n      catch (Exception e) {\n        e.printStackTrace();\n      }\n\n    producer.shutdown();\n  }\n}\n```\n\n<!-- more -->\n\n回调接口实现：\n\n```\npublic class  MySendCallback implements SendCallback {\n\n  public void onSuccess(final SendResult sendResult) {\n    System.out.println(\"SendCallback-发送消息成功! sendResult=\" + sendResult.toString());\n  }\n\n\n  public void onException(final Throwable e) {\n    System.out.println(\"SendCallback-发送消息失败! 异常=\" + e.toString());\n  }\n}\n```\n\n消息消费者和前一篇消息同步发送博文中示例相同。运行结果：  \n\n```\n生产者：\nSendCallback-发送消息成功! sendResult=SendResult [sendStatus=SEND_OK, msgId=C0A802684CCA1218025C454271C80000,offsetMsgId=C0A8026800002A9F0000000000001AC9, messageQueue=MessageQueue [topic=TopicTest, brokerName=xiajuns-MacBook-Pro.local, queueId=2], queueOffset=0]\n\n消费者：\nConsumeMessageThread_2 Receive New Messages: [MessageExt [queueId=2, storeSize=189, queueOffset=0, sysFlag=0, bornTimestamp=1479134782410, bornHost=/192.168.2.104:60966, storeTimestamp=1479134782449, storeHost=/192.168.2.104:10911, msgId=C0A8026800002A9F0000000000001AC9, commitLogOffset=6857, bodyCRC=1751783629, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=1, KEYS=OrderID188, CONSUME_START_TIME=1479134782503, UNIQ_KEY=C0A802684CCA1218025C454271C80000, WAIT=true, TAGS=TagA}, body=11]]]\n\n```\n\n# 2 异步消息发送原理以及应用场景    \n异步消息发送是指消息生产者发送了一条消息之后，不用等待此条消息的发送结果，而继续发送下一条消息。需要使用方自行实现回调接口SendCallback。发送端无需等待服务端响应结果，通过回调接口对服务器的响应进行处理。\n\n![异步消息发送原理示意图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-3-1.png)\n\n使用场景：  \n异步发送一般用于链路耗时较长，对 RT 响应时间较为敏感的业务场景，例如用户视频上传后通知启动转码服务，转码完成后通知推送转码结果等。\n\n# 3 异步消息发送源码分析  \n异步消息发送的整体发送流程与[RocketMQ同步消息发送](http://xiajunhust.github.io/2016/11/12/RocketMQ%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C-%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/)流程相同。不同之处在于，DefaultMQProducer.send(Message msg)调到DefaultMQProducerImpl的这个方法传递的CommunicationMode参数是ASYNC。最后会调到底层的Netty通信逻辑NettyRemotingClient:   \n\n```\npublic void invokeAsyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis,\n                            final InvokeCallback invokeCallback)\n        throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException {\n    final int opaque = request.getOpaque();\n    boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);\n    if (acquired) {\n        final SemaphoreReleaseOnlyOnce once = new SemaphoreReleaseOnlyOnce(this.semaphoreAsync);\n\n        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, invokeCallback, once);\n        this.responseTable.put(opaque, responseFuture);\n        try {\n            channel.writeAndFlush(request).addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture f) throws Exception {\n                    if (f.isSuccess()) {\n                        responseFuture.setSendRequestOK(true);\n                        return;\n                    } else {\n                        responseFuture.setSendRequestOK(false);\n                    }\n\n                    responseFuture.putResponse(null);\n                    responseTable.remove(opaque);\n                    try {\n                    \t //执行回调接口\n                        responseFuture.executeInvokeCallback();\n                    } catch (Throwable e) {\n                        plog.warn(\"excute callback in writeAndFlush addListener, and callback throw\", e);\n                    } finally {\n                        responseFuture.release();\n                    }\n\n                    plog.warn(\"send a request command to channel <{}> failed.\", RemotingHelper.parseChannelRemoteAddr(channel));\n                }\n            });\n        } catch (Exception e) {\n            responseFuture.release();\n            plog.warn(\"send a request command to channel <\" + RemotingHelper.parseChannelRemoteAddr(channel) + \"> Exception\", e);\n            throw new RemotingSendRequestException(RemotingHelper.parseChannelRemoteAddr(channel), e);\n        }\n    } else {\n        String info =\n                String.format(\"invokeAsyncImpl tryAcquire semaphore timeout, %dms, waiting thread nums: %d semaphoreAsyncValue: %d\", //\n                        timeoutMillis, //\n                        this.semaphoreAsync.getQueueLength(), //\n                        this.semaphoreAsync.availablePermits()//\n                );\n        plog.warn(info);\n        throw new RemotingTooMuchRequestException(info);\n    }\n}\n```\n\n这里同样是注册了监听器ChannelFutureListener，在监听器中设置消息发送结果，与同步发送不同的是会执行用户自己实现的回调接口，完成消息发送后的处理逻辑.  \n并且没有同步发送消息的awaiting逻辑，整个发送消息发送立即返回。\n\n# 4 参考资料  \n- [消息队列三种发送方式](http://jm.taobao.org/2016/07/21/3-ways-to-send-message/)\n\n\n\n","source":"_posts/RocketMQ源码学习之三-异步消息发送.md","raw":"---\ntitle: RocketMQ源码学习之三-异步消息发送\ndate: 2016-11-14 22:05:07\ntags: RocketMQ\n---\n\n本文主要介绍RocketMQ异步消息发送的原理。\n\n# 1 异步消息发送Demo  \n首先看一段RocketMQ异步消息发送的Demo代码：  \n消息生产者：  \n\n```\nimport com.alibaba.rocketmq.client.exception.MQClientException;\nimport com.alibaba.rocketmq.client.producer.DefaultMQProducer;\nimport com.alibaba.rocketmq.common.message.Message;\nimport com.SpringTest.rocketmq.callback.MySendCallback;\n\npublic class Producer3 {\n  public static void main(String[] args) throws MQClientException, InterruptedException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\");\n    producer.setNamesrvAddr(\"192.168.2.104:9876\");\n    producer.setInstanceName(\"Producer3\");\n    producer.start();\n    for (int i = 0; i < 1; i++)\n      try {\n        {\n          Message msg = new Message(\"TopicTest\",// topic\n                                    \"TagA\",// tag\n                                    \"OrderID188\",// key\n                                    (\"Hello MetaQ\").getBytes());// body\n\n          producer.send(msg, new MySendCallback());\n        }\n\n      }\n      catch (Exception e) {\n        e.printStackTrace();\n      }\n\n    producer.shutdown();\n  }\n}\n```\n\n<!-- more -->\n\n回调接口实现：\n\n```\npublic class  MySendCallback implements SendCallback {\n\n  public void onSuccess(final SendResult sendResult) {\n    System.out.println(\"SendCallback-发送消息成功! sendResult=\" + sendResult.toString());\n  }\n\n\n  public void onException(final Throwable e) {\n    System.out.println(\"SendCallback-发送消息失败! 异常=\" + e.toString());\n  }\n}\n```\n\n消息消费者和前一篇消息同步发送博文中示例相同。运行结果：  \n\n```\n生产者：\nSendCallback-发送消息成功! sendResult=SendResult [sendStatus=SEND_OK, msgId=C0A802684CCA1218025C454271C80000,offsetMsgId=C0A8026800002A9F0000000000001AC9, messageQueue=MessageQueue [topic=TopicTest, brokerName=xiajuns-MacBook-Pro.local, queueId=2], queueOffset=0]\n\n消费者：\nConsumeMessageThread_2 Receive New Messages: [MessageExt [queueId=2, storeSize=189, queueOffset=0, sysFlag=0, bornTimestamp=1479134782410, bornHost=/192.168.2.104:60966, storeTimestamp=1479134782449, storeHost=/192.168.2.104:10911, msgId=C0A8026800002A9F0000000000001AC9, commitLogOffset=6857, bodyCRC=1751783629, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=1, KEYS=OrderID188, CONSUME_START_TIME=1479134782503, UNIQ_KEY=C0A802684CCA1218025C454271C80000, WAIT=true, TAGS=TagA}, body=11]]]\n\n```\n\n# 2 异步消息发送原理以及应用场景    \n异步消息发送是指消息生产者发送了一条消息之后，不用等待此条消息的发送结果，而继续发送下一条消息。需要使用方自行实现回调接口SendCallback。发送端无需等待服务端响应结果，通过回调接口对服务器的响应进行处理。\n\n![异步消息发送原理示意图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-3-1.png)\n\n使用场景：  \n异步发送一般用于链路耗时较长，对 RT 响应时间较为敏感的业务场景，例如用户视频上传后通知启动转码服务，转码完成后通知推送转码结果等。\n\n# 3 异步消息发送源码分析  \n异步消息发送的整体发送流程与[RocketMQ同步消息发送](http://xiajunhust.github.io/2016/11/12/RocketMQ%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C-%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/)流程相同。不同之处在于，DefaultMQProducer.send(Message msg)调到DefaultMQProducerImpl的这个方法传递的CommunicationMode参数是ASYNC。最后会调到底层的Netty通信逻辑NettyRemotingClient:   \n\n```\npublic void invokeAsyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis,\n                            final InvokeCallback invokeCallback)\n        throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException {\n    final int opaque = request.getOpaque();\n    boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);\n    if (acquired) {\n        final SemaphoreReleaseOnlyOnce once = new SemaphoreReleaseOnlyOnce(this.semaphoreAsync);\n\n        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, invokeCallback, once);\n        this.responseTable.put(opaque, responseFuture);\n        try {\n            channel.writeAndFlush(request).addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture f) throws Exception {\n                    if (f.isSuccess()) {\n                        responseFuture.setSendRequestOK(true);\n                        return;\n                    } else {\n                        responseFuture.setSendRequestOK(false);\n                    }\n\n                    responseFuture.putResponse(null);\n                    responseTable.remove(opaque);\n                    try {\n                    \t //执行回调接口\n                        responseFuture.executeInvokeCallback();\n                    } catch (Throwable e) {\n                        plog.warn(\"excute callback in writeAndFlush addListener, and callback throw\", e);\n                    } finally {\n                        responseFuture.release();\n                    }\n\n                    plog.warn(\"send a request command to channel <{}> failed.\", RemotingHelper.parseChannelRemoteAddr(channel));\n                }\n            });\n        } catch (Exception e) {\n            responseFuture.release();\n            plog.warn(\"send a request command to channel <\" + RemotingHelper.parseChannelRemoteAddr(channel) + \"> Exception\", e);\n            throw new RemotingSendRequestException(RemotingHelper.parseChannelRemoteAddr(channel), e);\n        }\n    } else {\n        String info =\n                String.format(\"invokeAsyncImpl tryAcquire semaphore timeout, %dms, waiting thread nums: %d semaphoreAsyncValue: %d\", //\n                        timeoutMillis, //\n                        this.semaphoreAsync.getQueueLength(), //\n                        this.semaphoreAsync.availablePermits()//\n                );\n        plog.warn(info);\n        throw new RemotingTooMuchRequestException(info);\n    }\n}\n```\n\n这里同样是注册了监听器ChannelFutureListener，在监听器中设置消息发送结果，与同步发送不同的是会执行用户自己实现的回调接口，完成消息发送后的处理逻辑.  \n并且没有同步发送消息的awaiting逻辑，整个发送消息发送立即返回。\n\n# 4 参考资料  \n- [消息队列三种发送方式](http://jm.taobao.org/2016/07/21/3-ways-to-send-message/)\n\n\n\n","slug":"RocketMQ源码学习之三-异步消息发送","published":1,"updated":"2016-11-16T03:34:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsbu000d2hwfg0z5hf7q","content":"<p>本文主要介绍RocketMQ异步消息发送的原理。</p>\n<h1 id=\"1-异步消息发送Demo\"><a href=\"#1-异步消息发送Demo\" class=\"headerlink\" title=\"1 异步消息发送Demo\"></a>1 异步消息发送Demo</h1><p>首先看一段RocketMQ异步消息发送的Demo代码：<br>消息生产者：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">import com.alibaba.rocketmq.client.exception.MQClientException;</div><div class=\"line\">import com.alibaba.rocketmq.client.producer.DefaultMQProducer;</div><div class=\"line\">import com.alibaba.rocketmq.common.message.Message;</div><div class=\"line\">import com.SpringTest.rocketmq.callback.MySendCallback;</div><div class=\"line\"></div><div class=\"line\">public class Producer3 &#123;</div><div class=\"line\">  public static void main(String[] args) throws MQClientException, InterruptedException &#123;</div><div class=\"line\">    DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;);</div><div class=\"line\">    producer.setNamesrvAddr(&quot;192.168.2.104:9876&quot;);</div><div class=\"line\">    producer.setInstanceName(&quot;Producer3&quot;);</div><div class=\"line\">    producer.start();</div><div class=\"line\">    for (int i = 0; i &lt; 1; i++)</div><div class=\"line\">      try &#123;</div><div class=\"line\">        &#123;</div><div class=\"line\">          Message msg = new Message(&quot;TopicTest&quot;,// topic</div><div class=\"line\">                                    &quot;TagA&quot;,// tag</div><div class=\"line\">                                    &quot;OrderID188&quot;,// key</div><div class=\"line\">                                    (&quot;Hello MetaQ&quot;).getBytes());// body</div><div class=\"line\"></div><div class=\"line\">          producer.send(msg, new MySendCallback());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">      &#125;</div><div class=\"line\">      catch (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    producer.shutdown();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>回调接口实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class  MySendCallback implements SendCallback &#123;</div><div class=\"line\"></div><div class=\"line\">  public void onSuccess(final SendResult sendResult) &#123;</div><div class=\"line\">    System.out.println(&quot;SendCallback-发送消息成功! sendResult=&quot; + sendResult.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  public void onException(final Throwable e) &#123;</div><div class=\"line\">    System.out.println(&quot;SendCallback-发送消息失败! 异常=&quot; + e.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>消息消费者和前一篇消息同步发送博文中示例相同。运行结果：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">生产者：</div><div class=\"line\">SendCallback-发送消息成功! sendResult=SendResult [sendStatus=SEND_OK, msgId=C0A802684CCA1218025C454271C80000,offsetMsgId=C0A8026800002A9F0000000000001AC9, messageQueue=MessageQueue [topic=TopicTest, brokerName=xiajuns-MacBook-Pro.local, queueId=2], queueOffset=0]</div><div class=\"line\"></div><div class=\"line\">消费者：</div><div class=\"line\">ConsumeMessageThread_2 Receive New Messages: [MessageExt [queueId=2, storeSize=189, queueOffset=0, sysFlag=0, bornTimestamp=1479134782410, bornHost=/192.168.2.104:60966, storeTimestamp=1479134782449, storeHost=/192.168.2.104:10911, msgId=C0A8026800002A9F0000000000001AC9, commitLogOffset=6857, bodyCRC=1751783629, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=1, KEYS=OrderID188, CONSUME_START_TIME=1479134782503, UNIQ_KEY=C0A802684CCA1218025C454271C80000, WAIT=true, TAGS=TagA&#125;, body=11]]]</div></pre></td></tr></table></figure>\n<h1 id=\"2-异步消息发送原理以及应用场景\"><a href=\"#2-异步消息发送原理以及应用场景\" class=\"headerlink\" title=\"2 异步消息发送原理以及应用场景\"></a>2 异步消息发送原理以及应用场景</h1><p>异步消息发送是指消息生产者发送了一条消息之后，不用等待此条消息的发送结果，而继续发送下一条消息。需要使用方自行实现回调接口SendCallback。发送端无需等待服务端响应结果，通过回调接口对服务器的响应进行处理。</p>\n<p><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-3-1.png\" alt=\"异步消息发送原理示意图\"></p>\n<p>使用场景：<br>异步发送一般用于链路耗时较长，对 RT 响应时间较为敏感的业务场景，例如用户视频上传后通知启动转码服务，转码完成后通知推送转码结果等。</p>\n<h1 id=\"3-异步消息发送源码分析\"><a href=\"#3-异步消息发送源码分析\" class=\"headerlink\" title=\"3 异步消息发送源码分析\"></a>3 异步消息发送源码分析</h1><p>异步消息发送的整体发送流程与<a href=\"http://xiajunhust.github.io/2016/11/12/RocketMQ%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C-%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/\">RocketMQ同步消息发送</a>流程相同。不同之处在于，DefaultMQProducer.send(Message msg)调到DefaultMQProducerImpl的这个方法传递的CommunicationMode参数是ASYNC。最后会调到底层的Netty通信逻辑NettyRemotingClient:   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void invokeAsyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis,</div><div class=\"line\">                            final InvokeCallback invokeCallback)</div><div class=\"line\">        throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException &#123;</div><div class=\"line\">    final int opaque = request.getOpaque();</div><div class=\"line\">    boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);</div><div class=\"line\">    if (acquired) &#123;</div><div class=\"line\">        final SemaphoreReleaseOnlyOnce once = new SemaphoreReleaseOnlyOnce(this.semaphoreAsync);</div><div class=\"line\"></div><div class=\"line\">        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, invokeCallback, once);</div><div class=\"line\">        this.responseTable.put(opaque, responseFuture);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            channel.writeAndFlush(request).addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void operationComplete(ChannelFuture f) throws Exception &#123;</div><div class=\"line\">                    if (f.isSuccess()) &#123;</div><div class=\"line\">                        responseFuture.setSendRequestOK(true);</div><div class=\"line\">                        return;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        responseFuture.setSendRequestOK(false);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    responseFuture.putResponse(null);</div><div class=\"line\">                    responseTable.remove(opaque);</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                    \t //执行回调接口</div><div class=\"line\">                        responseFuture.executeInvokeCallback();</div><div class=\"line\">                    &#125; catch (Throwable e) &#123;</div><div class=\"line\">                        plog.warn(&quot;excute callback in writeAndFlush addListener, and callback throw&quot;, e);</div><div class=\"line\">                    &#125; finally &#123;</div><div class=\"line\">                        responseFuture.release();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    plog.warn(&quot;send a request command to channel &lt;&#123;&#125;&gt; failed.&quot;, RemotingHelper.parseChannelRemoteAddr(channel));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            responseFuture.release();</div><div class=\"line\">            plog.warn(&quot;send a request command to channel &lt;&quot; + RemotingHelper.parseChannelRemoteAddr(channel) + &quot;&gt; Exception&quot;, e);</div><div class=\"line\">            throw new RemotingSendRequestException(RemotingHelper.parseChannelRemoteAddr(channel), e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        String info =</div><div class=\"line\">                String.format(&quot;invokeAsyncImpl tryAcquire semaphore timeout, %dms, waiting thread nums: %d semaphoreAsyncValue: %d&quot;, //</div><div class=\"line\">                        timeoutMillis, //</div><div class=\"line\">                        this.semaphoreAsync.getQueueLength(), //</div><div class=\"line\">                        this.semaphoreAsync.availablePermits()//</div><div class=\"line\">                );</div><div class=\"line\">        plog.warn(info);</div><div class=\"line\">        throw new RemotingTooMuchRequestException(info);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里同样是注册了监听器ChannelFutureListener，在监听器中设置消息发送结果，与同步发送不同的是会执行用户自己实现的回调接口，完成消息发送后的处理逻辑.<br>并且没有同步发送消息的awaiting逻辑，整个发送消息发送立即返回。</p>\n<h1 id=\"4-参考资料\"><a href=\"#4-参考资料\" class=\"headerlink\" title=\"4 参考资料\"></a>4 参考资料</h1><ul>\n<li><a href=\"http://jm.taobao.org/2016/07/21/3-ways-to-send-message/\" target=\"_blank\" rel=\"external\">消息队列三种发送方式</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/11/14/RocketMQ源码学习之三-异步消息发送/\">http://xiajunhust.github.io/2016/11/14/RocketMQ源码学习之三-异步消息发送/</a></p>\n","excerpt":"<p>本文主要介绍RocketMQ异步消息发送的原理。</p>\n<h1 id=\"1-异步消息发送Demo\"><a href=\"#1-异步消息发送Demo\" class=\"headerlink\" title=\"1 异步消息发送Demo\"></a>1 异步消息发送Demo</h1><p>首先看一段RocketMQ异步消息发送的Demo代码：<br>消息生产者：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">import com.alibaba.rocketmq.client.exception.MQClientException;</div><div class=\"line\">import com.alibaba.rocketmq.client.producer.DefaultMQProducer;</div><div class=\"line\">import com.alibaba.rocketmq.common.message.Message;</div><div class=\"line\">import com.SpringTest.rocketmq.callback.MySendCallback;</div><div class=\"line\"></div><div class=\"line\">public class Producer3 &#123;</div><div class=\"line\">  public static void main(String[] args) throws MQClientException, InterruptedException &#123;</div><div class=\"line\">    DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;);</div><div class=\"line\">    producer.setNamesrvAddr(&quot;192.168.2.104:9876&quot;);</div><div class=\"line\">    producer.setInstanceName(&quot;Producer3&quot;);</div><div class=\"line\">    producer.start();</div><div class=\"line\">    for (int i = 0; i &lt; 1; i++)</div><div class=\"line\">      try &#123;</div><div class=\"line\">        &#123;</div><div class=\"line\">          Message msg = new Message(&quot;TopicTest&quot;,// topic</div><div class=\"line\">                                    &quot;TagA&quot;,// tag</div><div class=\"line\">                                    &quot;OrderID188&quot;,// key</div><div class=\"line\">                                    (&quot;Hello MetaQ&quot;).getBytes());// body</div><div class=\"line\"></div><div class=\"line\">          producer.send(msg, new MySendCallback());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">      &#125;</div><div class=\"line\">      catch (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    producer.shutdown();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>回调接口实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class  MySendCallback implements SendCallback &#123;</div><div class=\"line\"></div><div class=\"line\">  public void onSuccess(final SendResult sendResult) &#123;</div><div class=\"line\">    System.out.println(&quot;SendCallback-发送消息成功! sendResult=&quot; + sendResult.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  public void onException(final Throwable e) &#123;</div><div class=\"line\">    System.out.println(&quot;SendCallback-发送消息失败! 异常=&quot; + e.toString());</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>消息消费者和前一篇消息同步发送博文中示例相同。运行结果：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">生产者：</div><div class=\"line\">SendCallback-发送消息成功! sendResult=SendResult [sendStatus=SEND_OK, msgId=C0A802684CCA1218025C454271C80000,offsetMsgId=C0A8026800002A9F0000000000001AC9, messageQueue=MessageQueue [topic=TopicTest, brokerName=xiajuns-MacBook-Pro.local, queueId=2], queueOffset=0]</div><div class=\"line\"></div><div class=\"line\">消费者：</div><div class=\"line\">ConsumeMessageThread_2 Receive New Messages: [MessageExt [queueId=2, storeSize=189, queueOffset=0, sysFlag=0, bornTimestamp=1479134782410, bornHost=/192.168.2.104:60966, storeTimestamp=1479134782449, storeHost=/192.168.2.104:10911, msgId=C0A8026800002A9F0000000000001AC9, commitLogOffset=6857, bodyCRC=1751783629, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=1, KEYS=OrderID188, CONSUME_START_TIME=1479134782503, UNIQ_KEY=C0A802684CCA1218025C454271C80000, WAIT=true, TAGS=TagA&#125;, body=11]]]</div></pre></td></tr></table></figure>\n<h1 id=\"2-异步消息发送原理以及应用场景\"><a href=\"#2-异步消息发送原理以及应用场景\" class=\"headerlink\" title=\"2 异步消息发送原理以及应用场景\"></a>2 异步消息发送原理以及应用场景</h1><p>异步消息发送是指消息生产者发送了一条消息之后，不用等待此条消息的发送结果，而继续发送下一条消息。需要使用方自行实现回调接口SendCallback。发送端无需等待服务端响应结果，通过回调接口对服务器的响应进行处理。</p>\n<p><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-3-1.png\" alt=\"异步消息发送原理示意图\"></p>\n<p>使用场景：<br>异步发送一般用于链路耗时较长，对 RT 响应时间较为敏感的业务场景，例如用户视频上传后通知启动转码服务，转码完成后通知推送转码结果等。</p>\n<h1 id=\"3-异步消息发送源码分析\"><a href=\"#3-异步消息发送源码分析\" class=\"headerlink\" title=\"3 异步消息发送源码分析\"></a>3 异步消息发送源码分析</h1><p>异步消息发送的整体发送流程与<a href=\"http://xiajunhust.github.io/2016/11/12/RocketMQ%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C-%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/\">RocketMQ同步消息发送</a>流程相同。不同之处在于，DefaultMQProducer.send(Message msg)调到DefaultMQProducerImpl的这个方法传递的CommunicationMode参数是ASYNC。最后会调到底层的Netty通信逻辑NettyRemotingClient:   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void invokeAsyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis,</div><div class=\"line\">                            final InvokeCallback invokeCallback)</div><div class=\"line\">        throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException &#123;</div><div class=\"line\">    final int opaque = request.getOpaque();</div><div class=\"line\">    boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);</div><div class=\"line\">    if (acquired) &#123;</div><div class=\"line\">        final SemaphoreReleaseOnlyOnce once = new SemaphoreReleaseOnlyOnce(this.semaphoreAsync);</div><div class=\"line\"></div><div class=\"line\">        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, invokeCallback, once);</div><div class=\"line\">        this.responseTable.put(opaque, responseFuture);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            channel.writeAndFlush(request).addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void operationComplete(ChannelFuture f) throws Exception &#123;</div><div class=\"line\">                    if (f.isSuccess()) &#123;</div><div class=\"line\">                        responseFuture.setSendRequestOK(true);</div><div class=\"line\">                        return;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        responseFuture.setSendRequestOK(false);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    responseFuture.putResponse(null);</div><div class=\"line\">                    responseTable.remove(opaque);</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                    \t //执行回调接口</div><div class=\"line\">                        responseFuture.executeInvokeCallback();</div><div class=\"line\">                    &#125; catch (Throwable e) &#123;</div><div class=\"line\">                        plog.warn(&quot;excute callback in writeAndFlush addListener, and callback throw&quot;, e);</div><div class=\"line\">                    &#125; finally &#123;</div><div class=\"line\">                        responseFuture.release();</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    plog.warn(&quot;send a request command to channel &lt;&#123;&#125;&gt; failed.&quot;, RemotingHelper.parseChannelRemoteAddr(channel));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            responseFuture.release();</div><div class=\"line\">            plog.warn(&quot;send a request command to channel &lt;&quot; + RemotingHelper.parseChannelRemoteAddr(channel) + &quot;&gt; Exception&quot;, e);</div><div class=\"line\">            throw new RemotingSendRequestException(RemotingHelper.parseChannelRemoteAddr(channel), e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        String info =</div><div class=\"line\">                String.format(&quot;invokeAsyncImpl tryAcquire semaphore timeout, %dms, waiting thread nums: %d semaphoreAsyncValue: %d&quot;, //</div><div class=\"line\">                        timeoutMillis, //</div><div class=\"line\">                        this.semaphoreAsync.getQueueLength(), //</div><div class=\"line\">                        this.semaphoreAsync.availablePermits()//</div><div class=\"line\">                );</div><div class=\"line\">        plog.warn(info);</div><div class=\"line\">        throw new RemotingTooMuchRequestException(info);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里同样是注册了监听器ChannelFutureListener，在监听器中设置消息发送结果，与同步发送不同的是会执行用户自己实现的回调接口，完成消息发送后的处理逻辑.<br>并且没有同步发送消息的awaiting逻辑，整个发送消息发送立即返回。</p>\n<h1 id=\"4-参考资料\"><a href=\"#4-参考资料\" class=\"headerlink\" title=\"4 参考资料\"></a>4 参考资料</h1><ul>\n<li><a href=\"http://jm.taobao.org/2016/07/21/3-ways-to-send-message/\">消息队列三种发送方式</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/11/14/RocketMQ源码学习之三-异步消息发送/\">http://xiajunhust.github.io/2016/11/14/RocketMQ源码学习之三-异步消息发送/</a></p>"},{"title":"为什么Java HashMap、CopyOnWriteArrayList等集合自己实现readObject和writeObject方法","date":"2016-08-06T13:48:23.000Z","_content":"\nPS:本文源码参考的是JDK 1.8.\n\n# 1 readObject、writeObject方法是什么？作用是什么？\n\n当一个class实现了Serializable接口，那么意味着这个类可以被序列化。如果类不实现readObject、writeObject方法，那么会执行默认的序列化和反序列化逻辑，否则执行自定义的序列化和反序列化逻辑，即readObject、writeObject方法的逻辑。\n\n<!-- more -->\n\nJDK提供的对于Java对象序列化操作的类是ObjectOutputStream，反序列化的类是ObjectInputStream。下面我们来看序列化的实现（ObjectOutputStream.writeObject）。\n\n```\n/**\n * Write the specified object to the ObjectOutputStream.  The class of the\n * object, the signature of the class, and the values of the non-transient\n * and non-static fields of the class and all of its supertypes are\n * written.  Default serialization for a class can be overridden using the\n * writeObject and the readObject methods.  Objects referenced by this\n * object are written transitively so that a complete equivalent graph of\n * objects can be reconstructed by an ObjectInputStream.\n *\n * <p>Exceptions are thrown for problems with the OutputStream and for\n * classes that should not be serialized.  All exceptions are fatal to the\n * OutputStream, which is left in an indeterminate state, and it is up to\n * the caller to ignore or recover the stream state.\n *\n * @throws  InvalidClassException Something is wrong with a class used by\n *          serialization.\n * @throws  NotSerializableException Some object to be serialized does not\n *          implement the java.io.Serializable interface.\n * @throws  IOException Any exception thrown by the underlying\n *          OutputStream.\n */\npublic final void writeObject(Object obj) throws IOException {\n    if (enableOverride) {\n        writeObjectOverride(obj);\n        return;\n    }\n    try {\n        writeObject0(obj, false);\n    } catch (IOException ex) {\n        if (depth == 0) {\n            writeFatalException(ex);\n        }\n        throw ex;\n    }\n}\n```\n\n从方法注释可以看到，此方法正是执行了将对象序列化的操作。并且默认的序列化机制可以通过重写readObject、writeObject方法实现。实际调用的方法writeObject0最终会调到writeSerialData：  \n\n```\n/**\n * Writes instance data for each serializable class of given object, from\n * superclass to subclass.\n */\nprivate void writeSerialData(Object obj, ObjectStreamClass desc)\n    throws IOException\n{\n    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();\n    for (int i = 0; i < slots.length; i++) {\n        ObjectStreamClass slotDesc = slots[i].desc;\n        //如果类重写了writeObject方法\n        if (slotDesc.hasWriteObjectMethod()) {\n            PutFieldImpl oldPut = curPut;\n            curPut = null;\n            SerialCallbackContext oldContext = curContext;\n\n            if (extendedDebugInfo) {\n                debugInfoStack.push(\n                    \"custom writeObject data (class \\\"\" +\n                    slotDesc.getName() + \"\\\")\");\n            }\n            try {\n                curContext = new SerialCallbackContext(obj, slotDesc);\n                bout.setBlockDataMode(true);\n                //调用实现类自己的writeobject方法\n                slotDesc.invokeWriteObject(obj, this);\n                bout.setBlockDataMode(false);\n                bout.writeByte(TC_ENDBLOCKDATA);\n            } finally {\n                curContext.setUsed();\n                curContext = oldContext;\n                if (extendedDebugInfo) {\n                    debugInfoStack.pop();\n                }\n            }\n\n            curPut = oldPut;\n        } else {\n            defaultWriteFields(obj, slotDesc);\n        }\n    }\n}\n```\n\n# 2 为什么是private方法？\n\njavadoc上没有明确说明声明为private的原因，一个可能的原因是，除了子类以外没有其他类会使用它，这样不会被滥用。\n\n另一个原因是，不希望这些方法被子类override。每个类都可以有自己的writeObject方法，序列化引擎会逐一调用。readObject相同。\n\n\n# 3 HashMap中对readObject、writeObject方法的实现\n\n## 3.1 为什么HashMap要自定义序列化逻辑\n\n下文是摘自《Effective Java》：\n\n<i>For example, consider the case of a hash table. The physical representation is a sequence of hash buckets containing key-value entries. The bucket that an entry resides in is a function of the hash code of its key, which is not, in general, guaranteed to be the same from JVM implementation to JVM implementation. In fact, it isn't even guaranteed to be the same from run to run. Therefore, accepting the default serialized form for a hash table would constitute a serious bug. Serializing and deserializing the hash table could yield an object whose invariants were seriously corrupt.</i>\n\n大概意思是：对于同一个key，在不同的JVM平台上计算出来的hash值可能不同，导致的结果就是，同一个hashmap反序列化之后和序列化之前不同，导致同一个key取出来的值不同。\n\n## 3.1 HashMap是如何解决的\n\n- 将可能造成数据不一致的元素使用transient修饰，在序列化的时候忽略这些元素：  \n<i>\nEntry[] table  \nsize  \nmodCount\n</i>\n\n- HashMap中对writeObject的实现：\n\n```\n/**\n * Save the state of the <tt>HashMap</tt> instance to a stream (i.e.,\n * serialize it).\n *\n * @serialData The <i>capacity</i> of the HashMap (the length of the\n *             bucket array) is emitted (int), followed by the\n *             <i>size</i> (an int, the number of key-value\n *             mappings), followed by the key (Object) and value (Object)\n *             for each key-value mapping.  The key-value mappings are\n *             emitted in no particular order.\n */\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws IOException {\n    int buckets = capacity();\n    // Write out the threshold, loadfactor, and any hidden stuff\n    s.defaultWriteObject();\n    s.writeInt(buckets);\n    s.writeInt(size);\n    internalWriteEntries(s);\n}\n\n// Called only from writeObject, to ensure compatible ordering.\nvoid internalWriteEntries(java.io.ObjectOutputStream s) throws IOException {\n    Node<K,V>[] tab;\n    if (size > 0 && (tab = table) != null) {\n        for (int i = 0; i < tab.length; ++i) {\n            for (Node<K,V> e = tab[i]; e != null; e = e.next) {\n                s.writeObject(e.key);\n                s.writeObject(e.value);\n            }\n        }\n    }\n}\n```\n\nHashMap不会将保存数据的数组序列化，而是将元素个数以及每个元素的key、value序列化。而在反序列化的时候，重新计算，填充hashmap：\n\nreadObject的实现：\n\n```\n/**\n * Reconstitute the {@code HashMap} instance from a stream (i.e.,\n * deserialize it).\n */\nprivate void readObject(java.io.ObjectInputStream s)\n    throws IOException, ClassNotFoundException {\n    // Read in the threshold (ignored), loadfactor, and any hidden stuff\n    s.defaultReadObject();\n    reinitialize();\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new InvalidObjectException(\"Illegal load factor: \" +\n                                         loadFactor);\n    s.readInt();                // Read and ignore number of buckets\n    int mappings = s.readInt(); // Read number of mappings (size)\n    if (mappings < 0)\n        throw new InvalidObjectException(\"Illegal mappings count: \" +\n                                         mappings);\n    else if (mappings > 0) { // (if zero, use defaults)\n        // Size the table using given load factor only if within\n        // range of 0.25...4.0\n        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);\n        float fc = (float)mappings / lf + 1.0f;\n        int cap = ((fc < DEFAULT_INITIAL_CAPACITY) ?\n                   DEFAULT_INITIAL_CAPACITY :\n                   (fc >= MAXIMUM_CAPACITY) ?\n                   MAXIMUM_CAPACITY :\n                   tableSizeFor((int)fc));\n        float ft = (float)cap * lf;\n        threshold = ((cap < MAXIMUM_CAPACITY && ft < MAXIMUM_CAPACITY) ?\n                     (int)ft : Integer.MAX_VALUE);\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] tab = (Node<K,V>[])new Node[cap];\n        table = tab;\n\n        // Read the keys and values, and put the mappings in the HashMap\n        for (int i = 0; i < mappings; i++) {\n            @SuppressWarnings(\"unchecked\")\n                K key = (K) s.readObject();\n            @SuppressWarnings(\"unchecked\")\n                V value = (V) s.readObject();\n            putVal(hash(key), key, value, false, false);\n        }\n    }\n}\n```\n\n这样就避免了反序列化之后根据Key获取到的元素与序列化之前获取到的元素不同。\n\n# 4 为什么CopyOnWriteArrayList也需要自定义序列化逻辑？\n\nwriteObject、readObject实现：\n\n```\n   /**\n     * Saves this list to a stream (that is, serializes it).\n     *\n     * @param s the stream\n     * @throws java.io.IOException if an I/O error occurs\n     * @serialData The length of the array backing the list is emitted\n     *               (int), followed by all of its elements (each an Object)\n     *               in the proper order.\n     */\n    private void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException {\n\n        s.defaultWriteObject();\n\n        Object[] elements = getArray();\n        // Write out array length\n        s.writeInt(elements.length);\n\n        // Write out all elements in the proper order.\n        for (Object element : elements)\n            s.writeObject(element);\n    }\n\n    /**\n     * Reconstitutes this list from a stream (that is, deserializes it).\n     * @param s the stream\n     * @throws ClassNotFoundException if the class of a serialized object\n     *         could not be found\n     * @throws java.io.IOException if an I/O error occurs\n     */\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n\n        s.defaultReadObject();\n\n        // bind to new lock\n        resetLock();\n\n        // Read in array length and allocate array\n        int len = s.readInt();\n        Object[] elements = new Object[len];\n\n        // Read in all elements in the proper order.\n        for (int i = 0; i < len; i++)\n            elements[i] = s.readObject();\n        setArray(elements);\n    }\n```\n\n而数组被声明为transient：\n\n```\n/** The array, accessed only via getArray/setArray. */\nprivate transient volatile Object[] array;\n```\n\n可以看出其逻辑和ArrayList相同：是将数组长度以及所有元素序列化，在反序列化的时候新建数组，填充元素。\n\n如果采用默认的序列化机制会有如下问题：存储数据的数组实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化很多null元素，所以ArrayList把元素数组设置为transient。 \n\n# 5 参考资料\n\n- [Why are readObject and writeObject private, and why would I write transient variables explicitly?](http://stackoverflow.com/questions/7467313/why-are-readobject-and-writeobject-private-and-why-would-i-write-transient-vari)\n- [http://www.a-site.cn/article/140346.html](http://www.a-site.cn/article/140346.html)\n\n","source":"_posts/为什么Java-HashMap、CopyOnWriteArrayList等集合自己实现readObject和writeObject方法.md","raw":"---\ntitle: 为什么Java HashMap、CopyOnWriteArrayList等集合自己实现readObject和writeObject方法\ndate: 2016-08-06 21:48:23\ntags: Java\n---\n\nPS:本文源码参考的是JDK 1.8.\n\n# 1 readObject、writeObject方法是什么？作用是什么？\n\n当一个class实现了Serializable接口，那么意味着这个类可以被序列化。如果类不实现readObject、writeObject方法，那么会执行默认的序列化和反序列化逻辑，否则执行自定义的序列化和反序列化逻辑，即readObject、writeObject方法的逻辑。\n\n<!-- more -->\n\nJDK提供的对于Java对象序列化操作的类是ObjectOutputStream，反序列化的类是ObjectInputStream。下面我们来看序列化的实现（ObjectOutputStream.writeObject）。\n\n```\n/**\n * Write the specified object to the ObjectOutputStream.  The class of the\n * object, the signature of the class, and the values of the non-transient\n * and non-static fields of the class and all of its supertypes are\n * written.  Default serialization for a class can be overridden using the\n * writeObject and the readObject methods.  Objects referenced by this\n * object are written transitively so that a complete equivalent graph of\n * objects can be reconstructed by an ObjectInputStream.\n *\n * <p>Exceptions are thrown for problems with the OutputStream and for\n * classes that should not be serialized.  All exceptions are fatal to the\n * OutputStream, which is left in an indeterminate state, and it is up to\n * the caller to ignore or recover the stream state.\n *\n * @throws  InvalidClassException Something is wrong with a class used by\n *          serialization.\n * @throws  NotSerializableException Some object to be serialized does not\n *          implement the java.io.Serializable interface.\n * @throws  IOException Any exception thrown by the underlying\n *          OutputStream.\n */\npublic final void writeObject(Object obj) throws IOException {\n    if (enableOverride) {\n        writeObjectOverride(obj);\n        return;\n    }\n    try {\n        writeObject0(obj, false);\n    } catch (IOException ex) {\n        if (depth == 0) {\n            writeFatalException(ex);\n        }\n        throw ex;\n    }\n}\n```\n\n从方法注释可以看到，此方法正是执行了将对象序列化的操作。并且默认的序列化机制可以通过重写readObject、writeObject方法实现。实际调用的方法writeObject0最终会调到writeSerialData：  \n\n```\n/**\n * Writes instance data for each serializable class of given object, from\n * superclass to subclass.\n */\nprivate void writeSerialData(Object obj, ObjectStreamClass desc)\n    throws IOException\n{\n    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();\n    for (int i = 0; i < slots.length; i++) {\n        ObjectStreamClass slotDesc = slots[i].desc;\n        //如果类重写了writeObject方法\n        if (slotDesc.hasWriteObjectMethod()) {\n            PutFieldImpl oldPut = curPut;\n            curPut = null;\n            SerialCallbackContext oldContext = curContext;\n\n            if (extendedDebugInfo) {\n                debugInfoStack.push(\n                    \"custom writeObject data (class \\\"\" +\n                    slotDesc.getName() + \"\\\")\");\n            }\n            try {\n                curContext = new SerialCallbackContext(obj, slotDesc);\n                bout.setBlockDataMode(true);\n                //调用实现类自己的writeobject方法\n                slotDesc.invokeWriteObject(obj, this);\n                bout.setBlockDataMode(false);\n                bout.writeByte(TC_ENDBLOCKDATA);\n            } finally {\n                curContext.setUsed();\n                curContext = oldContext;\n                if (extendedDebugInfo) {\n                    debugInfoStack.pop();\n                }\n            }\n\n            curPut = oldPut;\n        } else {\n            defaultWriteFields(obj, slotDesc);\n        }\n    }\n}\n```\n\n# 2 为什么是private方法？\n\njavadoc上没有明确说明声明为private的原因，一个可能的原因是，除了子类以外没有其他类会使用它，这样不会被滥用。\n\n另一个原因是，不希望这些方法被子类override。每个类都可以有自己的writeObject方法，序列化引擎会逐一调用。readObject相同。\n\n\n# 3 HashMap中对readObject、writeObject方法的实现\n\n## 3.1 为什么HashMap要自定义序列化逻辑\n\n下文是摘自《Effective Java》：\n\n<i>For example, consider the case of a hash table. The physical representation is a sequence of hash buckets containing key-value entries. The bucket that an entry resides in is a function of the hash code of its key, which is not, in general, guaranteed to be the same from JVM implementation to JVM implementation. In fact, it isn't even guaranteed to be the same from run to run. Therefore, accepting the default serialized form for a hash table would constitute a serious bug. Serializing and deserializing the hash table could yield an object whose invariants were seriously corrupt.</i>\n\n大概意思是：对于同一个key，在不同的JVM平台上计算出来的hash值可能不同，导致的结果就是，同一个hashmap反序列化之后和序列化之前不同，导致同一个key取出来的值不同。\n\n## 3.1 HashMap是如何解决的\n\n- 将可能造成数据不一致的元素使用transient修饰，在序列化的时候忽略这些元素：  \n<i>\nEntry[] table  \nsize  \nmodCount\n</i>\n\n- HashMap中对writeObject的实现：\n\n```\n/**\n * Save the state of the <tt>HashMap</tt> instance to a stream (i.e.,\n * serialize it).\n *\n * @serialData The <i>capacity</i> of the HashMap (the length of the\n *             bucket array) is emitted (int), followed by the\n *             <i>size</i> (an int, the number of key-value\n *             mappings), followed by the key (Object) and value (Object)\n *             for each key-value mapping.  The key-value mappings are\n *             emitted in no particular order.\n */\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws IOException {\n    int buckets = capacity();\n    // Write out the threshold, loadfactor, and any hidden stuff\n    s.defaultWriteObject();\n    s.writeInt(buckets);\n    s.writeInt(size);\n    internalWriteEntries(s);\n}\n\n// Called only from writeObject, to ensure compatible ordering.\nvoid internalWriteEntries(java.io.ObjectOutputStream s) throws IOException {\n    Node<K,V>[] tab;\n    if (size > 0 && (tab = table) != null) {\n        for (int i = 0; i < tab.length; ++i) {\n            for (Node<K,V> e = tab[i]; e != null; e = e.next) {\n                s.writeObject(e.key);\n                s.writeObject(e.value);\n            }\n        }\n    }\n}\n```\n\nHashMap不会将保存数据的数组序列化，而是将元素个数以及每个元素的key、value序列化。而在反序列化的时候，重新计算，填充hashmap：\n\nreadObject的实现：\n\n```\n/**\n * Reconstitute the {@code HashMap} instance from a stream (i.e.,\n * deserialize it).\n */\nprivate void readObject(java.io.ObjectInputStream s)\n    throws IOException, ClassNotFoundException {\n    // Read in the threshold (ignored), loadfactor, and any hidden stuff\n    s.defaultReadObject();\n    reinitialize();\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new InvalidObjectException(\"Illegal load factor: \" +\n                                         loadFactor);\n    s.readInt();                // Read and ignore number of buckets\n    int mappings = s.readInt(); // Read number of mappings (size)\n    if (mappings < 0)\n        throw new InvalidObjectException(\"Illegal mappings count: \" +\n                                         mappings);\n    else if (mappings > 0) { // (if zero, use defaults)\n        // Size the table using given load factor only if within\n        // range of 0.25...4.0\n        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);\n        float fc = (float)mappings / lf + 1.0f;\n        int cap = ((fc < DEFAULT_INITIAL_CAPACITY) ?\n                   DEFAULT_INITIAL_CAPACITY :\n                   (fc >= MAXIMUM_CAPACITY) ?\n                   MAXIMUM_CAPACITY :\n                   tableSizeFor((int)fc));\n        float ft = (float)cap * lf;\n        threshold = ((cap < MAXIMUM_CAPACITY && ft < MAXIMUM_CAPACITY) ?\n                     (int)ft : Integer.MAX_VALUE);\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] tab = (Node<K,V>[])new Node[cap];\n        table = tab;\n\n        // Read the keys and values, and put the mappings in the HashMap\n        for (int i = 0; i < mappings; i++) {\n            @SuppressWarnings(\"unchecked\")\n                K key = (K) s.readObject();\n            @SuppressWarnings(\"unchecked\")\n                V value = (V) s.readObject();\n            putVal(hash(key), key, value, false, false);\n        }\n    }\n}\n```\n\n这样就避免了反序列化之后根据Key获取到的元素与序列化之前获取到的元素不同。\n\n# 4 为什么CopyOnWriteArrayList也需要自定义序列化逻辑？\n\nwriteObject、readObject实现：\n\n```\n   /**\n     * Saves this list to a stream (that is, serializes it).\n     *\n     * @param s the stream\n     * @throws java.io.IOException if an I/O error occurs\n     * @serialData The length of the array backing the list is emitted\n     *               (int), followed by all of its elements (each an Object)\n     *               in the proper order.\n     */\n    private void writeObject(java.io.ObjectOutputStream s)\n        throws java.io.IOException {\n\n        s.defaultWriteObject();\n\n        Object[] elements = getArray();\n        // Write out array length\n        s.writeInt(elements.length);\n\n        // Write out all elements in the proper order.\n        for (Object element : elements)\n            s.writeObject(element);\n    }\n\n    /**\n     * Reconstitutes this list from a stream (that is, deserializes it).\n     * @param s the stream\n     * @throws ClassNotFoundException if the class of a serialized object\n     *         could not be found\n     * @throws java.io.IOException if an I/O error occurs\n     */\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n\n        s.defaultReadObject();\n\n        // bind to new lock\n        resetLock();\n\n        // Read in array length and allocate array\n        int len = s.readInt();\n        Object[] elements = new Object[len];\n\n        // Read in all elements in the proper order.\n        for (int i = 0; i < len; i++)\n            elements[i] = s.readObject();\n        setArray(elements);\n    }\n```\n\n而数组被声明为transient：\n\n```\n/** The array, accessed only via getArray/setArray. */\nprivate transient volatile Object[] array;\n```\n\n可以看出其逻辑和ArrayList相同：是将数组长度以及所有元素序列化，在反序列化的时候新建数组，填充元素。\n\n如果采用默认的序列化机制会有如下问题：存储数据的数组实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化很多null元素，所以ArrayList把元素数组设置为transient。 \n\n# 5 参考资料\n\n- [Why are readObject and writeObject private, and why would I write transient variables explicitly?](http://stackoverflow.com/questions/7467313/why-are-readobject-and-writeobject-private-and-why-would-i-write-transient-vari)\n- [http://www.a-site.cn/article/140346.html](http://www.a-site.cn/article/140346.html)\n\n","slug":"为什么Java-HashMap、CopyOnWriteArrayList等集合自己实现readObject和writeObject方法","published":1,"updated":"2016-09-07T08:01:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsbw000e2hwf95t0j40v","content":"<p>PS:本文源码参考的是JDK 1.8.</p>\n<h1 id=\"1-readObject、writeObject方法是什么？作用是什么？\"><a href=\"#1-readObject、writeObject方法是什么？作用是什么？\" class=\"headerlink\" title=\"1 readObject、writeObject方法是什么？作用是什么？\"></a>1 readObject、writeObject方法是什么？作用是什么？</h1><p>当一个class实现了Serializable接口，那么意味着这个类可以被序列化。如果类不实现readObject、writeObject方法，那么会执行默认的序列化和反序列化逻辑，否则执行自定义的序列化和反序列化逻辑，即readObject、writeObject方法的逻辑。</p>\n<a id=\"more\"></a>\n<p>JDK提供的对于Java对象序列化操作的类是ObjectOutputStream，反序列化的类是ObjectInputStream。下面我们来看序列化的实现（ObjectOutputStream.writeObject）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Write the specified object to the ObjectOutputStream.  The class of the</div><div class=\"line\"> * object, the signature of the class, and the values of the non-transient</div><div class=\"line\"> * and non-static fields of the class and all of its supertypes are</div><div class=\"line\"> * written.  Default serialization for a class can be overridden using the</div><div class=\"line\"> * writeObject and the readObject methods.  Objects referenced by this</div><div class=\"line\"> * object are written transitively so that a complete equivalent graph of</div><div class=\"line\"> * objects can be reconstructed by an ObjectInputStream.</div><div class=\"line\"> *</div><div class=\"line\"> * &lt;p&gt;Exceptions are thrown for problems with the OutputStream and for</div><div class=\"line\"> * classes that should not be serialized.  All exceptions are fatal to the</div><div class=\"line\"> * OutputStream, which is left in an indeterminate state, and it is up to</div><div class=\"line\"> * the caller to ignore or recover the stream state.</div><div class=\"line\"> *</div><div class=\"line\"> * @throws  InvalidClassException Something is wrong with a class used by</div><div class=\"line\"> *          serialization.</div><div class=\"line\"> * @throws  NotSerializableException Some object to be serialized does not</div><div class=\"line\"> *          implement the java.io.Serializable interface.</div><div class=\"line\"> * @throws  IOException Any exception thrown by the underlying</div><div class=\"line\"> *          OutputStream.</div><div class=\"line\"> */</div><div class=\"line\">public final void writeObject(Object obj) throws IOException &#123;</div><div class=\"line\">    if (enableOverride) &#123;</div><div class=\"line\">        writeObjectOverride(obj);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        writeObject0(obj, false);</div><div class=\"line\">    &#125; catch (IOException ex) &#123;</div><div class=\"line\">        if (depth == 0) &#123;</div><div class=\"line\">            writeFatalException(ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw ex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从方法注释可以看到，此方法正是执行了将对象序列化的操作。并且默认的序列化机制可以通过重写readObject、writeObject方法实现。实际调用的方法writeObject0最终会调到writeSerialData：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Writes instance data for each serializable class of given object, from</div><div class=\"line\"> * superclass to subclass.</div><div class=\"line\"> */</div><div class=\"line\">private void writeSerialData(Object obj, ObjectStreamClass desc)</div><div class=\"line\">    throws IOException</div><div class=\"line\">&#123;</div><div class=\"line\">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</div><div class=\"line\">    for (int i = 0; i &lt; slots.length; i++) &#123;</div><div class=\"line\">        ObjectStreamClass slotDesc = slots[i].desc;</div><div class=\"line\">        //如果类重写了writeObject方法</div><div class=\"line\">        if (slotDesc.hasWriteObjectMethod()) &#123;</div><div class=\"line\">            PutFieldImpl oldPut = curPut;</div><div class=\"line\">            curPut = null;</div><div class=\"line\">            SerialCallbackContext oldContext = curContext;</div><div class=\"line\"></div><div class=\"line\">            if (extendedDebugInfo) &#123;</div><div class=\"line\">                debugInfoStack.push(</div><div class=\"line\">                    &quot;custom writeObject data (class \\&quot;&quot; +</div><div class=\"line\">                    slotDesc.getName() + &quot;\\&quot;)&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                curContext = new SerialCallbackContext(obj, slotDesc);</div><div class=\"line\">                bout.setBlockDataMode(true);</div><div class=\"line\">                //调用实现类自己的writeobject方法</div><div class=\"line\">                slotDesc.invokeWriteObject(obj, this);</div><div class=\"line\">                bout.setBlockDataMode(false);</div><div class=\"line\">                bout.writeByte(TC_ENDBLOCKDATA);</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                curContext.setUsed();</div><div class=\"line\">                curContext = oldContext;</div><div class=\"line\">                if (extendedDebugInfo) &#123;</div><div class=\"line\">                    debugInfoStack.pop();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            curPut = oldPut;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            defaultWriteFields(obj, slotDesc);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"2-为什么是private方法？\"><a href=\"#2-为什么是private方法？\" class=\"headerlink\" title=\"2 为什么是private方法？\"></a>2 为什么是private方法？</h1><p>javadoc上没有明确说明声明为private的原因，一个可能的原因是，除了子类以外没有其他类会使用它，这样不会被滥用。</p>\n<p>另一个原因是，不希望这些方法被子类override。每个类都可以有自己的writeObject方法，序列化引擎会逐一调用。readObject相同。</p>\n<h1 id=\"3-HashMap中对readObject、writeObject方法的实现\"><a href=\"#3-HashMap中对readObject、writeObject方法的实现\" class=\"headerlink\" title=\"3 HashMap中对readObject、writeObject方法的实现\"></a>3 HashMap中对readObject、writeObject方法的实现</h1><h2 id=\"3-1-为什么HashMap要自定义序列化逻辑\"><a href=\"#3-1-为什么HashMap要自定义序列化逻辑\" class=\"headerlink\" title=\"3.1 为什么HashMap要自定义序列化逻辑\"></a>3.1 为什么HashMap要自定义序列化逻辑</h2><p>下文是摘自《Effective Java》：</p>\n<p><i>For example, consider the case of a hash table. The physical representation is a sequence of hash buckets containing key-value entries. The bucket that an entry resides in is a function of the hash code of its key, which is not, in general, guaranteed to be the same from JVM implementation to JVM implementation. In fact, it isn’t even guaranteed to be the same from run to run. Therefore, accepting the default serialized form for a hash table would constitute a serious bug. Serializing and deserializing the hash table could yield an object whose invariants were seriously corrupt.</i></p>\n<p>大概意思是：对于同一个key，在不同的JVM平台上计算出来的hash值可能不同，导致的结果就是，同一个hashmap反序列化之后和序列化之前不同，导致同一个key取出来的值不同。</p>\n<h2 id=\"3-1-HashMap是如何解决的\"><a href=\"#3-1-HashMap是如何解决的\" class=\"headerlink\" title=\"3.1 HashMap是如何解决的\"></a>3.1 HashMap是如何解决的</h2><ul>\n<li><p>将可能造成数据不一致的元素使用transient修饰，在序列化的时候忽略这些元素：<br><i><br>Entry[] table<br>size<br>modCount<br></i></p>\n</li>\n<li><p>HashMap中对writeObject的实现：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</div><div class=\"line\"> * serialize it).</div><div class=\"line\"> *</div><div class=\"line\"> * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</div><div class=\"line\"> *             bucket array) is emitted (int), followed by the</div><div class=\"line\"> *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</div><div class=\"line\"> *             mappings), followed by the key (Object) and value (Object)</div><div class=\"line\"> *             for each key-value mapping.  The key-value mappings are</div><div class=\"line\"> *             emitted in no particular order.</div><div class=\"line\"> */</div><div class=\"line\">private void writeObject(java.io.ObjectOutputStream s)</div><div class=\"line\">    throws IOException &#123;</div><div class=\"line\">    int buckets = capacity();</div><div class=\"line\">    // Write out the threshold, loadfactor, and any hidden stuff</div><div class=\"line\">    s.defaultWriteObject();</div><div class=\"line\">    s.writeInt(buckets);</div><div class=\"line\">    s.writeInt(size);</div><div class=\"line\">    internalWriteEntries(s);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Called only from writeObject, to ensure compatible ordering.</div><div class=\"line\">void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123;</div><div class=\"line\">    Node&lt;K,V&gt;[] tab;</div><div class=\"line\">    if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; tab.length; ++i) &#123;</div><div class=\"line\">            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</div><div class=\"line\">                s.writeObject(e.key);</div><div class=\"line\">                s.writeObject(e.value);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>HashMap不会将保存数据的数组序列化，而是将元素个数以及每个元素的key、value序列化。而在反序列化的时候，重新计算，填充hashmap：</p>\n<p>readObject的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Reconstitute the &#123;@code HashMap&#125; instance from a stream (i.e.,</div><div class=\"line\"> * deserialize it).</div><div class=\"line\"> */</div><div class=\"line\">private void readObject(java.io.ObjectInputStream s)</div><div class=\"line\">    throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">    // Read in the threshold (ignored), loadfactor, and any hidden stuff</div><div class=\"line\">    s.defaultReadObject();</div><div class=\"line\">    reinitialize();</div><div class=\"line\">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class=\"line\">        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</div><div class=\"line\">                                         loadFactor);</div><div class=\"line\">    s.readInt();                // Read and ignore number of buckets</div><div class=\"line\">    int mappings = s.readInt(); // Read number of mappings (size)</div><div class=\"line\">    if (mappings &lt; 0)</div><div class=\"line\">        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</div><div class=\"line\">                                         mappings);</div><div class=\"line\">    else if (mappings &gt; 0) &#123; // (if zero, use defaults)</div><div class=\"line\">        // Size the table using given load factor only if within</div><div class=\"line\">        // range of 0.25...4.0</div><div class=\"line\">        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);</div><div class=\"line\">        float fc = (float)mappings / lf + 1.0f;</div><div class=\"line\">        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</div><div class=\"line\">                   DEFAULT_INITIAL_CAPACITY :</div><div class=\"line\">                   (fc &gt;= MAXIMUM_CAPACITY) ?</div><div class=\"line\">                   MAXIMUM_CAPACITY :</div><div class=\"line\">                   tableSizeFor((int)fc));</div><div class=\"line\">        float ft = (float)cap * lf;</div><div class=\"line\">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</div><div class=\"line\">                     (int)ft : Integer.MAX_VALUE);</div><div class=\"line\">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class=\"line\">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];</div><div class=\"line\">        table = tab;</div><div class=\"line\"></div><div class=\"line\">        // Read the keys and values, and put the mappings in the HashMap</div><div class=\"line\">        for (int i = 0; i &lt; mappings; i++) &#123;</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">                K key = (K) s.readObject();</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">                V value = (V) s.readObject();</div><div class=\"line\">            putVal(hash(key), key, value, false, false);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就避免了反序列化之后根据Key获取到的元素与序列化之前获取到的元素不同。</p>\n<h1 id=\"4-为什么CopyOnWriteArrayList也需要自定义序列化逻辑？\"><a href=\"#4-为什么CopyOnWriteArrayList也需要自定义序列化逻辑？\" class=\"headerlink\" title=\"4 为什么CopyOnWriteArrayList也需要自定义序列化逻辑？\"></a>4 为什么CopyOnWriteArrayList也需要自定义序列化逻辑？</h1><p>writeObject、readObject实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">  * Saves this list to a stream (that is, serializes it).</div><div class=\"line\">  *</div><div class=\"line\">  * @param s the stream</div><div class=\"line\">  * @throws java.io.IOException if an I/O error occurs</div><div class=\"line\">  * @serialData The length of the array backing the list is emitted</div><div class=\"line\">  *               (int), followed by all of its elements (each an Object)</div><div class=\"line\">  *               in the proper order.</div><div class=\"line\">  */</div><div class=\"line\"> private void writeObject(java.io.ObjectOutputStream s)</div><div class=\"line\">     throws java.io.IOException &#123;</div><div class=\"line\"></div><div class=\"line\">     s.defaultWriteObject();</div><div class=\"line\"></div><div class=\"line\">     Object[] elements = getArray();</div><div class=\"line\">     // Write out array length</div><div class=\"line\">     s.writeInt(elements.length);</div><div class=\"line\"></div><div class=\"line\">     // Write out all elements in the proper order.</div><div class=\"line\">     for (Object element : elements)</div><div class=\"line\">         s.writeObject(element);</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> /**</div><div class=\"line\">  * Reconstitutes this list from a stream (that is, deserializes it).</div><div class=\"line\">  * @param s the stream</div><div class=\"line\">  * @throws ClassNotFoundException if the class of a serialized object</div><div class=\"line\">  *         could not be found</div><div class=\"line\">  * @throws java.io.IOException if an I/O error occurs</div><div class=\"line\">  */</div><div class=\"line\"> private void readObject(java.io.ObjectInputStream s)</div><div class=\"line\">     throws java.io.IOException, ClassNotFoundException &#123;</div><div class=\"line\"></div><div class=\"line\">     s.defaultReadObject();</div><div class=\"line\"></div><div class=\"line\">     // bind to new lock</div><div class=\"line\">     resetLock();</div><div class=\"line\"></div><div class=\"line\">     // Read in array length and allocate array</div><div class=\"line\">     int len = s.readInt();</div><div class=\"line\">     Object[] elements = new Object[len];</div><div class=\"line\"></div><div class=\"line\">     // Read in all elements in the proper order.</div><div class=\"line\">     for (int i = 0; i &lt; len; i++)</div><div class=\"line\">         elements[i] = s.readObject();</div><div class=\"line\">     setArray(elements);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>而数组被声明为transient：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** The array, accessed only via getArray/setArray. */</div><div class=\"line\">private transient volatile Object[] array;</div></pre></td></tr></table></figure>\n<p>可以看出其逻辑和ArrayList相同：是将数组长度以及所有元素序列化，在反序列化的时候新建数组，填充元素。</p>\n<p>如果采用默认的序列化机制会有如下问题：存储数据的数组实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化很多null元素，所以ArrayList把元素数组设置为transient。 </p>\n<h1 id=\"5-参考资料\"><a href=\"#5-参考资料\" class=\"headerlink\" title=\"5 参考资料\"></a>5 参考资料</h1><ul>\n<li><a href=\"http://stackoverflow.com/questions/7467313/why-are-readobject-and-writeobject-private-and-why-would-i-write-transient-vari\" target=\"_blank\" rel=\"external\">Why are readObject and writeObject private, and why would I write transient variables explicitly?</a></li>\n<li><a href=\"http://www.a-site.cn/article/140346.html\" target=\"_blank\" rel=\"external\">http://www.a-site.cn/article/140346.html</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/08/06/为什么Java-HashMap、CopyOnWriteArrayList等集合自己实现readObject和writeObject方法/\">http://xiajunhust.github.io/2016/08/06/为什么Java-HashMap、CopyOnWriteArrayList等集合自己实现readObject和writeObject方法/</a></p>\n","excerpt":"<p>PS:本文源码参考的是JDK 1.8.</p>\n<h1 id=\"1-readObject、writeObject方法是什么？作用是什么？\"><a href=\"#1-readObject、writeObject方法是什么？作用是什么？\" class=\"headerlink\" title=\"1 readObject、writeObject方法是什么？作用是什么？\"></a>1 readObject、writeObject方法是什么？作用是什么？</h1><p>当一个class实现了Serializable接口，那么意味着这个类可以被序列化。如果类不实现readObject、writeObject方法，那么会执行默认的序列化和反序列化逻辑，否则执行自定义的序列化和反序列化逻辑，即readObject、writeObject方法的逻辑。</p>","more":"<p>JDK提供的对于Java对象序列化操作的类是ObjectOutputStream，反序列化的类是ObjectInputStream。下面我们来看序列化的实现（ObjectOutputStream.writeObject）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Write the specified object to the ObjectOutputStream.  The class of the</div><div class=\"line\"> * object, the signature of the class, and the values of the non-transient</div><div class=\"line\"> * and non-static fields of the class and all of its supertypes are</div><div class=\"line\"> * written.  Default serialization for a class can be overridden using the</div><div class=\"line\"> * writeObject and the readObject methods.  Objects referenced by this</div><div class=\"line\"> * object are written transitively so that a complete equivalent graph of</div><div class=\"line\"> * objects can be reconstructed by an ObjectInputStream.</div><div class=\"line\"> *</div><div class=\"line\"> * &lt;p&gt;Exceptions are thrown for problems with the OutputStream and for</div><div class=\"line\"> * classes that should not be serialized.  All exceptions are fatal to the</div><div class=\"line\"> * OutputStream, which is left in an indeterminate state, and it is up to</div><div class=\"line\"> * the caller to ignore or recover the stream state.</div><div class=\"line\"> *</div><div class=\"line\"> * @throws  InvalidClassException Something is wrong with a class used by</div><div class=\"line\"> *          serialization.</div><div class=\"line\"> * @throws  NotSerializableException Some object to be serialized does not</div><div class=\"line\"> *          implement the java.io.Serializable interface.</div><div class=\"line\"> * @throws  IOException Any exception thrown by the underlying</div><div class=\"line\"> *          OutputStream.</div><div class=\"line\"> */</div><div class=\"line\">public final void writeObject(Object obj) throws IOException &#123;</div><div class=\"line\">    if (enableOverride) &#123;</div><div class=\"line\">        writeObjectOverride(obj);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        writeObject0(obj, false);</div><div class=\"line\">    &#125; catch (IOException ex) &#123;</div><div class=\"line\">        if (depth == 0) &#123;</div><div class=\"line\">            writeFatalException(ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">        throw ex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从方法注释可以看到，此方法正是执行了将对象序列化的操作。并且默认的序列化机制可以通过重写readObject、writeObject方法实现。实际调用的方法writeObject0最终会调到writeSerialData：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Writes instance data for each serializable class of given object, from</div><div class=\"line\"> * superclass to subclass.</div><div class=\"line\"> */</div><div class=\"line\">private void writeSerialData(Object obj, ObjectStreamClass desc)</div><div class=\"line\">    throws IOException</div><div class=\"line\">&#123;</div><div class=\"line\">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</div><div class=\"line\">    for (int i = 0; i &lt; slots.length; i++) &#123;</div><div class=\"line\">        ObjectStreamClass slotDesc = slots[i].desc;</div><div class=\"line\">        //如果类重写了writeObject方法</div><div class=\"line\">        if (slotDesc.hasWriteObjectMethod()) &#123;</div><div class=\"line\">            PutFieldImpl oldPut = curPut;</div><div class=\"line\">            curPut = null;</div><div class=\"line\">            SerialCallbackContext oldContext = curContext;</div><div class=\"line\"></div><div class=\"line\">            if (extendedDebugInfo) &#123;</div><div class=\"line\">                debugInfoStack.push(</div><div class=\"line\">                    &quot;custom writeObject data (class \\&quot;&quot; +</div><div class=\"line\">                    slotDesc.getName() + &quot;\\&quot;)&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                curContext = new SerialCallbackContext(obj, slotDesc);</div><div class=\"line\">                bout.setBlockDataMode(true);</div><div class=\"line\">                //调用实现类自己的writeobject方法</div><div class=\"line\">                slotDesc.invokeWriteObject(obj, this);</div><div class=\"line\">                bout.setBlockDataMode(false);</div><div class=\"line\">                bout.writeByte(TC_ENDBLOCKDATA);</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                curContext.setUsed();</div><div class=\"line\">                curContext = oldContext;</div><div class=\"line\">                if (extendedDebugInfo) &#123;</div><div class=\"line\">                    debugInfoStack.pop();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            curPut = oldPut;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            defaultWriteFields(obj, slotDesc);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"2-为什么是private方法？\"><a href=\"#2-为什么是private方法？\" class=\"headerlink\" title=\"2 为什么是private方法？\"></a>2 为什么是private方法？</h1><p>javadoc上没有明确说明声明为private的原因，一个可能的原因是，除了子类以外没有其他类会使用它，这样不会被滥用。</p>\n<p>另一个原因是，不希望这些方法被子类override。每个类都可以有自己的writeObject方法，序列化引擎会逐一调用。readObject相同。</p>\n<h1 id=\"3-HashMap中对readObject、writeObject方法的实现\"><a href=\"#3-HashMap中对readObject、writeObject方法的实现\" class=\"headerlink\" title=\"3 HashMap中对readObject、writeObject方法的实现\"></a>3 HashMap中对readObject、writeObject方法的实现</h1><h2 id=\"3-1-为什么HashMap要自定义序列化逻辑\"><a href=\"#3-1-为什么HashMap要自定义序列化逻辑\" class=\"headerlink\" title=\"3.1 为什么HashMap要自定义序列化逻辑\"></a>3.1 为什么HashMap要自定义序列化逻辑</h2><p>下文是摘自《Effective Java》：</p>\n<p><i>For example, consider the case of a hash table. The physical representation is a sequence of hash buckets containing key-value entries. The bucket that an entry resides in is a function of the hash code of its key, which is not, in general, guaranteed to be the same from JVM implementation to JVM implementation. In fact, it isn’t even guaranteed to be the same from run to run. Therefore, accepting the default serialized form for a hash table would constitute a serious bug. Serializing and deserializing the hash table could yield an object whose invariants were seriously corrupt.</i></p>\n<p>大概意思是：对于同一个key，在不同的JVM平台上计算出来的hash值可能不同，导致的结果就是，同一个hashmap反序列化之后和序列化之前不同，导致同一个key取出来的值不同。</p>\n<h2 id=\"3-1-HashMap是如何解决的\"><a href=\"#3-1-HashMap是如何解决的\" class=\"headerlink\" title=\"3.1 HashMap是如何解决的\"></a>3.1 HashMap是如何解决的</h2><ul>\n<li><p>将可能造成数据不一致的元素使用transient修饰，在序列化的时候忽略这些元素：<br><i><br>Entry[] table<br>size<br>modCount<br></i></p>\n</li>\n<li><p>HashMap中对writeObject的实现：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</div><div class=\"line\"> * serialize it).</div><div class=\"line\"> *</div><div class=\"line\"> * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</div><div class=\"line\"> *             bucket array) is emitted (int), followed by the</div><div class=\"line\"> *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</div><div class=\"line\"> *             mappings), followed by the key (Object) and value (Object)</div><div class=\"line\"> *             for each key-value mapping.  The key-value mappings are</div><div class=\"line\"> *             emitted in no particular order.</div><div class=\"line\"> */</div><div class=\"line\">private void writeObject(java.io.ObjectOutputStream s)</div><div class=\"line\">    throws IOException &#123;</div><div class=\"line\">    int buckets = capacity();</div><div class=\"line\">    // Write out the threshold, loadfactor, and any hidden stuff</div><div class=\"line\">    s.defaultWriteObject();</div><div class=\"line\">    s.writeInt(buckets);</div><div class=\"line\">    s.writeInt(size);</div><div class=\"line\">    internalWriteEntries(s);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Called only from writeObject, to ensure compatible ordering.</div><div class=\"line\">void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123;</div><div class=\"line\">    Node&lt;K,V&gt;[] tab;</div><div class=\"line\">    if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; tab.length; ++i) &#123;</div><div class=\"line\">            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</div><div class=\"line\">                s.writeObject(e.key);</div><div class=\"line\">                s.writeObject(e.value);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>HashMap不会将保存数据的数组序列化，而是将元素个数以及每个元素的key、value序列化。而在反序列化的时候，重新计算，填充hashmap：</p>\n<p>readObject的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Reconstitute the &#123;@code HashMap&#125; instance from a stream (i.e.,</div><div class=\"line\"> * deserialize it).</div><div class=\"line\"> */</div><div class=\"line\">private void readObject(java.io.ObjectInputStream s)</div><div class=\"line\">    throws IOException, ClassNotFoundException &#123;</div><div class=\"line\">    // Read in the threshold (ignored), loadfactor, and any hidden stuff</div><div class=\"line\">    s.defaultReadObject();</div><div class=\"line\">    reinitialize();</div><div class=\"line\">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class=\"line\">        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</div><div class=\"line\">                                         loadFactor);</div><div class=\"line\">    s.readInt();                // Read and ignore number of buckets</div><div class=\"line\">    int mappings = s.readInt(); // Read number of mappings (size)</div><div class=\"line\">    if (mappings &lt; 0)</div><div class=\"line\">        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</div><div class=\"line\">                                         mappings);</div><div class=\"line\">    else if (mappings &gt; 0) &#123; // (if zero, use defaults)</div><div class=\"line\">        // Size the table using given load factor only if within</div><div class=\"line\">        // range of 0.25...4.0</div><div class=\"line\">        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);</div><div class=\"line\">        float fc = (float)mappings / lf + 1.0f;</div><div class=\"line\">        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</div><div class=\"line\">                   DEFAULT_INITIAL_CAPACITY :</div><div class=\"line\">                   (fc &gt;= MAXIMUM_CAPACITY) ?</div><div class=\"line\">                   MAXIMUM_CAPACITY :</div><div class=\"line\">                   tableSizeFor((int)fc));</div><div class=\"line\">        float ft = (float)cap * lf;</div><div class=\"line\">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</div><div class=\"line\">                     (int)ft : Integer.MAX_VALUE);</div><div class=\"line\">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class=\"line\">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];</div><div class=\"line\">        table = tab;</div><div class=\"line\"></div><div class=\"line\">        // Read the keys and values, and put the mappings in the HashMap</div><div class=\"line\">        for (int i = 0; i &lt; mappings; i++) &#123;</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">                K key = (K) s.readObject();</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">                V value = (V) s.readObject();</div><div class=\"line\">            putVal(hash(key), key, value, false, false);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样就避免了反序列化之后根据Key获取到的元素与序列化之前获取到的元素不同。</p>\n<h1 id=\"4-为什么CopyOnWriteArrayList也需要自定义序列化逻辑？\"><a href=\"#4-为什么CopyOnWriteArrayList也需要自定义序列化逻辑？\" class=\"headerlink\" title=\"4 为什么CopyOnWriteArrayList也需要自定义序列化逻辑？\"></a>4 为什么CopyOnWriteArrayList也需要自定义序列化逻辑？</h1><p>writeObject、readObject实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">  * Saves this list to a stream (that is, serializes it).</div><div class=\"line\">  *</div><div class=\"line\">  * @param s the stream</div><div class=\"line\">  * @throws java.io.IOException if an I/O error occurs</div><div class=\"line\">  * @serialData The length of the array backing the list is emitted</div><div class=\"line\">  *               (int), followed by all of its elements (each an Object)</div><div class=\"line\">  *               in the proper order.</div><div class=\"line\">  */</div><div class=\"line\"> private void writeObject(java.io.ObjectOutputStream s)</div><div class=\"line\">     throws java.io.IOException &#123;</div><div class=\"line\"></div><div class=\"line\">     s.defaultWriteObject();</div><div class=\"line\"></div><div class=\"line\">     Object[] elements = getArray();</div><div class=\"line\">     // Write out array length</div><div class=\"line\">     s.writeInt(elements.length);</div><div class=\"line\"></div><div class=\"line\">     // Write out all elements in the proper order.</div><div class=\"line\">     for (Object element : elements)</div><div class=\"line\">         s.writeObject(element);</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> /**</div><div class=\"line\">  * Reconstitutes this list from a stream (that is, deserializes it).</div><div class=\"line\">  * @param s the stream</div><div class=\"line\">  * @throws ClassNotFoundException if the class of a serialized object</div><div class=\"line\">  *         could not be found</div><div class=\"line\">  * @throws java.io.IOException if an I/O error occurs</div><div class=\"line\">  */</div><div class=\"line\"> private void readObject(java.io.ObjectInputStream s)</div><div class=\"line\">     throws java.io.IOException, ClassNotFoundException &#123;</div><div class=\"line\"></div><div class=\"line\">     s.defaultReadObject();</div><div class=\"line\"></div><div class=\"line\">     // bind to new lock</div><div class=\"line\">     resetLock();</div><div class=\"line\"></div><div class=\"line\">     // Read in array length and allocate array</div><div class=\"line\">     int len = s.readInt();</div><div class=\"line\">     Object[] elements = new Object[len];</div><div class=\"line\"></div><div class=\"line\">     // Read in all elements in the proper order.</div><div class=\"line\">     for (int i = 0; i &lt; len; i++)</div><div class=\"line\">         elements[i] = s.readObject();</div><div class=\"line\">     setArray(elements);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>而数组被声明为transient：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** The array, accessed only via getArray/setArray. */</div><div class=\"line\">private transient volatile Object[] array;</div></pre></td></tr></table></figure>\n<p>可以看出其逻辑和ArrayList相同：是将数组长度以及所有元素序列化，在反序列化的时候新建数组，填充元素。</p>\n<p>如果采用默认的序列化机制会有如下问题：存储数据的数组实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化很多null元素，所以ArrayList把元素数组设置为transient。 </p>\n<h1 id=\"5-参考资料\"><a href=\"#5-参考资料\" class=\"headerlink\" title=\"5 参考资料\"></a>5 参考资料</h1><ul>\n<li><a href=\"http://stackoverflow.com/questions/7467313/why-are-readobject-and-writeobject-private-and-why-would-i-write-transient-vari\">Why are readObject and writeObject private, and why would I write transient variables explicitly?</a></li>\n<li><a href=\"http://www.a-site.cn/article/140346.html\">http://www.a-site.cn/article/140346.html</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/08/06/为什么Java-HashMap、CopyOnWriteArrayList等集合自己实现readObject和writeObject方法/\">http://xiajunhust.github.io/2016/08/06/为什么Java-HashMap、CopyOnWriteArrayList等集合自己实现readObject和writeObject方法/</a></p>"},{"title":"RocketMQ源码学习之二-同步消息发送","date":"2016-11-12T12:52:32.000Z","_content":"\n本文讲述RocketMQ同步发送消息的原理。\n\n# 1 消息生产者demo  \n先看一段同步发送消息的demo代码：  \n\n```\nimport com.alibaba.rocketmq.client.exception.MQClientException;\nimport com.alibaba.rocketmq.client.producer.DefaultMQProducer;\nimport com.alibaba.rocketmq.client.producer.SendResult;\nimport com.alibaba.rocketmq.common.message.Message;\n\npublic class Producer1 {\n  public static void main(String[] args) throws MQClientException, InterruptedException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\");\n    producer.setNamesrvAddr(\"192.168.2.101:9876\");\n    producer.setInstanceName(\"Producer1\");\n    producer.start();\n    for (int i = 0; i < 1; i++)\n      try {\n        {\n          Message msg = new Message(\"TopicTest\",// topic\n                                    \"TagA\",// tag\n                                    \"OrderID188\",// key\n                                    (\"Hello MetaQ\").getBytes());// body\n          SendResult sendResult = producer.send(msg);\n          System.out.println(sendResult);\n        }\n\n      }\n      catch (Exception e) {\n        e.printStackTrace();\n      }\n\n    producer.shutdown();\n  }\n}\n\n```\n\n<!-- more -->\n\n运行结果：\n\n```\nlog4j:WARN No appenders could be found for logger (com.alibaba.rocketmq.shade.io.netty.util.internal.logging.InternalLoggerFactory).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.\nSendResult [sendStatus=SEND_OK, msgId=C0A8026507741218025C3A983E8F0000,offsetMsgId=C0A8026500002A9F0000000000001A0C, messageQueue=MessageQueue [topic=TopicTest, brokerName=xiajuns-MacBook-Pro.local, queueId=1], queueOffset=0]\n\nProcess finished with exit code 0\n```\n\n# 2 同步消息发送原理分析  \nRocketMQ网络部署图：  \n![RocketMQ网络部署图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-1.jpeg)\n\n原理：同步发送是指消息发送方发出数据后，会在收到接收方发回响应之后才发下一个数据包的通讯方式。\n\n![同步消息发送原理示意图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-2-1.png)\n\n应用场景：此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。\n\nRocketMQ发送同步消息的整体序列图如下：  \n![RocketMQ同步消息发送整体序列图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-2.jpg)\n\n下面进行具体分析。  \n\n## 2.1 发送消息前  \n同步消息发送的入口函数是DefaultMQProducer.send(Message msg).  \n发送消息之前需要完成如下事情：   \n\n- 创建DefaultMQProducer实例  \n其实就是指定group名字，以及创建了DefaultMQProducerImpl实例。发送晓得具体操作都是在DefaultMQProducerImpl中完成的，DefaultMQProducer只是做了一层封装。  \n- 给DefaultMQProducer实例设置nameserver地址  \n- 启动生产者  \n启动过程较复杂，下面详细分析。  \n首先判断服务状态，如果正在运行或者启动失败、已关闭，则抛出异常。否则执行下面的启动流程。  \n\n```\n//初始化服务状态为启动失败\nthis.serviceState = ServiceState.START_FAILED;\n\n//检查配置，主要是ProducerGroup\nthis.checkConfig();\n\nif (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) {\n    this.defaultMQProducer.changeInstanceNameToPID();\n}\n\n//创建MQClientInstance实例（MQClientInstance是MQ客户端实例，负责执行一些定时任务比如定时更新nameserver地址、从nameserver更新topic路由信息、向broker发送心跳等等。\n//MQClientManager负责创建MQClientInstance，每个clientId只创建一个，第一次创建完成之后存放在一个ConcurrentHashMap中）\nthis.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);\n\n//注册Producer。实际就是将group名、Producer键值对存到producerTable ConcurrentHashMap里\nboolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);\nif (!registerOK) {\n    this.serviceState = ServiceState.CREATE_JUST;\n    throw new MQClientException(\"The producer group[\" + this.defaultMQProducer.getProducerGroup()\n            + \"] has been created before, specify another name please.\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),\n            null);\n}\n\n//存储TopicPublishInfo\nthis.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());\n\n//启动MQClientInstance（startFactory默认是true）\nif (startFactory) {\n    mQClientFactory.start();\n}\n\nlog.info(\"the producer [{}] start OK. sendMessageWithVIPChannel={}\", this.defaultMQProducer.getProducerGroup(),\n        this.defaultMQProducer.isSendMessageWithVIPChannel());\n        \n//更改服务状态\nthis.serviceState = ServiceState.RUNNING;\n```\n\n## 2.2 发送消息  \n序列图：  \n![同步消息发送具体步骤](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-3.jpg)\n\n单步跟进，发现DefaultMQProducer.send(Message msg)会最终调到DefaultMQProducerImpl的这个方法：\n\n```\npublic SendResult send(Message msg, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n    return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);\n}\n```\n\n可以看到调sendDefaultImpl传递的CommunicationMode是SYNC，是同步模式：  \n\n```\n//三种消息模式枚举类型\npublic enum CommunicationMode {\n//同步\nSYNC,\n//异步\nASYNC,\n//单向\nONEWAY,\n}\n```\n\n接下来调到sendKernelImpl方法，下面摘取重要的部分：  \n\n```\nprivate SendResult sendKernelImpl(final Message msg, //\n                                  final MessageQueue mq, //\n                                  final CommunicationMode communicationMode, //\n                                  final SendCallback sendCallback, //\n                                  final TopicPublishInfo topicPublishInfo, //\n                                  final long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n    //获取broker地址\n    String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());\n    if (null == brokerAddr) {\n        tryToFindTopicPublishInfo(mq.getTopic());\n        brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());\n    }\n\n    SendMessageContext context = null;\n    if (brokerAddr != null) {\n        brokerAddr = MixAll.brokerVIPChannel(this.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);\n\n        byte[] prevBody = msg.getBody();\n        try {\n\t\t\t  //消息ID生成\n            MessageClientIDSetter.setUniqID(msg);\n\n            int sysFlag = 0;\n            if (this.tryToCompressMessage(msg)) {\n                sysFlag |= MessageSysFlag.CompressedFlag;\n            }\n\n            final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n            if (tranMsg != null && Boolean.parseBoolean(tranMsg)) {\n                sysFlag |= MessageSysFlag.TransactionPreparedType;\n            }\n\n\t\t\t  //一些钩子函数执行\n            if (hasCheckForbiddenHook()) {\n                ...\n            }\n\n            if (this.hasSendMessageHook()) {\n                ...\n            }\n\n\t\t\t  //消息发送请求体构造\n            SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n            requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());\n            requestHeader.setTopic(msg.getTopic());\n            requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey());\n            requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums());\n            requestHeader.setQueueId(mq.getQueueId());\n            requestHeader.setSysFlag(sysFlag);\n            requestHeader.setBornTimestamp(System.currentTimeMillis());\n            requestHeader.setFlag(msg.getFlag());\n            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));\n            requestHeader.setReconsumeTimes(0);\n            requestHeader.setUnitMode(this.isUnitMode());\n            if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);\n                if (reconsumeTimes != null) {\n                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));\n                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);\n                }\n\n                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);\n                if (maxReconsumeTimes != null) {\n                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));\n                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);\n                }\n            }\n\n            SendResult sendResult = null;\n            switch (communicationMode) {\n                case ASYNC:\n                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(//\n                            brokerAddr, // 1\n                            mq.getBrokerName(), // 2\n                            msg, // 3\n                            requestHeader, // 4\n                            timeout, // 5\n                            communicationMode, // 6\n                            sendCallback, // 7\n                            topicPublishInfo, // 8\n                            this.mQClientFactory, // 9\n                            this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), // 10\n                            context, //\n                            this);\n                    break;\n                case ONEWAY:\n                case SYNC://同步发送模式\n                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(//\n                            brokerAddr, // 1\n                            mq.getBrokerName(), // 2\n                            msg, // 3\n                            requestHeader, // 4\n                            timeout, // 5\n                            communicationMode, // 6\n                            context,//\n                            this);\n                    break;\n                default:\n                    assert false;\n                    break;\n            }\n\n            if (this.hasSendMessageHook()) {\n                context.setSendResult(sendResult);\n                this.executeSendMessageHookAfter(context);\n            }\n\n            return sendResult;\n        \n        ...\n}\n```\n\n同步发送模式，最终会调到MQClientAPIImpl的如下方法：  \n\n```\nprivate SendResult sendMessageSync(//\n                                   final String addr, //\n                                   final String brokerName, //\n                                   final Message msg, //\n                                   final long timeoutMillis, //\n                                   final RemotingCommand request//\n) throws RemotingException, MQBrokerException, InterruptedException {\n    RemotingCommand response = this.remotingClient.invokeSync(addr, request, timeoutMillis);\n    assert response != null;\n    return this.processSendResponse(brokerName, msg, response);\n}\n```\n\n会调用RemotingClient.invokeSync发送同步消息。此处的RemotingClient是NettyRemotingClient，封装了Netty通信逻辑。\n\n```\npublic RemotingCommand invokeSync(String addr, final RemotingCommand request, long timeoutMillis)\n            throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException {\n    final Channel channel = this.getAndCreateChannel(addr);\n    if (channel != null && channel.isActive()) {\n        try {\n            if (this.rpcHook != null) {\n                this.rpcHook.doBeforeRequest(addr, request);\n            }\n            RemotingCommand response = this.invokeSyncImpl(channel, request, timeoutMillis);\n            if (this.rpcHook != null) {\n                this.rpcHook.doAfterResponse(RemotingHelper.parseChannelRemoteAddr(channel), request, response);\n            }\n            return response;\n            \n            ...\n}\n\npublic RemotingCommand invokeSyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis)\n        throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException {\n    final int opaque = request.getOpaque();\n\n    try {\n        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, null, null);\n        this.responseTable.put(opaque, responseFuture);\n        final SocketAddress addr = channel.remoteAddress();\n        \n        //添加监听器\n        channel.writeAndFlush(request).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture f) throws Exception {\n                if (f.isSuccess()) {\n                    responseFuture.setSendRequestOK(true);\n                    return;\n                } else {\n                    responseFuture.setSendRequestOK(false);\n                }\n\n                responseTable.remove(opaque);\n                responseFuture.setCause(f.cause());\n                responseFuture.putResponse(null);\n                plog.warn(\"send a request command to channel <\" + addr + \"> failed.\");\n            }\n        });\n\n\t\t //线程阻塞等待，获取发送消息的结果\n        RemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);\n        if (null == responseCommand) {\n            if (responseFuture.isSendRequestOK()) {\n                throw new RemotingTimeoutException(RemotingHelper.parseSocketAddressAddr(addr), timeoutMillis,\n                        responseFuture.getCause());\n            } else {\n                throw new RemotingSendRequestException(RemotingHelper.parseSocketAddressAddr(addr), responseFuture.getCause());\n            }\n        }\n\n        return responseCommand;\n    } finally {\n        this.responseTable.remove(opaque);\n    }\n}            \n\n```\n\nNettyRemotingAbstract.invokeSyncImpl这里才是真正发送消息的逻辑，底层使用Netty通信。关于netty，我们知道在Netty中所有的IO操作都是异步的，因此，你不能立刻得知消息是否被正确处理，但是我们可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFuture,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。总之，所有的操作都会返回一个ChannelFuture。\n\n这里为channelFuture配置了ChannelFutureListener监听器，监听channel的操作结果。如果消息发送成功，则设置ResponseFuture中SendRequestOK为true，return。否则设置为false，并且设置responseFuture中的responseCommand为null。\n\n在设置了监听器之后，线程会阻塞等待：\n\n```\nRemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);\n\n---\n\nthis.countDownLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);\nreturn this.responseCommand;\n```\n\n达到了最大等待时间之后，返回responseCommand。如果为null，则抛出消息发送超时或者其他异常。\n\n# 3 参考资料  \n- [消息队列三种发送方式](http://jm.taobao.org/2016/07/21/3-ways-to-send-message/)\n\n\n\n\n\n\n\n\n\n\n  \n","source":"_posts/RocketMQ源码学习之二-同步消息发送.md","raw":"---\ntitle: RocketMQ源码学习之二-同步消息发送\ndate: 2016-11-12 20:52:32\ntags: RocketMQ\n---\n\n本文讲述RocketMQ同步发送消息的原理。\n\n# 1 消息生产者demo  \n先看一段同步发送消息的demo代码：  \n\n```\nimport com.alibaba.rocketmq.client.exception.MQClientException;\nimport com.alibaba.rocketmq.client.producer.DefaultMQProducer;\nimport com.alibaba.rocketmq.client.producer.SendResult;\nimport com.alibaba.rocketmq.common.message.Message;\n\npublic class Producer1 {\n  public static void main(String[] args) throws MQClientException, InterruptedException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\");\n    producer.setNamesrvAddr(\"192.168.2.101:9876\");\n    producer.setInstanceName(\"Producer1\");\n    producer.start();\n    for (int i = 0; i < 1; i++)\n      try {\n        {\n          Message msg = new Message(\"TopicTest\",// topic\n                                    \"TagA\",// tag\n                                    \"OrderID188\",// key\n                                    (\"Hello MetaQ\").getBytes());// body\n          SendResult sendResult = producer.send(msg);\n          System.out.println(sendResult);\n        }\n\n      }\n      catch (Exception e) {\n        e.printStackTrace();\n      }\n\n    producer.shutdown();\n  }\n}\n\n```\n\n<!-- more -->\n\n运行结果：\n\n```\nlog4j:WARN No appenders could be found for logger (com.alibaba.rocketmq.shade.io.netty.util.internal.logging.InternalLoggerFactory).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.\nSendResult [sendStatus=SEND_OK, msgId=C0A8026507741218025C3A983E8F0000,offsetMsgId=C0A8026500002A9F0000000000001A0C, messageQueue=MessageQueue [topic=TopicTest, brokerName=xiajuns-MacBook-Pro.local, queueId=1], queueOffset=0]\n\nProcess finished with exit code 0\n```\n\n# 2 同步消息发送原理分析  \nRocketMQ网络部署图：  \n![RocketMQ网络部署图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-1.jpeg)\n\n原理：同步发送是指消息发送方发出数据后，会在收到接收方发回响应之后才发下一个数据包的通讯方式。\n\n![同步消息发送原理示意图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-2-1.png)\n\n应用场景：此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。\n\nRocketMQ发送同步消息的整体序列图如下：  \n![RocketMQ同步消息发送整体序列图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-2.jpg)\n\n下面进行具体分析。  \n\n## 2.1 发送消息前  \n同步消息发送的入口函数是DefaultMQProducer.send(Message msg).  \n发送消息之前需要完成如下事情：   \n\n- 创建DefaultMQProducer实例  \n其实就是指定group名字，以及创建了DefaultMQProducerImpl实例。发送晓得具体操作都是在DefaultMQProducerImpl中完成的，DefaultMQProducer只是做了一层封装。  \n- 给DefaultMQProducer实例设置nameserver地址  \n- 启动生产者  \n启动过程较复杂，下面详细分析。  \n首先判断服务状态，如果正在运行或者启动失败、已关闭，则抛出异常。否则执行下面的启动流程。  \n\n```\n//初始化服务状态为启动失败\nthis.serviceState = ServiceState.START_FAILED;\n\n//检查配置，主要是ProducerGroup\nthis.checkConfig();\n\nif (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) {\n    this.defaultMQProducer.changeInstanceNameToPID();\n}\n\n//创建MQClientInstance实例（MQClientInstance是MQ客户端实例，负责执行一些定时任务比如定时更新nameserver地址、从nameserver更新topic路由信息、向broker发送心跳等等。\n//MQClientManager负责创建MQClientInstance，每个clientId只创建一个，第一次创建完成之后存放在一个ConcurrentHashMap中）\nthis.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);\n\n//注册Producer。实际就是将group名、Producer键值对存到producerTable ConcurrentHashMap里\nboolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);\nif (!registerOK) {\n    this.serviceState = ServiceState.CREATE_JUST;\n    throw new MQClientException(\"The producer group[\" + this.defaultMQProducer.getProducerGroup()\n            + \"] has been created before, specify another name please.\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),\n            null);\n}\n\n//存储TopicPublishInfo\nthis.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());\n\n//启动MQClientInstance（startFactory默认是true）\nif (startFactory) {\n    mQClientFactory.start();\n}\n\nlog.info(\"the producer [{}] start OK. sendMessageWithVIPChannel={}\", this.defaultMQProducer.getProducerGroup(),\n        this.defaultMQProducer.isSendMessageWithVIPChannel());\n        \n//更改服务状态\nthis.serviceState = ServiceState.RUNNING;\n```\n\n## 2.2 发送消息  \n序列图：  \n![同步消息发送具体步骤](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-3.jpg)\n\n单步跟进，发现DefaultMQProducer.send(Message msg)会最终调到DefaultMQProducerImpl的这个方法：\n\n```\npublic SendResult send(Message msg, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n    return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);\n}\n```\n\n可以看到调sendDefaultImpl传递的CommunicationMode是SYNC，是同步模式：  \n\n```\n//三种消息模式枚举类型\npublic enum CommunicationMode {\n//同步\nSYNC,\n//异步\nASYNC,\n//单向\nONEWAY,\n}\n```\n\n接下来调到sendKernelImpl方法，下面摘取重要的部分：  \n\n```\nprivate SendResult sendKernelImpl(final Message msg, //\n                                  final MessageQueue mq, //\n                                  final CommunicationMode communicationMode, //\n                                  final SendCallback sendCallback, //\n                                  final TopicPublishInfo topicPublishInfo, //\n                                  final long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n    //获取broker地址\n    String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());\n    if (null == brokerAddr) {\n        tryToFindTopicPublishInfo(mq.getTopic());\n        brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());\n    }\n\n    SendMessageContext context = null;\n    if (brokerAddr != null) {\n        brokerAddr = MixAll.brokerVIPChannel(this.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);\n\n        byte[] prevBody = msg.getBody();\n        try {\n\t\t\t  //消息ID生成\n            MessageClientIDSetter.setUniqID(msg);\n\n            int sysFlag = 0;\n            if (this.tryToCompressMessage(msg)) {\n                sysFlag |= MessageSysFlag.CompressedFlag;\n            }\n\n            final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n            if (tranMsg != null && Boolean.parseBoolean(tranMsg)) {\n                sysFlag |= MessageSysFlag.TransactionPreparedType;\n            }\n\n\t\t\t  //一些钩子函数执行\n            if (hasCheckForbiddenHook()) {\n                ...\n            }\n\n            if (this.hasSendMessageHook()) {\n                ...\n            }\n\n\t\t\t  //消息发送请求体构造\n            SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n            requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());\n            requestHeader.setTopic(msg.getTopic());\n            requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey());\n            requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums());\n            requestHeader.setQueueId(mq.getQueueId());\n            requestHeader.setSysFlag(sysFlag);\n            requestHeader.setBornTimestamp(System.currentTimeMillis());\n            requestHeader.setFlag(msg.getFlag());\n            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));\n            requestHeader.setReconsumeTimes(0);\n            requestHeader.setUnitMode(this.isUnitMode());\n            if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);\n                if (reconsumeTimes != null) {\n                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));\n                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);\n                }\n\n                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);\n                if (maxReconsumeTimes != null) {\n                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));\n                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);\n                }\n            }\n\n            SendResult sendResult = null;\n            switch (communicationMode) {\n                case ASYNC:\n                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(//\n                            brokerAddr, // 1\n                            mq.getBrokerName(), // 2\n                            msg, // 3\n                            requestHeader, // 4\n                            timeout, // 5\n                            communicationMode, // 6\n                            sendCallback, // 7\n                            topicPublishInfo, // 8\n                            this.mQClientFactory, // 9\n                            this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), // 10\n                            context, //\n                            this);\n                    break;\n                case ONEWAY:\n                case SYNC://同步发送模式\n                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(//\n                            brokerAddr, // 1\n                            mq.getBrokerName(), // 2\n                            msg, // 3\n                            requestHeader, // 4\n                            timeout, // 5\n                            communicationMode, // 6\n                            context,//\n                            this);\n                    break;\n                default:\n                    assert false;\n                    break;\n            }\n\n            if (this.hasSendMessageHook()) {\n                context.setSendResult(sendResult);\n                this.executeSendMessageHookAfter(context);\n            }\n\n            return sendResult;\n        \n        ...\n}\n```\n\n同步发送模式，最终会调到MQClientAPIImpl的如下方法：  \n\n```\nprivate SendResult sendMessageSync(//\n                                   final String addr, //\n                                   final String brokerName, //\n                                   final Message msg, //\n                                   final long timeoutMillis, //\n                                   final RemotingCommand request//\n) throws RemotingException, MQBrokerException, InterruptedException {\n    RemotingCommand response = this.remotingClient.invokeSync(addr, request, timeoutMillis);\n    assert response != null;\n    return this.processSendResponse(brokerName, msg, response);\n}\n```\n\n会调用RemotingClient.invokeSync发送同步消息。此处的RemotingClient是NettyRemotingClient，封装了Netty通信逻辑。\n\n```\npublic RemotingCommand invokeSync(String addr, final RemotingCommand request, long timeoutMillis)\n            throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException {\n    final Channel channel = this.getAndCreateChannel(addr);\n    if (channel != null && channel.isActive()) {\n        try {\n            if (this.rpcHook != null) {\n                this.rpcHook.doBeforeRequest(addr, request);\n            }\n            RemotingCommand response = this.invokeSyncImpl(channel, request, timeoutMillis);\n            if (this.rpcHook != null) {\n                this.rpcHook.doAfterResponse(RemotingHelper.parseChannelRemoteAddr(channel), request, response);\n            }\n            return response;\n            \n            ...\n}\n\npublic RemotingCommand invokeSyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis)\n        throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException {\n    final int opaque = request.getOpaque();\n\n    try {\n        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, null, null);\n        this.responseTable.put(opaque, responseFuture);\n        final SocketAddress addr = channel.remoteAddress();\n        \n        //添加监听器\n        channel.writeAndFlush(request).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture f) throws Exception {\n                if (f.isSuccess()) {\n                    responseFuture.setSendRequestOK(true);\n                    return;\n                } else {\n                    responseFuture.setSendRequestOK(false);\n                }\n\n                responseTable.remove(opaque);\n                responseFuture.setCause(f.cause());\n                responseFuture.putResponse(null);\n                plog.warn(\"send a request command to channel <\" + addr + \"> failed.\");\n            }\n        });\n\n\t\t //线程阻塞等待，获取发送消息的结果\n        RemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);\n        if (null == responseCommand) {\n            if (responseFuture.isSendRequestOK()) {\n                throw new RemotingTimeoutException(RemotingHelper.parseSocketAddressAddr(addr), timeoutMillis,\n                        responseFuture.getCause());\n            } else {\n                throw new RemotingSendRequestException(RemotingHelper.parseSocketAddressAddr(addr), responseFuture.getCause());\n            }\n        }\n\n        return responseCommand;\n    } finally {\n        this.responseTable.remove(opaque);\n    }\n}            \n\n```\n\nNettyRemotingAbstract.invokeSyncImpl这里才是真正发送消息的逻辑，底层使用Netty通信。关于netty，我们知道在Netty中所有的IO操作都是异步的，因此，你不能立刻得知消息是否被正确处理，但是我们可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFuture,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。总之，所有的操作都会返回一个ChannelFuture。\n\n这里为channelFuture配置了ChannelFutureListener监听器，监听channel的操作结果。如果消息发送成功，则设置ResponseFuture中SendRequestOK为true，return。否则设置为false，并且设置responseFuture中的responseCommand为null。\n\n在设置了监听器之后，线程会阻塞等待：\n\n```\nRemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);\n\n---\n\nthis.countDownLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);\nreturn this.responseCommand;\n```\n\n达到了最大等待时间之后，返回responseCommand。如果为null，则抛出消息发送超时或者其他异常。\n\n# 3 参考资料  \n- [消息队列三种发送方式](http://jm.taobao.org/2016/07/21/3-ways-to-send-message/)\n\n\n\n\n\n\n\n\n\n\n  \n","slug":"RocketMQ源码学习之二-同步消息发送","published":1,"updated":"2016-11-16T03:34:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsby000g2hwf6ax2zvr8","content":"<p>本文讲述RocketMQ同步发送消息的原理。</p>\n<h1 id=\"1-消息生产者demo\"><a href=\"#1-消息生产者demo\" class=\"headerlink\" title=\"1 消息生产者demo\"></a>1 消息生产者demo</h1><p>先看一段同步发送消息的demo代码：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">import com.alibaba.rocketmq.client.exception.MQClientException;</div><div class=\"line\">import com.alibaba.rocketmq.client.producer.DefaultMQProducer;</div><div class=\"line\">import com.alibaba.rocketmq.client.producer.SendResult;</div><div class=\"line\">import com.alibaba.rocketmq.common.message.Message;</div><div class=\"line\"></div><div class=\"line\">public class Producer1 &#123;</div><div class=\"line\">  public static void main(String[] args) throws MQClientException, InterruptedException &#123;</div><div class=\"line\">    DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;);</div><div class=\"line\">    producer.setNamesrvAddr(&quot;192.168.2.101:9876&quot;);</div><div class=\"line\">    producer.setInstanceName(&quot;Producer1&quot;);</div><div class=\"line\">    producer.start();</div><div class=\"line\">    for (int i = 0; i &lt; 1; i++)</div><div class=\"line\">      try &#123;</div><div class=\"line\">        &#123;</div><div class=\"line\">          Message msg = new Message(&quot;TopicTest&quot;,// topic</div><div class=\"line\">                                    &quot;TagA&quot;,// tag</div><div class=\"line\">                                    &quot;OrderID188&quot;,// key</div><div class=\"line\">                                    (&quot;Hello MetaQ&quot;).getBytes());// body</div><div class=\"line\">          SendResult sendResult = producer.send(msg);</div><div class=\"line\">          System.out.println(sendResult);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">      &#125;</div><div class=\"line\">      catch (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    producer.shutdown();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">log4j:WARN No appenders could be found for logger (com.alibaba.rocketmq.shade.io.netty.util.internal.logging.InternalLoggerFactory).</div><div class=\"line\">log4j:WARN Please initialize the log4j system properly.</div><div class=\"line\">log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</div><div class=\"line\">SendResult [sendStatus=SEND_OK, msgId=C0A8026507741218025C3A983E8F0000,offsetMsgId=C0A8026500002A9F0000000000001A0C, messageQueue=MessageQueue [topic=TopicTest, brokerName=xiajuns-MacBook-Pro.local, queueId=1], queueOffset=0]</div><div class=\"line\"></div><div class=\"line\">Process finished with exit code 0</div></pre></td></tr></table></figure>\n<h1 id=\"2-同步消息发送原理分析\"><a href=\"#2-同步消息发送原理分析\" class=\"headerlink\" title=\"2 同步消息发送原理分析\"></a>2 同步消息发送原理分析</h1><p>RocketMQ网络部署图：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-1.jpeg\" alt=\"RocketMQ网络部署图\"></p>\n<p>原理：同步发送是指消息发送方发出数据后，会在收到接收方发回响应之后才发下一个数据包的通讯方式。</p>\n<p><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-2-1.png\" alt=\"同步消息发送原理示意图\"></p>\n<p>应用场景：此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。</p>\n<p>RocketMQ发送同步消息的整体序列图如下：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-2.jpg\" alt=\"RocketMQ同步消息发送整体序列图\"></p>\n<p>下面进行具体分析。  </p>\n<h2 id=\"2-1-发送消息前\"><a href=\"#2-1-发送消息前\" class=\"headerlink\" title=\"2.1 发送消息前\"></a>2.1 发送消息前</h2><p>同步消息发送的入口函数是DefaultMQProducer.send(Message msg).<br>发送消息之前需要完成如下事情：   </p>\n<ul>\n<li>创建DefaultMQProducer实例<br>其实就是指定group名字，以及创建了DefaultMQProducerImpl实例。发送晓得具体操作都是在DefaultMQProducerImpl中完成的，DefaultMQProducer只是做了一层封装。  </li>\n<li>给DefaultMQProducer实例设置nameserver地址  </li>\n<li>启动生产者<br>启动过程较复杂，下面详细分析。<br>首先判断服务状态，如果正在运行或者启动失败、已关闭，则抛出异常。否则执行下面的启动流程。  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化服务状态为启动失败</div><div class=\"line\">this.serviceState = ServiceState.START_FAILED;</div><div class=\"line\"></div><div class=\"line\">//检查配置，主要是ProducerGroup</div><div class=\"line\">this.checkConfig();</div><div class=\"line\"></div><div class=\"line\">if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</div><div class=\"line\">    this.defaultMQProducer.changeInstanceNameToPID();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建MQClientInstance实例（MQClientInstance是MQ客户端实例，负责执行一些定时任务比如定时更新nameserver地址、从nameserver更新topic路由信息、向broker发送心跳等等。</div><div class=\"line\">//MQClientManager负责创建MQClientInstance，每个clientId只创建一个，第一次创建完成之后存放在一个ConcurrentHashMap中）</div><div class=\"line\">this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);</div><div class=\"line\"></div><div class=\"line\">//注册Producer。实际就是将group名、Producer键值对存到producerTable ConcurrentHashMap里</div><div class=\"line\">boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);</div><div class=\"line\">if (!registerOK) &#123;</div><div class=\"line\">    this.serviceState = ServiceState.CREATE_JUST;</div><div class=\"line\">    throw new MQClientException(&quot;The producer group[&quot; + this.defaultMQProducer.getProducerGroup()</div><div class=\"line\">            + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</div><div class=\"line\">            null);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//存储TopicPublishInfo</div><div class=\"line\">this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());</div><div class=\"line\"></div><div class=\"line\">//启动MQClientInstance（startFactory默认是true）</div><div class=\"line\">if (startFactory) &#123;</div><div class=\"line\">    mQClientFactory.start();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">log.info(&quot;the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;&quot;, this.defaultMQProducer.getProducerGroup(),</div><div class=\"line\">        this.defaultMQProducer.isSendMessageWithVIPChannel());</div><div class=\"line\">        </div><div class=\"line\">//更改服务状态</div><div class=\"line\">this.serviceState = ServiceState.RUNNING;</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-发送消息\"><a href=\"#2-2-发送消息\" class=\"headerlink\" title=\"2.2 发送消息\"></a>2.2 发送消息</h2><p>序列图：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-3.jpg\" alt=\"同步消息发送具体步骤\"></p>\n<p>单步跟进，发现DefaultMQProducer.send(Message msg)会最终调到DefaultMQProducerImpl的这个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public SendResult send(Message msg, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\">    return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到调sendDefaultImpl传递的CommunicationMode是SYNC，是同步模式：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//三种消息模式枚举类型</div><div class=\"line\">public enum CommunicationMode &#123;</div><div class=\"line\">//同步</div><div class=\"line\">SYNC,</div><div class=\"line\">//异步</div><div class=\"line\">ASYNC,</div><div class=\"line\">//单向</div><div class=\"line\">ONEWAY,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来调到sendKernelImpl方法，下面摘取重要的部分：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">private SendResult sendKernelImpl(final Message msg, //</div><div class=\"line\">                                  final MessageQueue mq, //</div><div class=\"line\">                                  final CommunicationMode communicationMode, //</div><div class=\"line\">                                  final SendCallback sendCallback, //</div><div class=\"line\">                                  final TopicPublishInfo topicPublishInfo, //</div><div class=\"line\">                                  final long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\">    //获取broker地址</div><div class=\"line\">    String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class=\"line\">    if (null == brokerAddr) &#123;</div><div class=\"line\">        tryToFindTopicPublishInfo(mq.getTopic());</div><div class=\"line\">        brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SendMessageContext context = null;</div><div class=\"line\">    if (brokerAddr != null) &#123;</div><div class=\"line\">        brokerAddr = MixAll.brokerVIPChannel(this.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</div><div class=\"line\"></div><div class=\"line\">        byte[] prevBody = msg.getBody();</div><div class=\"line\">        try &#123;</div><div class=\"line\">\t\t\t  //消息ID生成</div><div class=\"line\">            MessageClientIDSetter.setUniqID(msg);</div><div class=\"line\"></div><div class=\"line\">            int sysFlag = 0;</div><div class=\"line\">            if (this.tryToCompressMessage(msg)) &#123;</div><div class=\"line\">                sysFlag |= MessageSysFlag.CompressedFlag;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class=\"line\">            if (tranMsg != null &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</div><div class=\"line\">                sysFlag |= MessageSysFlag.TransactionPreparedType;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t  //一些钩子函数执行</div><div class=\"line\">            if (hasCheckForbiddenHook()) &#123;</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (this.hasSendMessageHook()) &#123;</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t  //消息发送请求体构造</div><div class=\"line\">            SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();</div><div class=\"line\">            requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());</div><div class=\"line\">            requestHeader.setTopic(msg.getTopic());</div><div class=\"line\">            requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey());</div><div class=\"line\">            requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums());</div><div class=\"line\">            requestHeader.setQueueId(mq.getQueueId());</div><div class=\"line\">            requestHeader.setSysFlag(sysFlag);</div><div class=\"line\">            requestHeader.setBornTimestamp(System.currentTimeMillis());</div><div class=\"line\">            requestHeader.setFlag(msg.getFlag());</div><div class=\"line\">            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class=\"line\">            requestHeader.setReconsumeTimes(0);</div><div class=\"line\">            requestHeader.setUnitMode(this.isUnitMode());</div><div class=\"line\">            if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\">                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</div><div class=\"line\">                if (reconsumeTimes != null) &#123;</div><div class=\"line\">                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</div><div class=\"line\">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</div><div class=\"line\">                if (maxReconsumeTimes != null) &#123;</div><div class=\"line\">                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</div><div class=\"line\">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            SendResult sendResult = null;</div><div class=\"line\">            switch (communicationMode) &#123;</div><div class=\"line\">                case ASYNC:</div><div class=\"line\">                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(//</div><div class=\"line\">                            brokerAddr, // 1</div><div class=\"line\">                            mq.getBrokerName(), // 2</div><div class=\"line\">                            msg, // 3</div><div class=\"line\">                            requestHeader, // 4</div><div class=\"line\">                            timeout, // 5</div><div class=\"line\">                            communicationMode, // 6</div><div class=\"line\">                            sendCallback, // 7</div><div class=\"line\">                            topicPublishInfo, // 8</div><div class=\"line\">                            this.mQClientFactory, // 9</div><div class=\"line\">                            this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), // 10</div><div class=\"line\">                            context, //</div><div class=\"line\">                            this);</div><div class=\"line\">                    break;</div><div class=\"line\">                case ONEWAY:</div><div class=\"line\">                case SYNC://同步发送模式</div><div class=\"line\">                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(//</div><div class=\"line\">                            brokerAddr, // 1</div><div class=\"line\">                            mq.getBrokerName(), // 2</div><div class=\"line\">                            msg, // 3</div><div class=\"line\">                            requestHeader, // 4</div><div class=\"line\">                            timeout, // 5</div><div class=\"line\">                            communicationMode, // 6</div><div class=\"line\">                            context,//</div><div class=\"line\">                            this);</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                    assert false;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (this.hasSendMessageHook()) &#123;</div><div class=\"line\">                context.setSendResult(sendResult);</div><div class=\"line\">                this.executeSendMessageHookAfter(context);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return sendResult;</div><div class=\"line\">        </div><div class=\"line\">        ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同步发送模式，最终会调到MQClientAPIImpl的如下方法：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">private SendResult sendMessageSync(//</div><div class=\"line\">                                   final String addr, //</div><div class=\"line\">                                   final String brokerName, //</div><div class=\"line\">                                   final Message msg, //</div><div class=\"line\">                                   final long timeoutMillis, //</div><div class=\"line\">                                   final RemotingCommand request//</div><div class=\"line\">) throws RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\">    RemotingCommand response = this.remotingClient.invokeSync(addr, request, timeoutMillis);</div><div class=\"line\">    assert response != null;</div><div class=\"line\">    return this.processSendResponse(brokerName, msg, response);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>会调用RemotingClient.invokeSync发送同步消息。此处的RemotingClient是NettyRemotingClient，封装了Netty通信逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">public RemotingCommand invokeSync(String addr, final RemotingCommand request, long timeoutMillis)</div><div class=\"line\">            throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException &#123;</div><div class=\"line\">    final Channel channel = this.getAndCreateChannel(addr);</div><div class=\"line\">    if (channel != null &amp;&amp; channel.isActive()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            if (this.rpcHook != null) &#123;</div><div class=\"line\">                this.rpcHook.doBeforeRequest(addr, request);</div><div class=\"line\">            &#125;</div><div class=\"line\">            RemotingCommand response = this.invokeSyncImpl(channel, request, timeoutMillis);</div><div class=\"line\">            if (this.rpcHook != null) &#123;</div><div class=\"line\">                this.rpcHook.doAfterResponse(RemotingHelper.parseChannelRemoteAddr(channel), request, response);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return response;</div><div class=\"line\">            </div><div class=\"line\">            ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public RemotingCommand invokeSyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis)</div><div class=\"line\">        throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException &#123;</div><div class=\"line\">    final int opaque = request.getOpaque();</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, null, null);</div><div class=\"line\">        this.responseTable.put(opaque, responseFuture);</div><div class=\"line\">        final SocketAddress addr = channel.remoteAddress();</div><div class=\"line\">        </div><div class=\"line\">        //添加监听器</div><div class=\"line\">        channel.writeAndFlush(request).addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void operationComplete(ChannelFuture f) throws Exception &#123;</div><div class=\"line\">                if (f.isSuccess()) &#123;</div><div class=\"line\">                    responseFuture.setSendRequestOK(true);</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    responseFuture.setSendRequestOK(false);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                responseTable.remove(opaque);</div><div class=\"line\">                responseFuture.setCause(f.cause());</div><div class=\"line\">                responseFuture.putResponse(null);</div><div class=\"line\">                plog.warn(&quot;send a request command to channel &lt;&quot; + addr + &quot;&gt; failed.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">\t\t //线程阻塞等待，获取发送消息的结果</div><div class=\"line\">        RemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);</div><div class=\"line\">        if (null == responseCommand) &#123;</div><div class=\"line\">            if (responseFuture.isSendRequestOK()) &#123;</div><div class=\"line\">                throw new RemotingTimeoutException(RemotingHelper.parseSocketAddressAddr(addr), timeoutMillis,</div><div class=\"line\">                        responseFuture.getCause());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                throw new RemotingSendRequestException(RemotingHelper.parseSocketAddressAddr(addr), responseFuture.getCause());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return responseCommand;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        this.responseTable.remove(opaque);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>NettyRemotingAbstract.invokeSyncImpl这里才是真正发送消息的逻辑，底层使用Netty通信。关于netty，我们知道在Netty中所有的IO操作都是异步的，因此，你不能立刻得知消息是否被正确处理，但是我们可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFuture,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。总之，所有的操作都会返回一个ChannelFuture。</p>\n<p>这里为channelFuture配置了ChannelFutureListener监听器，监听channel的操作结果。如果消息发送成功，则设置ResponseFuture中SendRequestOK为true，return。否则设置为false，并且设置responseFuture中的responseCommand为null。</p>\n<p>在设置了监听器之后，线程会阻塞等待：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">RemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">this.countDownLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);</div><div class=\"line\">return this.responseCommand;</div></pre></td></tr></table></figure>\n<p>达到了最大等待时间之后，返回responseCommand。如果为null，则抛出消息发送超时或者其他异常。</p>\n<h1 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3 参考资料\"></a>3 参考资料</h1><ul>\n<li><a href=\"http://jm.taobao.org/2016/07/21/3-ways-to-send-message/\" target=\"_blank\" rel=\"external\">消息队列三种发送方式</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/11/12/RocketMQ源码学习之二-同步消息发送/\">http://xiajunhust.github.io/2016/11/12/RocketMQ源码学习之二-同步消息发送/</a></p>\n","excerpt":"<p>本文讲述RocketMQ同步发送消息的原理。</p>\n<h1 id=\"1-消息生产者demo\"><a href=\"#1-消息生产者demo\" class=\"headerlink\" title=\"1 消息生产者demo\"></a>1 消息生产者demo</h1><p>先看一段同步发送消息的demo代码：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">import com.alibaba.rocketmq.client.exception.MQClientException;</div><div class=\"line\">import com.alibaba.rocketmq.client.producer.DefaultMQProducer;</div><div class=\"line\">import com.alibaba.rocketmq.client.producer.SendResult;</div><div class=\"line\">import com.alibaba.rocketmq.common.message.Message;</div><div class=\"line\"></div><div class=\"line\">public class Producer1 &#123;</div><div class=\"line\">  public static void main(String[] args) throws MQClientException, InterruptedException &#123;</div><div class=\"line\">    DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;);</div><div class=\"line\">    producer.setNamesrvAddr(&quot;192.168.2.101:9876&quot;);</div><div class=\"line\">    producer.setInstanceName(&quot;Producer1&quot;);</div><div class=\"line\">    producer.start();</div><div class=\"line\">    for (int i = 0; i &lt; 1; i++)</div><div class=\"line\">      try &#123;</div><div class=\"line\">        &#123;</div><div class=\"line\">          Message msg = new Message(&quot;TopicTest&quot;,// topic</div><div class=\"line\">                                    &quot;TagA&quot;,// tag</div><div class=\"line\">                                    &quot;OrderID188&quot;,// key</div><div class=\"line\">                                    (&quot;Hello MetaQ&quot;).getBytes());// body</div><div class=\"line\">          SendResult sendResult = producer.send(msg);</div><div class=\"line\">          System.out.println(sendResult);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">      &#125;</div><div class=\"line\">      catch (Exception e) &#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    producer.shutdown();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">log4j:WARN No appenders could be found for logger (com.alibaba.rocketmq.shade.io.netty.util.internal.logging.InternalLoggerFactory).</div><div class=\"line\">log4j:WARN Please initialize the log4j system properly.</div><div class=\"line\">log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</div><div class=\"line\">SendResult [sendStatus=SEND_OK, msgId=C0A8026507741218025C3A983E8F0000,offsetMsgId=C0A8026500002A9F0000000000001A0C, messageQueue=MessageQueue [topic=TopicTest, brokerName=xiajuns-MacBook-Pro.local, queueId=1], queueOffset=0]</div><div class=\"line\"></div><div class=\"line\">Process finished with exit code 0</div></pre></td></tr></table></figure>\n<h1 id=\"2-同步消息发送原理分析\"><a href=\"#2-同步消息发送原理分析\" class=\"headerlink\" title=\"2 同步消息发送原理分析\"></a>2 同步消息发送原理分析</h1><p>RocketMQ网络部署图：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-1.jpeg\" alt=\"RocketMQ网络部署图\"></p>\n<p>原理：同步发送是指消息发送方发出数据后，会在收到接收方发回响应之后才发下一个数据包的通讯方式。</p>\n<p><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-2-1.png\" alt=\"同步消息发送原理示意图\"></p>\n<p>应用场景：此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。</p>\n<p>RocketMQ发送同步消息的整体序列图如下：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-2.jpg\" alt=\"RocketMQ同步消息发送整体序列图\"></p>\n<p>下面进行具体分析。  </p>\n<h2 id=\"2-1-发送消息前\"><a href=\"#2-1-发送消息前\" class=\"headerlink\" title=\"2.1 发送消息前\"></a>2.1 发送消息前</h2><p>同步消息发送的入口函数是DefaultMQProducer.send(Message msg).<br>发送消息之前需要完成如下事情：   </p>\n<ul>\n<li>创建DefaultMQProducer实例<br>其实就是指定group名字，以及创建了DefaultMQProducerImpl实例。发送晓得具体操作都是在DefaultMQProducerImpl中完成的，DefaultMQProducer只是做了一层封装。  </li>\n<li>给DefaultMQProducer实例设置nameserver地址  </li>\n<li>启动生产者<br>启动过程较复杂，下面详细分析。<br>首先判断服务状态，如果正在运行或者启动失败、已关闭，则抛出异常。否则执行下面的启动流程。  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化服务状态为启动失败</div><div class=\"line\">this.serviceState = ServiceState.START_FAILED;</div><div class=\"line\"></div><div class=\"line\">//检查配置，主要是ProducerGroup</div><div class=\"line\">this.checkConfig();</div><div class=\"line\"></div><div class=\"line\">if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</div><div class=\"line\">    this.defaultMQProducer.changeInstanceNameToPID();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建MQClientInstance实例（MQClientInstance是MQ客户端实例，负责执行一些定时任务比如定时更新nameserver地址、从nameserver更新topic路由信息、向broker发送心跳等等。</div><div class=\"line\">//MQClientManager负责创建MQClientInstance，每个clientId只创建一个，第一次创建完成之后存放在一个ConcurrentHashMap中）</div><div class=\"line\">this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);</div><div class=\"line\"></div><div class=\"line\">//注册Producer。实际就是将group名、Producer键值对存到producerTable ConcurrentHashMap里</div><div class=\"line\">boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);</div><div class=\"line\">if (!registerOK) &#123;</div><div class=\"line\">    this.serviceState = ServiceState.CREATE_JUST;</div><div class=\"line\">    throw new MQClientException(&quot;The producer group[&quot; + this.defaultMQProducer.getProducerGroup()</div><div class=\"line\">            + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</div><div class=\"line\">            null);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//存储TopicPublishInfo</div><div class=\"line\">this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());</div><div class=\"line\"></div><div class=\"line\">//启动MQClientInstance（startFactory默认是true）</div><div class=\"line\">if (startFactory) &#123;</div><div class=\"line\">    mQClientFactory.start();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">log.info(&quot;the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;&quot;, this.defaultMQProducer.getProducerGroup(),</div><div class=\"line\">        this.defaultMQProducer.isSendMessageWithVIPChannel());</div><div class=\"line\">        </div><div class=\"line\">//更改服务状态</div><div class=\"line\">this.serviceState = ServiceState.RUNNING;</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-发送消息\"><a href=\"#2-2-发送消息\" class=\"headerlink\" title=\"2.2 发送消息\"></a>2.2 发送消息</h2><p>序列图：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-1-3.jpg\" alt=\"同步消息发送具体步骤\"></p>\n<p>单步跟进，发现DefaultMQProducer.send(Message msg)会最终调到DefaultMQProducerImpl的这个方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public SendResult send(Message msg, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\">    return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到调sendDefaultImpl传递的CommunicationMode是SYNC，是同步模式：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//三种消息模式枚举类型</div><div class=\"line\">public enum CommunicationMode &#123;</div><div class=\"line\">//同步</div><div class=\"line\">SYNC,</div><div class=\"line\">//异步</div><div class=\"line\">ASYNC,</div><div class=\"line\">//单向</div><div class=\"line\">ONEWAY,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来调到sendKernelImpl方法，下面摘取重要的部分：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">private SendResult sendKernelImpl(final Message msg, //</div><div class=\"line\">                                  final MessageQueue mq, //</div><div class=\"line\">                                  final CommunicationMode communicationMode, //</div><div class=\"line\">                                  final SendCallback sendCallback, //</div><div class=\"line\">                                  final TopicPublishInfo topicPublishInfo, //</div><div class=\"line\">                                  final long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\">    //获取broker地址</div><div class=\"line\">    String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class=\"line\">    if (null == brokerAddr) &#123;</div><div class=\"line\">        tryToFindTopicPublishInfo(mq.getTopic());</div><div class=\"line\">        brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    SendMessageContext context = null;</div><div class=\"line\">    if (brokerAddr != null) &#123;</div><div class=\"line\">        brokerAddr = MixAll.brokerVIPChannel(this.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</div><div class=\"line\"></div><div class=\"line\">        byte[] prevBody = msg.getBody();</div><div class=\"line\">        try &#123;</div><div class=\"line\">\t\t\t  //消息ID生成</div><div class=\"line\">            MessageClientIDSetter.setUniqID(msg);</div><div class=\"line\"></div><div class=\"line\">            int sysFlag = 0;</div><div class=\"line\">            if (this.tryToCompressMessage(msg)) &#123;</div><div class=\"line\">                sysFlag |= MessageSysFlag.CompressedFlag;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class=\"line\">            if (tranMsg != null &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</div><div class=\"line\">                sysFlag |= MessageSysFlag.TransactionPreparedType;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t  //一些钩子函数执行</div><div class=\"line\">            if (hasCheckForbiddenHook()) &#123;</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (this.hasSendMessageHook()) &#123;</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t  //消息发送请求体构造</div><div class=\"line\">            SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();</div><div class=\"line\">            requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());</div><div class=\"line\">            requestHeader.setTopic(msg.getTopic());</div><div class=\"line\">            requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey());</div><div class=\"line\">            requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums());</div><div class=\"line\">            requestHeader.setQueueId(mq.getQueueId());</div><div class=\"line\">            requestHeader.setSysFlag(sysFlag);</div><div class=\"line\">            requestHeader.setBornTimestamp(System.currentTimeMillis());</div><div class=\"line\">            requestHeader.setFlag(msg.getFlag());</div><div class=\"line\">            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class=\"line\">            requestHeader.setReconsumeTimes(0);</div><div class=\"line\">            requestHeader.setUnitMode(this.isUnitMode());</div><div class=\"line\">            if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\">                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</div><div class=\"line\">                if (reconsumeTimes != null) &#123;</div><div class=\"line\">                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</div><div class=\"line\">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</div><div class=\"line\">                if (maxReconsumeTimes != null) &#123;</div><div class=\"line\">                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</div><div class=\"line\">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            SendResult sendResult = null;</div><div class=\"line\">            switch (communicationMode) &#123;</div><div class=\"line\">                case ASYNC:</div><div class=\"line\">                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(//</div><div class=\"line\">                            brokerAddr, // 1</div><div class=\"line\">                            mq.getBrokerName(), // 2</div><div class=\"line\">                            msg, // 3</div><div class=\"line\">                            requestHeader, // 4</div><div class=\"line\">                            timeout, // 5</div><div class=\"line\">                            communicationMode, // 6</div><div class=\"line\">                            sendCallback, // 7</div><div class=\"line\">                            topicPublishInfo, // 8</div><div class=\"line\">                            this.mQClientFactory, // 9</div><div class=\"line\">                            this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), // 10</div><div class=\"line\">                            context, //</div><div class=\"line\">                            this);</div><div class=\"line\">                    break;</div><div class=\"line\">                case ONEWAY:</div><div class=\"line\">                case SYNC://同步发送模式</div><div class=\"line\">                    sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(//</div><div class=\"line\">                            brokerAddr, // 1</div><div class=\"line\">                            mq.getBrokerName(), // 2</div><div class=\"line\">                            msg, // 3</div><div class=\"line\">                            requestHeader, // 4</div><div class=\"line\">                            timeout, // 5</div><div class=\"line\">                            communicationMode, // 6</div><div class=\"line\">                            context,//</div><div class=\"line\">                            this);</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                    assert false;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (this.hasSendMessageHook()) &#123;</div><div class=\"line\">                context.setSendResult(sendResult);</div><div class=\"line\">                this.executeSendMessageHookAfter(context);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return sendResult;</div><div class=\"line\">        </div><div class=\"line\">        ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同步发送模式，最终会调到MQClientAPIImpl的如下方法：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">private SendResult sendMessageSync(//</div><div class=\"line\">                                   final String addr, //</div><div class=\"line\">                                   final String brokerName, //</div><div class=\"line\">                                   final Message msg, //</div><div class=\"line\">                                   final long timeoutMillis, //</div><div class=\"line\">                                   final RemotingCommand request//</div><div class=\"line\">) throws RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\">    RemotingCommand response = this.remotingClient.invokeSync(addr, request, timeoutMillis);</div><div class=\"line\">    assert response != null;</div><div class=\"line\">    return this.processSendResponse(brokerName, msg, response);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>会调用RemotingClient.invokeSync发送同步消息。此处的RemotingClient是NettyRemotingClient，封装了Netty通信逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">public RemotingCommand invokeSync(String addr, final RemotingCommand request, long timeoutMillis)</div><div class=\"line\">            throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException &#123;</div><div class=\"line\">    final Channel channel = this.getAndCreateChannel(addr);</div><div class=\"line\">    if (channel != null &amp;&amp; channel.isActive()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            if (this.rpcHook != null) &#123;</div><div class=\"line\">                this.rpcHook.doBeforeRequest(addr, request);</div><div class=\"line\">            &#125;</div><div class=\"line\">            RemotingCommand response = this.invokeSyncImpl(channel, request, timeoutMillis);</div><div class=\"line\">            if (this.rpcHook != null) &#123;</div><div class=\"line\">                this.rpcHook.doAfterResponse(RemotingHelper.parseChannelRemoteAddr(channel), request, response);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return response;</div><div class=\"line\">            </div><div class=\"line\">            ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public RemotingCommand invokeSyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis)</div><div class=\"line\">        throws InterruptedException, RemotingSendRequestException, RemotingTimeoutException &#123;</div><div class=\"line\">    final int opaque = request.getOpaque();</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, null, null);</div><div class=\"line\">        this.responseTable.put(opaque, responseFuture);</div><div class=\"line\">        final SocketAddress addr = channel.remoteAddress();</div><div class=\"line\">        </div><div class=\"line\">        //添加监听器</div><div class=\"line\">        channel.writeAndFlush(request).addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void operationComplete(ChannelFuture f) throws Exception &#123;</div><div class=\"line\">                if (f.isSuccess()) &#123;</div><div class=\"line\">                    responseFuture.setSendRequestOK(true);</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    responseFuture.setSendRequestOK(false);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                responseTable.remove(opaque);</div><div class=\"line\">                responseFuture.setCause(f.cause());</div><div class=\"line\">                responseFuture.putResponse(null);</div><div class=\"line\">                plog.warn(&quot;send a request command to channel &lt;&quot; + addr + &quot;&gt; failed.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\">\t\t //线程阻塞等待，获取发送消息的结果</div><div class=\"line\">        RemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);</div><div class=\"line\">        if (null == responseCommand) &#123;</div><div class=\"line\">            if (responseFuture.isSendRequestOK()) &#123;</div><div class=\"line\">                throw new RemotingTimeoutException(RemotingHelper.parseSocketAddressAddr(addr), timeoutMillis,</div><div class=\"line\">                        responseFuture.getCause());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                throw new RemotingSendRequestException(RemotingHelper.parseSocketAddressAddr(addr), responseFuture.getCause());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return responseCommand;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        this.responseTable.remove(opaque);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>NettyRemotingAbstract.invokeSyncImpl这里才是真正发送消息的逻辑，底层使用Netty通信。关于netty，我们知道在Netty中所有的IO操作都是异步的，因此，你不能立刻得知消息是否被正确处理，但是我们可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFuture,他们可以注册一个监听，当操作执行成功或失败时监听会自动触发。总之，所有的操作都会返回一个ChannelFuture。</p>\n<p>这里为channelFuture配置了ChannelFutureListener监听器，监听channel的操作结果。如果消息发送成功，则设置ResponseFuture中SendRequestOK为true，return。否则设置为false，并且设置responseFuture中的responseCommand为null。</p>\n<p>在设置了监听器之后，线程会阻塞等待：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">RemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);</div><div class=\"line\"></div><div class=\"line\">---</div><div class=\"line\"></div><div class=\"line\">this.countDownLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);</div><div class=\"line\">return this.responseCommand;</div></pre></td></tr></table></figure>\n<p>达到了最大等待时间之后，返回responseCommand。如果为null，则抛出消息发送超时或者其他异常。</p>\n<h1 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3 参考资料\"></a>3 参考资料</h1><ul>\n<li><a href=\"http://jm.taobao.org/2016/07/21/3-ways-to-send-message/\">消息队列三种发送方式</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/11/12/RocketMQ源码学习之二-同步消息发送/\">http://xiajunhust.github.io/2016/11/12/RocketMQ源码学习之二-同步消息发送/</a></p>"},{"title":"RocketMQ源码学习之四-PushConsumer","date":"2016-11-17T15:06:03.000Z","_content":"\n本文主要讲解RocketMQ的push消息消费者的实现原理。\n\n# 1 RocketMQ的两种消息消费者  \nRocketMQ支持两种形式的消息消费者：  \n\n* Push Consumer  \n通常是应用向Consumer对象注册一个Listener，一旦收到消息，Consumer对象立即回调Listener接口方法。底层采用的是Pull长轮询拉取消息的方式。\n* Pull Consumer  \n应用通常主动调用Consumer的拉消息方法从Broker拉消息，主动权由应用控制。\n\n# 2 Push Consumer的一个demo  \n\n<!-- more -->\n\ndemo：\n\n```\npublic class Consumer2 {\n  public static void main(String[] args) throws InterruptedException, MQClientException {\n    DefaultMQPushConsumer\n        consumer = new DefaultMQPushConsumer(\"please_rename_unique_group_name_4\");\n    consumer.setVipChannelEnabled(false);\n    consumer.setNamesrvAddr(Constants.hostIpStr + \":9876\");\n\n    /**\n     * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费<br>\n     * 如果非第一次启动，那么按照上次消费的位置继续消费\n     */\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n    consumer.subscribe(\"TopicTest2\", \"*\");\n\n    consumer.registerMessageListener(new MessageListenerOrderly() {\n\n      Random random = new Random();\n\n      public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n        context.setAutoCommit(true);\n        System.out.print(Thread.currentThread().getName() + \" Receive New Messages: \" );\n        for (MessageExt msg: msgs) {\n          System.out.println(msg + \", content:\" + new String(msg.getBody()));\n        }\n        try {\n          //模拟业务逻辑处理中...\n          TimeUnit.SECONDS.sleep(random.nextInt(10));\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        return ConsumeOrderlyStatus.SUCCESS;\n      }\n    });\n\n    consumer.start();\n\n    System.out.println(\"Consumer2 Started.\");\n  }\n}\n```\n\n运行结果：\n\n```\nconsumeMessageThread_2 Receive New Messages: MessageExt [queueId=0, storeSize=209, queueOffset=30, sysFlag=0, bornTimestamp=1479262699041, bornHost=/172.17.8.240:59605, storeTimestamp=1479262699053, storeHost=/172.17.8.240:10911, msgId=AC1108F000002A9F000000000000246D, commitLogOffset=9325, bodyCRC=2087030154, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest2, flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=31, KEYS=KEY0, UNIQ_KEY=AC1108F00B4E1218025C4F757A200000, WAIT=true, TAGS=TagA}, body=36]], content:2016-11-16 10:18:18 Hello RocketMQ 0\nConsumeMessageThread_2 Receive New Messages: MessageExt [queueId=0, storeSize=209, queueOffset=31, sysFlag=0, bornTimestamp=1479262699062, bornHost=/172.17.8.240:59605, storeTimestamp=1479262699063, storeHost=/172.17.8.240:10911, msgId=AC1108F000002A9F000000000000253E, commitLogOffset=9534, bodyCRC=191020316, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest2, flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=32, KEYS=KEY1, UNIQ_KEY=AC1108F00B4E1218025C4F757A360001, WAIT=true, TAGS=TagB}, body=36]], content:2016-11-16 10:18:18 Hello RocketMQ 1\n```\n\n# 3 Push消费方式原理分析  \n\n## 3.1 消费者启动  \nPush消费方式-消费者启动过程序列图如下：  \n![Push消费者启动序列图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-4-2.jpg)\n\n### 3.1.1 设置属性  \nNamesrvAddr  \nConsumeFromWhere-第一次启动从队列头部还是尾部开始消费  \n订阅的topic以及tag  \n### 3.1.2 监听器注册  \n这里监听器有2种类型：  \nMessageListenerOrderly-顺序消费消息  \nMessageListenerConcurrently-并发消费消息  \n### 3.1.3 订阅配置拷贝  \n将订阅关系设置到rebalanceImpl的subscriptionInner中。\n### 3.1.4 创建并加载OffsetStore实例  \nOffsetStore保存了消息消费的进度。会依据MessageModel来创建不同类型的实例：  \nBROADCASTING-LocalFileOffsetStore  \nCLUSTERING-RemoteBrokerOffsetStore\n### 3.1.5 ConsumeMessageService实例创建  \n会依据监听器的类型分别创建对应的ConsumeMessageService实例，ConsumeMessageService负责完成具体的消息消费：  \n顺序消费-ConsumeMessageOrderlyService  \n并发消费-ConsumeMessageConcurrentlyService  \n后面会做详细介绍。\n### 3.1.6 MQClientInstance启动  \n这一步非常重要：启动了消息拉取服务PullMessageService，拉取消息供ConsumeMessageService消费。 \n\n## 3.2 Pull长轮询拉取消息消费实现原理  \n整个Pull长轮询拉取消息消费执行序列图如下：  \n![Pull长轮询拉取消息消费执行序列图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-4-4.jpg)\n\n源码分析：  \n\n```\nMQClientInstance.start\n\npublic void start() throws MQClientException {\n\n    synchronized (this) {\n        switch (this.serviceState) {\n            case CREATE_JUST:\n                this.serviceState = ServiceState.START_FAILED;\n                // If not specified,looking address from name server\n                if (null == this.clientConfig.getNamesrvAddr()) {\n                    this.clientConfig.setNamesrvAddr(this.mQClientAPIImpl.fetchNameServerAddr());\n                }\n                // Start request-response channel\n                this.mQClientAPIImpl.start();\n                // Start various schedule tasks\n                this.startScheduledTask();\n                // Start pull service\n                this.pullMessageService.start();\n                // Start rebalance service\n                this.rebalanceService.start();\n                // Start push service\n                this.defaultMQProducer.getDefaultMQProducerImpl().start(false);\n                log.info(\"the client factory [{}] start OK\", this.clientId);\n                this.serviceState = ServiceState.RUNNING;\n                break;\n            case RUNNING:\n                break;\n            case SHUTDOWN_ALREADY:\n                break;\n            case START_FAILED:\n                throw new MQClientException(\"The Factory object[\" + this.getClientId() + \"] has been created before, and failed.\", null);\n            default:\n                break;\n        }\n    }\n}\n```\n    \n这里面非常重要的异步就是消息拉取服务PullMessageService的启动，PullMessageService通过长轮训拉取消息，然后交给ConsumeMessageService完成具体的消息消费。  \n我们看下PullMessageService启动做了什么事情，启动了一个线程，run函数中核心代码：\n\n```\npublic void run() {\n    while (!this.isStoped()) {\n    \t ...\n    \t //从队列中获取PullRequest，调用拉取消息方法\n        PullRequest pullRequest = this.pullRequestQueue.take();\n        if (pullRequest != null) {\n            this.pullMessage(pullRequest);\n        }\n        ...\n    }\n}\n\n//拉取消息\nprivate void pullMessage(final PullRequest pullRequest) {\n\t//获取消费者，调用消费者的消息拉取方法\n    final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());\n    if (consumer != null) {\n        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;\n        impl.pullMessage(pullRequest);\n    } else {\n        log.warn(\"No matched consumer for the PullRequest {}, drop it\", pullRequest);\n    }\n}\n```\n\n这里对应的消费者是DefaultMQPushConsumerImpl，我们接下来看DefaultMQPushConsumerImpl的pullMessage方法。  \n（1）流控，如果超出流量限制则，或者broker锁定失败，将PullRequest提交到PullMessageService的单线程线程池。  \n\n```\npublic void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) {\n    this.scheduledExecutorService.schedule(new Runnable() {\n\n        @Override\n        public void run() {\n            PullMessageService.this.executePullRequestImmediately(pullRequest);\n        }\n    }, timeDelay, TimeUnit.MILLISECONDS);\n}\n\npublic void executePullRequestImmediately(final PullRequest pullRequest) {\n    try {\n    \t //将拉取请求放入阻塞队列\n        this.pullRequestQueue.put(pullRequest);\n    } catch (InterruptedException e) {\n        log.error(\"executePullRequestImmediately pullRequestQueue.put\", e);\n    }\n}\n```\n    \n（2）启动拉取PullAPIWrapper.pullKernelImpl\n\n```\nthis.pullAPIWrapper.pullKernelImpl(//\n        pullRequest.getMessageQueue(), // 1\n        subExpression, // 2\n        subscriptionData.getSubVersion(), // 3\n        pullRequest.getNextOffset(), // 4\n        this.defaultMQPushConsumer.getPullBatchSize(), // 5\n        sysFlag, // 6\n        commitOffsetValue, // 7\n        BrokerSuspendMaxTimeMillis, // 8\n        ConsumerTimeoutMillisWhenSuspend, // 9\n        CommunicationMode.ASYNC, // 10\n        pullCallback// 11\n);\n    \n\npublic PullResult pullKernelImpl(//\n                                 final MessageQueue mq,// 1\n                                 final String subExpression,// 2\n                                 final long subVersion,// 3\n                                 final long offset,// 4\n                                 final int maxNums,// 5\n                                 final int sysFlag,// 6\n                                 final long commitOffset,// 7\n                                 final long brokerSuspendMaxTimeMillis,// 8\n                                 final long timeoutMillis,// 9\n                                 final CommunicationMode communicationMode,// 10\n                                 final PullCallback pullCallback// 11\n) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n    FindBrokerResult findBrokerResult =\n            this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),\n                    this.recalculatePullFromWhichNode(mq), false);\n    if (null == findBrokerResult) {\n        this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());\n        findBrokerResult =\n                this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),\n                        this.recalculatePullFromWhichNode(mq), false);\n    }\n\n    if (findBrokerResult != null) {\n        int sysFlagInner = sysFlag;\n\n        if (findBrokerResult.isSlave()) {\n            sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);\n        }\n\n        PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();\n        requestHeader.setConsumerGroup(this.consumerGroup);\n        requestHeader.setTopic(mq.getTopic());\n        requestHeader.setQueueId(mq.getQueueId());\n        requestHeader.setQueueOffset(offset);\n        requestHeader.setMaxMsgNums(maxNums);\n        requestHeader.setSysFlag(sysFlagInner);\n        requestHeader.setCommitOffset(commitOffset);\n        requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);\n        requestHeader.setSubscription(subExpression);\n        requestHeader.setSubVersion(subVersion);\n\n        String brokerAddr = findBrokerResult.getBrokerAddr();\n        if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) {\n            brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);\n        }\n\n        PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage(//\n                brokerAddr,//\n                requestHeader,//\n                timeoutMillis,//\n                communicationMode,//这里传的是ASYNC\n                pullCallback);\n\n        return pullResult;\n    }\n\n    throw new MQClientException(\"The broker[\" + mq.getBrokerName() + \"] not exist\", null);\n}\n```\n\n接下来调到底层通信层NettyRemotingClient.invokeAsyncImpl:\n\n```\nprivate void pullMessageAsync(//\n                              final String addr, // 1\n                              final RemotingCommand request, //\n                              final long timeoutMillis, //\n                              final PullCallback pullCallback//\n) throws RemotingException, InterruptedException {\n    this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() {\n        @Override\n        public void operationComplete(ResponseFuture responseFuture) {\n            RemotingCommand response = responseFuture.getResponseCommand();\n            if (response != null) {\n                try {\n                    PullResult pullResult = MQClientAPIImpl.this.processPullResponse(response);\n                    assert pullResult != null;\n                    pullCallback.onSuccess(pullResult);\n                } catch (Exception e) {\n                    pullCallback.onException(e);\n                }\n            } else {\n                if (!responseFuture.isSendRequestOK()) {\n                    pullCallback.onException(new MQClientException(\"send request failed\", responseFuture.getCause()));\n                } else if (responseFuture.isTimeout()) {\n                    pullCallback.onException(new MQClientException(\"wait response timeout \" + responseFuture.getTimeoutMillis() + \"ms\",\n                            responseFuture.getCause()));\n                } else {\n                    pullCallback.onException(new MQClientException(\"unknow reseaon\", responseFuture.getCause()));\n                }\n            }\n        }\n    });\n}\n    \npublic void invokeAsyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis,final InvokeCallback invokeCallback)\n        throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException {\n    final int opaque = request.getOpaque();\n    boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);\n    if (acquired) {\n        final SemaphoreReleaseOnlyOnce once = new SemaphoreReleaseOnlyOnce(this.semaphoreAsync);\n\n        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, invokeCallback, once);\n        this.responseTable.put(opaque, responseFuture);\n        try {\n            channel.writeAndFlush(request).addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture f) throws Exception {\n                    if (f.isSuccess()) {\n                        responseFuture.setSendRequestOK(true);\n                        return;\n                    } else {\n                        responseFuture.setSendRequestOK(false);\n                    }\n\n                    responseFuture.putResponse(null);\n                    responseTable.remove(opaque);\n                    try {\n                    \t //执行回调函数InvokeCallback\n                        responseFuture.executeInvokeCallback();\n                    } catch (Throwable e) {\n\n\t\t....\n}\n```\n\n可以看出是采用的异步模式，注册监听器，收到响应结果后调用回调函数InvokeCallback。而在InvokeCallback中调用了DefaultMQPushConsumerImpl中的PullCallback回调函数的onSuccess、onException，分别就返回成功结果和失败结果执行对应操作：\n\n```\nPullCallback核心代码：  \n@Override\npublic void onSuccess(PullResult pullResult) {\n\tswitch (pullResult.getPullStatus()) {\n\tcase FOUND:\n\t\t...\n\t\t//将拉取到的消息放入processQueue\n\t    boolean dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());\n\t    //向消息服务consumeMessageService提交消息消费请求\n\t    DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(//\n\t            pullResult.getMsgFoundList(), //\n\t            processQueue, //\n\t            pullRequest.getMessageQueue(), //\n\t            dispathToConsume);\n...\n\t\n\t\n@Override\npublic void onException(Throwable e) {\n    if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n        log.warn(\"execute the pull request exception\", e);\n    }\n\t//提交到线程池，稍后执行\n    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, PullTimeDelayMillsWhenException);\n}\n```\n\n\n## 3.2 消息消费服务-ConsumeMessageService  \nPull消息拉取服务拉取消息成功之后，向ConsumeMessageService提交消息消费请求，由后者完成具体的消费过程。具体逻辑在下一篇文章中讲解。 \n","source":"_posts/RocketMQ源码学习之四-PushConsumer.md","raw":"---\ntitle: RocketMQ源码学习之四-PushConsumer\ndate: 2016-11-17 23:06:03\ntags: RocketMQ\n---\n\n本文主要讲解RocketMQ的push消息消费者的实现原理。\n\n# 1 RocketMQ的两种消息消费者  \nRocketMQ支持两种形式的消息消费者：  \n\n* Push Consumer  \n通常是应用向Consumer对象注册一个Listener，一旦收到消息，Consumer对象立即回调Listener接口方法。底层采用的是Pull长轮询拉取消息的方式。\n* Pull Consumer  \n应用通常主动调用Consumer的拉消息方法从Broker拉消息，主动权由应用控制。\n\n# 2 Push Consumer的一个demo  \n\n<!-- more -->\n\ndemo：\n\n```\npublic class Consumer2 {\n  public static void main(String[] args) throws InterruptedException, MQClientException {\n    DefaultMQPushConsumer\n        consumer = new DefaultMQPushConsumer(\"please_rename_unique_group_name_4\");\n    consumer.setVipChannelEnabled(false);\n    consumer.setNamesrvAddr(Constants.hostIpStr + \":9876\");\n\n    /**\n     * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费<br>\n     * 如果非第一次启动，那么按照上次消费的位置继续消费\n     */\n    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n    consumer.subscribe(\"TopicTest2\", \"*\");\n\n    consumer.registerMessageListener(new MessageListenerOrderly() {\n\n      Random random = new Random();\n\n      public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n        context.setAutoCommit(true);\n        System.out.print(Thread.currentThread().getName() + \" Receive New Messages: \" );\n        for (MessageExt msg: msgs) {\n          System.out.println(msg + \", content:\" + new String(msg.getBody()));\n        }\n        try {\n          //模拟业务逻辑处理中...\n          TimeUnit.SECONDS.sleep(random.nextInt(10));\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        return ConsumeOrderlyStatus.SUCCESS;\n      }\n    });\n\n    consumer.start();\n\n    System.out.println(\"Consumer2 Started.\");\n  }\n}\n```\n\n运行结果：\n\n```\nconsumeMessageThread_2 Receive New Messages: MessageExt [queueId=0, storeSize=209, queueOffset=30, sysFlag=0, bornTimestamp=1479262699041, bornHost=/172.17.8.240:59605, storeTimestamp=1479262699053, storeHost=/172.17.8.240:10911, msgId=AC1108F000002A9F000000000000246D, commitLogOffset=9325, bodyCRC=2087030154, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest2, flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=31, KEYS=KEY0, UNIQ_KEY=AC1108F00B4E1218025C4F757A200000, WAIT=true, TAGS=TagA}, body=36]], content:2016-11-16 10:18:18 Hello RocketMQ 0\nConsumeMessageThread_2 Receive New Messages: MessageExt [queueId=0, storeSize=209, queueOffset=31, sysFlag=0, bornTimestamp=1479262699062, bornHost=/172.17.8.240:59605, storeTimestamp=1479262699063, storeHost=/172.17.8.240:10911, msgId=AC1108F000002A9F000000000000253E, commitLogOffset=9534, bodyCRC=191020316, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest2, flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=32, KEYS=KEY1, UNIQ_KEY=AC1108F00B4E1218025C4F757A360001, WAIT=true, TAGS=TagB}, body=36]], content:2016-11-16 10:18:18 Hello RocketMQ 1\n```\n\n# 3 Push消费方式原理分析  \n\n## 3.1 消费者启动  \nPush消费方式-消费者启动过程序列图如下：  \n![Push消费者启动序列图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-4-2.jpg)\n\n### 3.1.1 设置属性  \nNamesrvAddr  \nConsumeFromWhere-第一次启动从队列头部还是尾部开始消费  \n订阅的topic以及tag  \n### 3.1.2 监听器注册  \n这里监听器有2种类型：  \nMessageListenerOrderly-顺序消费消息  \nMessageListenerConcurrently-并发消费消息  \n### 3.1.3 订阅配置拷贝  \n将订阅关系设置到rebalanceImpl的subscriptionInner中。\n### 3.1.4 创建并加载OffsetStore实例  \nOffsetStore保存了消息消费的进度。会依据MessageModel来创建不同类型的实例：  \nBROADCASTING-LocalFileOffsetStore  \nCLUSTERING-RemoteBrokerOffsetStore\n### 3.1.5 ConsumeMessageService实例创建  \n会依据监听器的类型分别创建对应的ConsumeMessageService实例，ConsumeMessageService负责完成具体的消息消费：  \n顺序消费-ConsumeMessageOrderlyService  \n并发消费-ConsumeMessageConcurrentlyService  \n后面会做详细介绍。\n### 3.1.6 MQClientInstance启动  \n这一步非常重要：启动了消息拉取服务PullMessageService，拉取消息供ConsumeMessageService消费。 \n\n## 3.2 Pull长轮询拉取消息消费实现原理  \n整个Pull长轮询拉取消息消费执行序列图如下：  \n![Pull长轮询拉取消息消费执行序列图](http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-4-4.jpg)\n\n源码分析：  \n\n```\nMQClientInstance.start\n\npublic void start() throws MQClientException {\n\n    synchronized (this) {\n        switch (this.serviceState) {\n            case CREATE_JUST:\n                this.serviceState = ServiceState.START_FAILED;\n                // If not specified,looking address from name server\n                if (null == this.clientConfig.getNamesrvAddr()) {\n                    this.clientConfig.setNamesrvAddr(this.mQClientAPIImpl.fetchNameServerAddr());\n                }\n                // Start request-response channel\n                this.mQClientAPIImpl.start();\n                // Start various schedule tasks\n                this.startScheduledTask();\n                // Start pull service\n                this.pullMessageService.start();\n                // Start rebalance service\n                this.rebalanceService.start();\n                // Start push service\n                this.defaultMQProducer.getDefaultMQProducerImpl().start(false);\n                log.info(\"the client factory [{}] start OK\", this.clientId);\n                this.serviceState = ServiceState.RUNNING;\n                break;\n            case RUNNING:\n                break;\n            case SHUTDOWN_ALREADY:\n                break;\n            case START_FAILED:\n                throw new MQClientException(\"The Factory object[\" + this.getClientId() + \"] has been created before, and failed.\", null);\n            default:\n                break;\n        }\n    }\n}\n```\n    \n这里面非常重要的异步就是消息拉取服务PullMessageService的启动，PullMessageService通过长轮训拉取消息，然后交给ConsumeMessageService完成具体的消息消费。  \n我们看下PullMessageService启动做了什么事情，启动了一个线程，run函数中核心代码：\n\n```\npublic void run() {\n    while (!this.isStoped()) {\n    \t ...\n    \t //从队列中获取PullRequest，调用拉取消息方法\n        PullRequest pullRequest = this.pullRequestQueue.take();\n        if (pullRequest != null) {\n            this.pullMessage(pullRequest);\n        }\n        ...\n    }\n}\n\n//拉取消息\nprivate void pullMessage(final PullRequest pullRequest) {\n\t//获取消费者，调用消费者的消息拉取方法\n    final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());\n    if (consumer != null) {\n        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;\n        impl.pullMessage(pullRequest);\n    } else {\n        log.warn(\"No matched consumer for the PullRequest {}, drop it\", pullRequest);\n    }\n}\n```\n\n这里对应的消费者是DefaultMQPushConsumerImpl，我们接下来看DefaultMQPushConsumerImpl的pullMessage方法。  \n（1）流控，如果超出流量限制则，或者broker锁定失败，将PullRequest提交到PullMessageService的单线程线程池。  \n\n```\npublic void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) {\n    this.scheduledExecutorService.schedule(new Runnable() {\n\n        @Override\n        public void run() {\n            PullMessageService.this.executePullRequestImmediately(pullRequest);\n        }\n    }, timeDelay, TimeUnit.MILLISECONDS);\n}\n\npublic void executePullRequestImmediately(final PullRequest pullRequest) {\n    try {\n    \t //将拉取请求放入阻塞队列\n        this.pullRequestQueue.put(pullRequest);\n    } catch (InterruptedException e) {\n        log.error(\"executePullRequestImmediately pullRequestQueue.put\", e);\n    }\n}\n```\n    \n（2）启动拉取PullAPIWrapper.pullKernelImpl\n\n```\nthis.pullAPIWrapper.pullKernelImpl(//\n        pullRequest.getMessageQueue(), // 1\n        subExpression, // 2\n        subscriptionData.getSubVersion(), // 3\n        pullRequest.getNextOffset(), // 4\n        this.defaultMQPushConsumer.getPullBatchSize(), // 5\n        sysFlag, // 6\n        commitOffsetValue, // 7\n        BrokerSuspendMaxTimeMillis, // 8\n        ConsumerTimeoutMillisWhenSuspend, // 9\n        CommunicationMode.ASYNC, // 10\n        pullCallback// 11\n);\n    \n\npublic PullResult pullKernelImpl(//\n                                 final MessageQueue mq,// 1\n                                 final String subExpression,// 2\n                                 final long subVersion,// 3\n                                 final long offset,// 4\n                                 final int maxNums,// 5\n                                 final int sysFlag,// 6\n                                 final long commitOffset,// 7\n                                 final long brokerSuspendMaxTimeMillis,// 8\n                                 final long timeoutMillis,// 9\n                                 final CommunicationMode communicationMode,// 10\n                                 final PullCallback pullCallback// 11\n) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n    FindBrokerResult findBrokerResult =\n            this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),\n                    this.recalculatePullFromWhichNode(mq), false);\n    if (null == findBrokerResult) {\n        this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());\n        findBrokerResult =\n                this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),\n                        this.recalculatePullFromWhichNode(mq), false);\n    }\n\n    if (findBrokerResult != null) {\n        int sysFlagInner = sysFlag;\n\n        if (findBrokerResult.isSlave()) {\n            sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);\n        }\n\n        PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();\n        requestHeader.setConsumerGroup(this.consumerGroup);\n        requestHeader.setTopic(mq.getTopic());\n        requestHeader.setQueueId(mq.getQueueId());\n        requestHeader.setQueueOffset(offset);\n        requestHeader.setMaxMsgNums(maxNums);\n        requestHeader.setSysFlag(sysFlagInner);\n        requestHeader.setCommitOffset(commitOffset);\n        requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);\n        requestHeader.setSubscription(subExpression);\n        requestHeader.setSubVersion(subVersion);\n\n        String brokerAddr = findBrokerResult.getBrokerAddr();\n        if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) {\n            brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);\n        }\n\n        PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage(//\n                brokerAddr,//\n                requestHeader,//\n                timeoutMillis,//\n                communicationMode,//这里传的是ASYNC\n                pullCallback);\n\n        return pullResult;\n    }\n\n    throw new MQClientException(\"The broker[\" + mq.getBrokerName() + \"] not exist\", null);\n}\n```\n\n接下来调到底层通信层NettyRemotingClient.invokeAsyncImpl:\n\n```\nprivate void pullMessageAsync(//\n                              final String addr, // 1\n                              final RemotingCommand request, //\n                              final long timeoutMillis, //\n                              final PullCallback pullCallback//\n) throws RemotingException, InterruptedException {\n    this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() {\n        @Override\n        public void operationComplete(ResponseFuture responseFuture) {\n            RemotingCommand response = responseFuture.getResponseCommand();\n            if (response != null) {\n                try {\n                    PullResult pullResult = MQClientAPIImpl.this.processPullResponse(response);\n                    assert pullResult != null;\n                    pullCallback.onSuccess(pullResult);\n                } catch (Exception e) {\n                    pullCallback.onException(e);\n                }\n            } else {\n                if (!responseFuture.isSendRequestOK()) {\n                    pullCallback.onException(new MQClientException(\"send request failed\", responseFuture.getCause()));\n                } else if (responseFuture.isTimeout()) {\n                    pullCallback.onException(new MQClientException(\"wait response timeout \" + responseFuture.getTimeoutMillis() + \"ms\",\n                            responseFuture.getCause()));\n                } else {\n                    pullCallback.onException(new MQClientException(\"unknow reseaon\", responseFuture.getCause()));\n                }\n            }\n        }\n    });\n}\n    \npublic void invokeAsyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis,final InvokeCallback invokeCallback)\n        throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException {\n    final int opaque = request.getOpaque();\n    boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);\n    if (acquired) {\n        final SemaphoreReleaseOnlyOnce once = new SemaphoreReleaseOnlyOnce(this.semaphoreAsync);\n\n        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, invokeCallback, once);\n        this.responseTable.put(opaque, responseFuture);\n        try {\n            channel.writeAndFlush(request).addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture f) throws Exception {\n                    if (f.isSuccess()) {\n                        responseFuture.setSendRequestOK(true);\n                        return;\n                    } else {\n                        responseFuture.setSendRequestOK(false);\n                    }\n\n                    responseFuture.putResponse(null);\n                    responseTable.remove(opaque);\n                    try {\n                    \t //执行回调函数InvokeCallback\n                        responseFuture.executeInvokeCallback();\n                    } catch (Throwable e) {\n\n\t\t....\n}\n```\n\n可以看出是采用的异步模式，注册监听器，收到响应结果后调用回调函数InvokeCallback。而在InvokeCallback中调用了DefaultMQPushConsumerImpl中的PullCallback回调函数的onSuccess、onException，分别就返回成功结果和失败结果执行对应操作：\n\n```\nPullCallback核心代码：  \n@Override\npublic void onSuccess(PullResult pullResult) {\n\tswitch (pullResult.getPullStatus()) {\n\tcase FOUND:\n\t\t...\n\t\t//将拉取到的消息放入processQueue\n\t    boolean dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());\n\t    //向消息服务consumeMessageService提交消息消费请求\n\t    DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(//\n\t            pullResult.getMsgFoundList(), //\n\t            processQueue, //\n\t            pullRequest.getMessageQueue(), //\n\t            dispathToConsume);\n...\n\t\n\t\n@Override\npublic void onException(Throwable e) {\n    if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n        log.warn(\"execute the pull request exception\", e);\n    }\n\t//提交到线程池，稍后执行\n    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, PullTimeDelayMillsWhenException);\n}\n```\n\n\n## 3.2 消息消费服务-ConsumeMessageService  \nPull消息拉取服务拉取消息成功之后，向ConsumeMessageService提交消息消费请求，由后者完成具体的消费过程。具体逻辑在下一篇文章中讲解。 \n","slug":"RocketMQ源码学习之四-PushConsumer","published":1,"updated":"2016-11-19T03:33:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsbz000i2hwfcwx14owr","content":"<p>本文主要讲解RocketMQ的push消息消费者的实现原理。</p>\n<h1 id=\"1-RocketMQ的两种消息消费者\"><a href=\"#1-RocketMQ的两种消息消费者\" class=\"headerlink\" title=\"1 RocketMQ的两种消息消费者\"></a>1 RocketMQ的两种消息消费者</h1><p>RocketMQ支持两种形式的消息消费者：  </p>\n<ul>\n<li>Push Consumer<br>通常是应用向Consumer对象注册一个Listener，一旦收到消息，Consumer对象立即回调Listener接口方法。底层采用的是Pull长轮询拉取消息的方式。</li>\n<li>Pull Consumer<br>应用通常主动调用Consumer的拉消息方法从Broker拉消息，主动权由应用控制。</li>\n</ul>\n<h1 id=\"2-Push-Consumer的一个demo\"><a href=\"#2-Push-Consumer的一个demo\" class=\"headerlink\" title=\"2 Push Consumer的一个demo\"></a>2 Push Consumer的一个demo</h1><a id=\"more\"></a>\n<p>demo：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Consumer2 &#123;</div><div class=\"line\">  public static void main(String[] args) throws InterruptedException, MQClientException &#123;</div><div class=\"line\">    DefaultMQPushConsumer</div><div class=\"line\">        consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;);</div><div class=\"line\">    consumer.setVipChannelEnabled(false);</div><div class=\"line\">    consumer.setNamesrvAddr(Constants.hostIpStr + &quot;:9876&quot;);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</div><div class=\"line\">     * 如果非第一次启动，那么按照上次消费的位置继续消费</div><div class=\"line\">     */</div><div class=\"line\">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</div><div class=\"line\"></div><div class=\"line\">    consumer.subscribe(&quot;TopicTest2&quot;, &quot;*&quot;);</div><div class=\"line\"></div><div class=\"line\">    consumer.registerMessageListener(new MessageListenerOrderly() &#123;</div><div class=\"line\"></div><div class=\"line\">      Random random = new Random();</div><div class=\"line\"></div><div class=\"line\">      public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) &#123;</div><div class=\"line\">        context.setAutoCommit(true);</div><div class=\"line\">        System.out.print(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; );</div><div class=\"line\">        for (MessageExt msg: msgs) &#123;</div><div class=\"line\">          System.out.println(msg + &quot;, content:&quot; + new String(msg.getBody()));</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">          //模拟业务逻辑处理中...</div><div class=\"line\">          TimeUnit.SECONDS.sleep(random.nextInt(10));</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">          e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return ConsumeOrderlyStatus.SUCCESS;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    consumer.start();</div><div class=\"line\"></div><div class=\"line\">    System.out.println(&quot;Consumer2 Started.&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">consumeMessageThread_2 Receive New Messages: MessageExt [queueId=0, storeSize=209, queueOffset=30, sysFlag=0, bornTimestamp=1479262699041, bornHost=/172.17.8.240:59605, storeTimestamp=1479262699053, storeHost=/172.17.8.240:10911, msgId=AC1108F000002A9F000000000000246D, commitLogOffset=9325, bodyCRC=2087030154, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest2, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=31, KEYS=KEY0, UNIQ_KEY=AC1108F00B4E1218025C4F757A200000, WAIT=true, TAGS=TagA&#125;, body=36]], content:2016-11-16 10:18:18 Hello RocketMQ 0</div><div class=\"line\">ConsumeMessageThread_2 Receive New Messages: MessageExt [queueId=0, storeSize=209, queueOffset=31, sysFlag=0, bornTimestamp=1479262699062, bornHost=/172.17.8.240:59605, storeTimestamp=1479262699063, storeHost=/172.17.8.240:10911, msgId=AC1108F000002A9F000000000000253E, commitLogOffset=9534, bodyCRC=191020316, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest2, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=32, KEYS=KEY1, UNIQ_KEY=AC1108F00B4E1218025C4F757A360001, WAIT=true, TAGS=TagB&#125;, body=36]], content:2016-11-16 10:18:18 Hello RocketMQ 1</div></pre></td></tr></table></figure>\n<h1 id=\"3-Push消费方式原理分析\"><a href=\"#3-Push消费方式原理分析\" class=\"headerlink\" title=\"3 Push消费方式原理分析\"></a>3 Push消费方式原理分析</h1><h2 id=\"3-1-消费者启动\"><a href=\"#3-1-消费者启动\" class=\"headerlink\" title=\"3.1 消费者启动\"></a>3.1 消费者启动</h2><p>Push消费方式-消费者启动过程序列图如下：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-4-2.jpg\" alt=\"Push消费者启动序列图\"></p>\n<h3 id=\"3-1-1-设置属性\"><a href=\"#3-1-1-设置属性\" class=\"headerlink\" title=\"3.1.1 设置属性\"></a>3.1.1 设置属性</h3><p>NamesrvAddr<br>ConsumeFromWhere-第一次启动从队列头部还是尾部开始消费<br>订阅的topic以及tag  </p>\n<h3 id=\"3-1-2-监听器注册\"><a href=\"#3-1-2-监听器注册\" class=\"headerlink\" title=\"3.1.2 监听器注册\"></a>3.1.2 监听器注册</h3><p>这里监听器有2种类型：<br>MessageListenerOrderly-顺序消费消息<br>MessageListenerConcurrently-并发消费消息  </p>\n<h3 id=\"3-1-3-订阅配置拷贝\"><a href=\"#3-1-3-订阅配置拷贝\" class=\"headerlink\" title=\"3.1.3 订阅配置拷贝\"></a>3.1.3 订阅配置拷贝</h3><p>将订阅关系设置到rebalanceImpl的subscriptionInner中。</p>\n<h3 id=\"3-1-4-创建并加载OffsetStore实例\"><a href=\"#3-1-4-创建并加载OffsetStore实例\" class=\"headerlink\" title=\"3.1.4 创建并加载OffsetStore实例\"></a>3.1.4 创建并加载OffsetStore实例</h3><p>OffsetStore保存了消息消费的进度。会依据MessageModel来创建不同类型的实例：<br>BROADCASTING-LocalFileOffsetStore<br>CLUSTERING-RemoteBrokerOffsetStore</p>\n<h3 id=\"3-1-5-ConsumeMessageService实例创建\"><a href=\"#3-1-5-ConsumeMessageService实例创建\" class=\"headerlink\" title=\"3.1.5 ConsumeMessageService实例创建\"></a>3.1.5 ConsumeMessageService实例创建</h3><p>会依据监听器的类型分别创建对应的ConsumeMessageService实例，ConsumeMessageService负责完成具体的消息消费：<br>顺序消费-ConsumeMessageOrderlyService<br>并发消费-ConsumeMessageConcurrentlyService<br>后面会做详细介绍。</p>\n<h3 id=\"3-1-6-MQClientInstance启动\"><a href=\"#3-1-6-MQClientInstance启动\" class=\"headerlink\" title=\"3.1.6 MQClientInstance启动\"></a>3.1.6 MQClientInstance启动</h3><p>这一步非常重要：启动了消息拉取服务PullMessageService，拉取消息供ConsumeMessageService消费。 </p>\n<h2 id=\"3-2-Pull长轮询拉取消息消费实现原理\"><a href=\"#3-2-Pull长轮询拉取消息消费实现原理\" class=\"headerlink\" title=\"3.2 Pull长轮询拉取消息消费实现原理\"></a>3.2 Pull长轮询拉取消息消费实现原理</h2><p>整个Pull长轮询拉取消息消费执行序列图如下：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-4-4.jpg\" alt=\"Pull长轮询拉取消息消费执行序列图\"></p>\n<p>源码分析：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">MQClientInstance.start</div><div class=\"line\"></div><div class=\"line\">public void start() throws MQClientException &#123;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        switch (this.serviceState) &#123;</div><div class=\"line\">            case CREATE_JUST:</div><div class=\"line\">                this.serviceState = ServiceState.START_FAILED;</div><div class=\"line\">                // If not specified,looking address from name server</div><div class=\"line\">                if (null == this.clientConfig.getNamesrvAddr()) &#123;</div><div class=\"line\">                    this.clientConfig.setNamesrvAddr(this.mQClientAPIImpl.fetchNameServerAddr());</div><div class=\"line\">                &#125;</div><div class=\"line\">                // Start request-response channel</div><div class=\"line\">                this.mQClientAPIImpl.start();</div><div class=\"line\">                // Start various schedule tasks</div><div class=\"line\">                this.startScheduledTask();</div><div class=\"line\">                // Start pull service</div><div class=\"line\">                this.pullMessageService.start();</div><div class=\"line\">                // Start rebalance service</div><div class=\"line\">                this.rebalanceService.start();</div><div class=\"line\">                // Start push service</div><div class=\"line\">                this.defaultMQProducer.getDefaultMQProducerImpl().start(false);</div><div class=\"line\">                log.info(&quot;the client factory [&#123;&#125;] start OK&quot;, this.clientId);</div><div class=\"line\">                this.serviceState = ServiceState.RUNNING;</div><div class=\"line\">                break;</div><div class=\"line\">            case RUNNING:</div><div class=\"line\">                break;</div><div class=\"line\">            case SHUTDOWN_ALREADY:</div><div class=\"line\">                break;</div><div class=\"line\">            case START_FAILED:</div><div class=\"line\">                throw new MQClientException(&quot;The Factory object[&quot; + this.getClientId() + &quot;] has been created before, and failed.&quot;, null);</div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里面非常重要的异步就是消息拉取服务PullMessageService的启动，PullMessageService通过长轮训拉取消息，然后交给ConsumeMessageService完成具体的消息消费。<br>我们看下PullMessageService启动做了什么事情，启动了一个线程，run函数中核心代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\">    while (!this.isStoped()) &#123;</div><div class=\"line\">    \t ...</div><div class=\"line\">    \t //从队列中获取PullRequest，调用拉取消息方法</div><div class=\"line\">        PullRequest pullRequest = this.pullRequestQueue.take();</div><div class=\"line\">        if (pullRequest != null) &#123;</div><div class=\"line\">            this.pullMessage(pullRequest);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//拉取消息</div><div class=\"line\">private void pullMessage(final PullRequest pullRequest) &#123;</div><div class=\"line\">\t//获取消费者，调用消费者的消息拉取方法</div><div class=\"line\">    final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</div><div class=\"line\">    if (consumer != null) &#123;</div><div class=\"line\">        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</div><div class=\"line\">        impl.pullMessage(pullRequest);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        log.warn(&quot;No matched consumer for the PullRequest &#123;&#125;, drop it&quot;, pullRequest);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里对应的消费者是DefaultMQPushConsumerImpl，我们接下来看DefaultMQPushConsumerImpl的pullMessage方法。<br>（1）流控，如果超出流量限制则，或者broker锁定失败，将PullRequest提交到PullMessageService的单线程线程池。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) &#123;</div><div class=\"line\">    this.scheduledExecutorService.schedule(new Runnable() &#123;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            PullMessageService.this.executePullRequestImmediately(pullRequest);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;, timeDelay, TimeUnit.MILLISECONDS);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public void executePullRequestImmediately(final PullRequest pullRequest) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">    \t //将拉取请求放入阻塞队列</div><div class=\"line\">        this.pullRequestQueue.put(pullRequest);</div><div class=\"line\">    &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">        log.error(&quot;executePullRequestImmediately pullRequestQueue.put&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）启动拉取PullAPIWrapper.pullKernelImpl</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.pullAPIWrapper.pullKernelImpl(//</div><div class=\"line\">        pullRequest.getMessageQueue(), // 1</div><div class=\"line\">        subExpression, // 2</div><div class=\"line\">        subscriptionData.getSubVersion(), // 3</div><div class=\"line\">        pullRequest.getNextOffset(), // 4</div><div class=\"line\">        this.defaultMQPushConsumer.getPullBatchSize(), // 5</div><div class=\"line\">        sysFlag, // 6</div><div class=\"line\">        commitOffsetValue, // 7</div><div class=\"line\">        BrokerSuspendMaxTimeMillis, // 8</div><div class=\"line\">        ConsumerTimeoutMillisWhenSuspend, // 9</div><div class=\"line\">        CommunicationMode.ASYNC, // 10</div><div class=\"line\">        pullCallback// 11</div><div class=\"line\">);</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\">public PullResult pullKernelImpl(//</div><div class=\"line\">                                 final MessageQueue mq,// 1</div><div class=\"line\">                                 final String subExpression,// 2</div><div class=\"line\">                                 final long subVersion,// 3</div><div class=\"line\">                                 final long offset,// 4</div><div class=\"line\">                                 final int maxNums,// 5</div><div class=\"line\">                                 final int sysFlag,// 6</div><div class=\"line\">                                 final long commitOffset,// 7</div><div class=\"line\">                                 final long brokerSuspendMaxTimeMillis,// 8</div><div class=\"line\">                                 final long timeoutMillis,// 9</div><div class=\"line\">                                 final CommunicationMode communicationMode,// 10</div><div class=\"line\">                                 final PullCallback pullCallback// 11</div><div class=\"line\">) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\">    FindBrokerResult findBrokerResult =</div><div class=\"line\">            this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</div><div class=\"line\">                    this.recalculatePullFromWhichNode(mq), false);</div><div class=\"line\">    if (null == findBrokerResult) &#123;</div><div class=\"line\">        this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</div><div class=\"line\">        findBrokerResult =</div><div class=\"line\">                this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</div><div class=\"line\">                        this.recalculatePullFromWhichNode(mq), false);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (findBrokerResult != null) &#123;</div><div class=\"line\">        int sysFlagInner = sysFlag;</div><div class=\"line\"></div><div class=\"line\">        if (findBrokerResult.isSlave()) &#123;</div><div class=\"line\">            sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();</div><div class=\"line\">        requestHeader.setConsumerGroup(this.consumerGroup);</div><div class=\"line\">        requestHeader.setTopic(mq.getTopic());</div><div class=\"line\">        requestHeader.setQueueId(mq.getQueueId());</div><div class=\"line\">        requestHeader.setQueueOffset(offset);</div><div class=\"line\">        requestHeader.setMaxMsgNums(maxNums);</div><div class=\"line\">        requestHeader.setSysFlag(sysFlagInner);</div><div class=\"line\">        requestHeader.setCommitOffset(commitOffset);</div><div class=\"line\">        requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);</div><div class=\"line\">        requestHeader.setSubscription(subExpression);</div><div class=\"line\">        requestHeader.setSubVersion(subVersion);</div><div class=\"line\"></div><div class=\"line\">        String brokerAddr = findBrokerResult.getBrokerAddr();</div><div class=\"line\">        if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) &#123;</div><div class=\"line\">            brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage(//</div><div class=\"line\">                brokerAddr,//</div><div class=\"line\">                requestHeader,//</div><div class=\"line\">                timeoutMillis,//</div><div class=\"line\">                communicationMode,//这里传的是ASYNC</div><div class=\"line\">                pullCallback);</div><div class=\"line\"></div><div class=\"line\">        return pullResult;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    throw new MQClientException(&quot;The broker[&quot; + mq.getBrokerName() + &quot;] not exist&quot;, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来调到底层通信层NettyRemotingClient.invokeAsyncImpl:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void pullMessageAsync(//</div><div class=\"line\">                              final String addr, // 1</div><div class=\"line\">                              final RemotingCommand request, //</div><div class=\"line\">                              final long timeoutMillis, //</div><div class=\"line\">                              final PullCallback pullCallback//</div><div class=\"line\">) throws RemotingException, InterruptedException &#123;</div><div class=\"line\">    this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void operationComplete(ResponseFuture responseFuture) &#123;</div><div class=\"line\">            RemotingCommand response = responseFuture.getResponseCommand();</div><div class=\"line\">            if (response != null) &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    PullResult pullResult = MQClientAPIImpl.this.processPullResponse(response);</div><div class=\"line\">                    assert pullResult != null;</div><div class=\"line\">                    pullCallback.onSuccess(pullResult);</div><div class=\"line\">                &#125; catch (Exception e) &#123;</div><div class=\"line\">                    pullCallback.onException(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                if (!responseFuture.isSendRequestOK()) &#123;</div><div class=\"line\">                    pullCallback.onException(new MQClientException(&quot;send request failed&quot;, responseFuture.getCause()));</div><div class=\"line\">                &#125; else if (responseFuture.isTimeout()) &#123;</div><div class=\"line\">                    pullCallback.onException(new MQClientException(&quot;wait response timeout &quot; + responseFuture.getTimeoutMillis() + &quot;ms&quot;,</div><div class=\"line\">                            responseFuture.getCause()));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    pullCallback.onException(new MQClientException(&quot;unknow reseaon&quot;, responseFuture.getCause()));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">public void invokeAsyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis,final InvokeCallback invokeCallback)</div><div class=\"line\">        throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException &#123;</div><div class=\"line\">    final int opaque = request.getOpaque();</div><div class=\"line\">    boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);</div><div class=\"line\">    if (acquired) &#123;</div><div class=\"line\">        final SemaphoreReleaseOnlyOnce once = new SemaphoreReleaseOnlyOnce(this.semaphoreAsync);</div><div class=\"line\"></div><div class=\"line\">        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, invokeCallback, once);</div><div class=\"line\">        this.responseTable.put(opaque, responseFuture);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            channel.writeAndFlush(request).addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void operationComplete(ChannelFuture f) throws Exception &#123;</div><div class=\"line\">                    if (f.isSuccess()) &#123;</div><div class=\"line\">                        responseFuture.setSendRequestOK(true);</div><div class=\"line\">                        return;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        responseFuture.setSendRequestOK(false);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    responseFuture.putResponse(null);</div><div class=\"line\">                    responseTable.remove(opaque);</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                    \t //执行回调函数InvokeCallback</div><div class=\"line\">                        responseFuture.executeInvokeCallback();</div><div class=\"line\">                    &#125; catch (Throwable e) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t....</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出是采用的异步模式，注册监听器，收到响应结果后调用回调函数InvokeCallback。而在InvokeCallback中调用了DefaultMQPushConsumerImpl中的PullCallback回调函数的onSuccess、onException，分别就返回成功结果和失败结果执行对应操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">PullCallback核心代码：  </div><div class=\"line\">@Override</div><div class=\"line\">public void onSuccess(PullResult pullResult) &#123;</div><div class=\"line\">\tswitch (pullResult.getPullStatus()) &#123;</div><div class=\"line\">\tcase FOUND:</div><div class=\"line\">\t\t...</div><div class=\"line\">\t\t//将拉取到的消息放入processQueue</div><div class=\"line\">\t    boolean dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</div><div class=\"line\">\t    //向消息服务consumeMessageService提交消息消费请求</div><div class=\"line\">\t    DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(//</div><div class=\"line\">\t            pullResult.getMsgFoundList(), //</div><div class=\"line\">\t            processQueue, //</div><div class=\"line\">\t            pullRequest.getMessageQueue(), //</div><div class=\"line\">\t            dispathToConsume);</div><div class=\"line\">...</div><div class=\"line\">\t</div><div class=\"line\">\t</div><div class=\"line\">@Override</div><div class=\"line\">public void onException(Throwable e) &#123;</div><div class=\"line\">    if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\">        log.warn(&quot;execute the pull request exception&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//提交到线程池，稍后执行</div><div class=\"line\">    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, PullTimeDelayMillsWhenException);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-消息消费服务-ConsumeMessageService\"><a href=\"#3-2-消息消费服务-ConsumeMessageService\" class=\"headerlink\" title=\"3.2 消息消费服务-ConsumeMessageService\"></a>3.2 消息消费服务-ConsumeMessageService</h2><p>Pull消息拉取服务拉取消息成功之后，向ConsumeMessageService提交消息消费请求，由后者完成具体的消费过程。具体逻辑在下一篇文章中讲解。 </p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/11/17/RocketMQ源码学习之四-PushConsumer/\">http://xiajunhust.github.io/2016/11/17/RocketMQ源码学习之四-PushConsumer/</a></p>\n","excerpt":"<p>本文主要讲解RocketMQ的push消息消费者的实现原理。</p>\n<h1 id=\"1-RocketMQ的两种消息消费者\"><a href=\"#1-RocketMQ的两种消息消费者\" class=\"headerlink\" title=\"1 RocketMQ的两种消息消费者\"></a>1 RocketMQ的两种消息消费者</h1><p>RocketMQ支持两种形式的消息消费者：  </p>\n<ul>\n<li>Push Consumer<br>通常是应用向Consumer对象注册一个Listener，一旦收到消息，Consumer对象立即回调Listener接口方法。底层采用的是Pull长轮询拉取消息的方式。</li>\n<li>Pull Consumer<br>应用通常主动调用Consumer的拉消息方法从Broker拉消息，主动权由应用控制。</li>\n</ul>\n<h1 id=\"2-Push-Consumer的一个demo\"><a href=\"#2-Push-Consumer的一个demo\" class=\"headerlink\" title=\"2 Push Consumer的一个demo\"></a>2 Push Consumer的一个demo</h1>","more":"<p>demo：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Consumer2 &#123;</div><div class=\"line\">  public static void main(String[] args) throws InterruptedException, MQClientException &#123;</div><div class=\"line\">    DefaultMQPushConsumer</div><div class=\"line\">        consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;);</div><div class=\"line\">    consumer.setVipChannelEnabled(false);</div><div class=\"line\">    consumer.setNamesrvAddr(Constants.hostIpStr + &quot;:9876&quot;);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</div><div class=\"line\">     * 如果非第一次启动，那么按照上次消费的位置继续消费</div><div class=\"line\">     */</div><div class=\"line\">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</div><div class=\"line\"></div><div class=\"line\">    consumer.subscribe(&quot;TopicTest2&quot;, &quot;*&quot;);</div><div class=\"line\"></div><div class=\"line\">    consumer.registerMessageListener(new MessageListenerOrderly() &#123;</div><div class=\"line\"></div><div class=\"line\">      Random random = new Random();</div><div class=\"line\"></div><div class=\"line\">      public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) &#123;</div><div class=\"line\">        context.setAutoCommit(true);</div><div class=\"line\">        System.out.print(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; );</div><div class=\"line\">        for (MessageExt msg: msgs) &#123;</div><div class=\"line\">          System.out.println(msg + &quot;, content:&quot; + new String(msg.getBody()));</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">          //模拟业务逻辑处理中...</div><div class=\"line\">          TimeUnit.SECONDS.sleep(random.nextInt(10));</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">          e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return ConsumeOrderlyStatus.SUCCESS;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    consumer.start();</div><div class=\"line\"></div><div class=\"line\">    System.out.println(&quot;Consumer2 Started.&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">consumeMessageThread_2 Receive New Messages: MessageExt [queueId=0, storeSize=209, queueOffset=30, sysFlag=0, bornTimestamp=1479262699041, bornHost=/172.17.8.240:59605, storeTimestamp=1479262699053, storeHost=/172.17.8.240:10911, msgId=AC1108F000002A9F000000000000246D, commitLogOffset=9325, bodyCRC=2087030154, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest2, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=31, KEYS=KEY0, UNIQ_KEY=AC1108F00B4E1218025C4F757A200000, WAIT=true, TAGS=TagA&#125;, body=36]], content:2016-11-16 10:18:18 Hello RocketMQ 0</div><div class=\"line\">ConsumeMessageThread_2 Receive New Messages: MessageExt [queueId=0, storeSize=209, queueOffset=31, sysFlag=0, bornTimestamp=1479262699062, bornHost=/172.17.8.240:59605, storeTimestamp=1479262699063, storeHost=/172.17.8.240:10911, msgId=AC1108F000002A9F000000000000253E, commitLogOffset=9534, bodyCRC=191020316, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=TopicTest2, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=32, KEYS=KEY1, UNIQ_KEY=AC1108F00B4E1218025C4F757A360001, WAIT=true, TAGS=TagB&#125;, body=36]], content:2016-11-16 10:18:18 Hello RocketMQ 1</div></pre></td></tr></table></figure>\n<h1 id=\"3-Push消费方式原理分析\"><a href=\"#3-Push消费方式原理分析\" class=\"headerlink\" title=\"3 Push消费方式原理分析\"></a>3 Push消费方式原理分析</h1><h2 id=\"3-1-消费者启动\"><a href=\"#3-1-消费者启动\" class=\"headerlink\" title=\"3.1 消费者启动\"></a>3.1 消费者启动</h2><p>Push消费方式-消费者启动过程序列图如下：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-4-2.jpg\" alt=\"Push消费者启动序列图\"></p>\n<h3 id=\"3-1-1-设置属性\"><a href=\"#3-1-1-设置属性\" class=\"headerlink\" title=\"3.1.1 设置属性\"></a>3.1.1 设置属性</h3><p>NamesrvAddr<br>ConsumeFromWhere-第一次启动从队列头部还是尾部开始消费<br>订阅的topic以及tag  </p>\n<h3 id=\"3-1-2-监听器注册\"><a href=\"#3-1-2-监听器注册\" class=\"headerlink\" title=\"3.1.2 监听器注册\"></a>3.1.2 监听器注册</h3><p>这里监听器有2种类型：<br>MessageListenerOrderly-顺序消费消息<br>MessageListenerConcurrently-并发消费消息  </p>\n<h3 id=\"3-1-3-订阅配置拷贝\"><a href=\"#3-1-3-订阅配置拷贝\" class=\"headerlink\" title=\"3.1.3 订阅配置拷贝\"></a>3.1.3 订阅配置拷贝</h3><p>将订阅关系设置到rebalanceImpl的subscriptionInner中。</p>\n<h3 id=\"3-1-4-创建并加载OffsetStore实例\"><a href=\"#3-1-4-创建并加载OffsetStore实例\" class=\"headerlink\" title=\"3.1.4 创建并加载OffsetStore实例\"></a>3.1.4 创建并加载OffsetStore实例</h3><p>OffsetStore保存了消息消费的进度。会依据MessageModel来创建不同类型的实例：<br>BROADCASTING-LocalFileOffsetStore<br>CLUSTERING-RemoteBrokerOffsetStore</p>\n<h3 id=\"3-1-5-ConsumeMessageService实例创建\"><a href=\"#3-1-5-ConsumeMessageService实例创建\" class=\"headerlink\" title=\"3.1.5 ConsumeMessageService实例创建\"></a>3.1.5 ConsumeMessageService实例创建</h3><p>会依据监听器的类型分别创建对应的ConsumeMessageService实例，ConsumeMessageService负责完成具体的消息消费：<br>顺序消费-ConsumeMessageOrderlyService<br>并发消费-ConsumeMessageConcurrentlyService<br>后面会做详细介绍。</p>\n<h3 id=\"3-1-6-MQClientInstance启动\"><a href=\"#3-1-6-MQClientInstance启动\" class=\"headerlink\" title=\"3.1.6 MQClientInstance启动\"></a>3.1.6 MQClientInstance启动</h3><p>这一步非常重要：启动了消息拉取服务PullMessageService，拉取消息供ConsumeMessageService消费。 </p>\n<h2 id=\"3-2-Pull长轮询拉取消息消费实现原理\"><a href=\"#3-2-Pull长轮询拉取消息消费实现原理\" class=\"headerlink\" title=\"3.2 Pull长轮询拉取消息消费实现原理\"></a>3.2 Pull长轮询拉取消息消费实现原理</h2><p>整个Pull长轮询拉取消息消费执行序列图如下：<br><img src=\"http://o8sltkx20.bkt.clouddn.com/rocketmq-sourcecode-4-4.jpg\" alt=\"Pull长轮询拉取消息消费执行序列图\"></p>\n<p>源码分析：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">MQClientInstance.start</div><div class=\"line\"></div><div class=\"line\">public void start() throws MQClientException &#123;</div><div class=\"line\"></div><div class=\"line\">    synchronized (this) &#123;</div><div class=\"line\">        switch (this.serviceState) &#123;</div><div class=\"line\">            case CREATE_JUST:</div><div class=\"line\">                this.serviceState = ServiceState.START_FAILED;</div><div class=\"line\">                // If not specified,looking address from name server</div><div class=\"line\">                if (null == this.clientConfig.getNamesrvAddr()) &#123;</div><div class=\"line\">                    this.clientConfig.setNamesrvAddr(this.mQClientAPIImpl.fetchNameServerAddr());</div><div class=\"line\">                &#125;</div><div class=\"line\">                // Start request-response channel</div><div class=\"line\">                this.mQClientAPIImpl.start();</div><div class=\"line\">                // Start various schedule tasks</div><div class=\"line\">                this.startScheduledTask();</div><div class=\"line\">                // Start pull service</div><div class=\"line\">                this.pullMessageService.start();</div><div class=\"line\">                // Start rebalance service</div><div class=\"line\">                this.rebalanceService.start();</div><div class=\"line\">                // Start push service</div><div class=\"line\">                this.defaultMQProducer.getDefaultMQProducerImpl().start(false);</div><div class=\"line\">                log.info(&quot;the client factory [&#123;&#125;] start OK&quot;, this.clientId);</div><div class=\"line\">                this.serviceState = ServiceState.RUNNING;</div><div class=\"line\">                break;</div><div class=\"line\">            case RUNNING:</div><div class=\"line\">                break;</div><div class=\"line\">            case SHUTDOWN_ALREADY:</div><div class=\"line\">                break;</div><div class=\"line\">            case START_FAILED:</div><div class=\"line\">                throw new MQClientException(&quot;The Factory object[&quot; + this.getClientId() + &quot;] has been created before, and failed.&quot;, null);</div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里面非常重要的异步就是消息拉取服务PullMessageService的启动，PullMessageService通过长轮训拉取消息，然后交给ConsumeMessageService完成具体的消息消费。<br>我们看下PullMessageService启动做了什么事情，启动了一个线程，run函数中核心代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\">    while (!this.isStoped()) &#123;</div><div class=\"line\">    \t ...</div><div class=\"line\">    \t //从队列中获取PullRequest，调用拉取消息方法</div><div class=\"line\">        PullRequest pullRequest = this.pullRequestQueue.take();</div><div class=\"line\">        if (pullRequest != null) &#123;</div><div class=\"line\">            this.pullMessage(pullRequest);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//拉取消息</div><div class=\"line\">private void pullMessage(final PullRequest pullRequest) &#123;</div><div class=\"line\">\t//获取消费者，调用消费者的消息拉取方法</div><div class=\"line\">    final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</div><div class=\"line\">    if (consumer != null) &#123;</div><div class=\"line\">        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</div><div class=\"line\">        impl.pullMessage(pullRequest);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        log.warn(&quot;No matched consumer for the PullRequest &#123;&#125;, drop it&quot;, pullRequest);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里对应的消费者是DefaultMQPushConsumerImpl，我们接下来看DefaultMQPushConsumerImpl的pullMessage方法。<br>（1）流控，如果超出流量限制则，或者broker锁定失败，将PullRequest提交到PullMessageService的单线程线程池。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) &#123;</div><div class=\"line\">    this.scheduledExecutorService.schedule(new Runnable() &#123;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            PullMessageService.this.executePullRequestImmediately(pullRequest);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;, timeDelay, TimeUnit.MILLISECONDS);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public void executePullRequestImmediately(final PullRequest pullRequest) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">    \t //将拉取请求放入阻塞队列</div><div class=\"line\">        this.pullRequestQueue.put(pullRequest);</div><div class=\"line\">    &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">        log.error(&quot;executePullRequestImmediately pullRequestQueue.put&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）启动拉取PullAPIWrapper.pullKernelImpl</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.pullAPIWrapper.pullKernelImpl(//</div><div class=\"line\">        pullRequest.getMessageQueue(), // 1</div><div class=\"line\">        subExpression, // 2</div><div class=\"line\">        subscriptionData.getSubVersion(), // 3</div><div class=\"line\">        pullRequest.getNextOffset(), // 4</div><div class=\"line\">        this.defaultMQPushConsumer.getPullBatchSize(), // 5</div><div class=\"line\">        sysFlag, // 6</div><div class=\"line\">        commitOffsetValue, // 7</div><div class=\"line\">        BrokerSuspendMaxTimeMillis, // 8</div><div class=\"line\">        ConsumerTimeoutMillisWhenSuspend, // 9</div><div class=\"line\">        CommunicationMode.ASYNC, // 10</div><div class=\"line\">        pullCallback// 11</div><div class=\"line\">);</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\">public PullResult pullKernelImpl(//</div><div class=\"line\">                                 final MessageQueue mq,// 1</div><div class=\"line\">                                 final String subExpression,// 2</div><div class=\"line\">                                 final long subVersion,// 3</div><div class=\"line\">                                 final long offset,// 4</div><div class=\"line\">                                 final int maxNums,// 5</div><div class=\"line\">                                 final int sysFlag,// 6</div><div class=\"line\">                                 final long commitOffset,// 7</div><div class=\"line\">                                 final long brokerSuspendMaxTimeMillis,// 8</div><div class=\"line\">                                 final long timeoutMillis,// 9</div><div class=\"line\">                                 final CommunicationMode communicationMode,// 10</div><div class=\"line\">                                 final PullCallback pullCallback// 11</div><div class=\"line\">) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\">    FindBrokerResult findBrokerResult =</div><div class=\"line\">            this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</div><div class=\"line\">                    this.recalculatePullFromWhichNode(mq), false);</div><div class=\"line\">    if (null == findBrokerResult) &#123;</div><div class=\"line\">        this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</div><div class=\"line\">        findBrokerResult =</div><div class=\"line\">                this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</div><div class=\"line\">                        this.recalculatePullFromWhichNode(mq), false);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (findBrokerResult != null) &#123;</div><div class=\"line\">        int sysFlagInner = sysFlag;</div><div class=\"line\"></div><div class=\"line\">        if (findBrokerResult.isSlave()) &#123;</div><div class=\"line\">            sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();</div><div class=\"line\">        requestHeader.setConsumerGroup(this.consumerGroup);</div><div class=\"line\">        requestHeader.setTopic(mq.getTopic());</div><div class=\"line\">        requestHeader.setQueueId(mq.getQueueId());</div><div class=\"line\">        requestHeader.setQueueOffset(offset);</div><div class=\"line\">        requestHeader.setMaxMsgNums(maxNums);</div><div class=\"line\">        requestHeader.setSysFlag(sysFlagInner);</div><div class=\"line\">        requestHeader.setCommitOffset(commitOffset);</div><div class=\"line\">        requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);</div><div class=\"line\">        requestHeader.setSubscription(subExpression);</div><div class=\"line\">        requestHeader.setSubVersion(subVersion);</div><div class=\"line\"></div><div class=\"line\">        String brokerAddr = findBrokerResult.getBrokerAddr();</div><div class=\"line\">        if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) &#123;</div><div class=\"line\">            brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage(//</div><div class=\"line\">                brokerAddr,//</div><div class=\"line\">                requestHeader,//</div><div class=\"line\">                timeoutMillis,//</div><div class=\"line\">                communicationMode,//这里传的是ASYNC</div><div class=\"line\">                pullCallback);</div><div class=\"line\"></div><div class=\"line\">        return pullResult;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    throw new MQClientException(&quot;The broker[&quot; + mq.getBrokerName() + &quot;] not exist&quot;, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来调到底层通信层NettyRemotingClient.invokeAsyncImpl:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void pullMessageAsync(//</div><div class=\"line\">                              final String addr, // 1</div><div class=\"line\">                              final RemotingCommand request, //</div><div class=\"line\">                              final long timeoutMillis, //</div><div class=\"line\">                              final PullCallback pullCallback//</div><div class=\"line\">) throws RemotingException, InterruptedException &#123;</div><div class=\"line\">    this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void operationComplete(ResponseFuture responseFuture) &#123;</div><div class=\"line\">            RemotingCommand response = responseFuture.getResponseCommand();</div><div class=\"line\">            if (response != null) &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    PullResult pullResult = MQClientAPIImpl.this.processPullResponse(response);</div><div class=\"line\">                    assert pullResult != null;</div><div class=\"line\">                    pullCallback.onSuccess(pullResult);</div><div class=\"line\">                &#125; catch (Exception e) &#123;</div><div class=\"line\">                    pullCallback.onException(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                if (!responseFuture.isSendRequestOK()) &#123;</div><div class=\"line\">                    pullCallback.onException(new MQClientException(&quot;send request failed&quot;, responseFuture.getCause()));</div><div class=\"line\">                &#125; else if (responseFuture.isTimeout()) &#123;</div><div class=\"line\">                    pullCallback.onException(new MQClientException(&quot;wait response timeout &quot; + responseFuture.getTimeoutMillis() + &quot;ms&quot;,</div><div class=\"line\">                            responseFuture.getCause()));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    pullCallback.onException(new MQClientException(&quot;unknow reseaon&quot;, responseFuture.getCause()));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\">public void invokeAsyncImpl(final Channel channel, final RemotingCommand request, final long timeoutMillis,final InvokeCallback invokeCallback)</div><div class=\"line\">        throws InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException &#123;</div><div class=\"line\">    final int opaque = request.getOpaque();</div><div class=\"line\">    boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);</div><div class=\"line\">    if (acquired) &#123;</div><div class=\"line\">        final SemaphoreReleaseOnlyOnce once = new SemaphoreReleaseOnlyOnce(this.semaphoreAsync);</div><div class=\"line\"></div><div class=\"line\">        final ResponseFuture responseFuture = new ResponseFuture(opaque, timeoutMillis, invokeCallback, once);</div><div class=\"line\">        this.responseTable.put(opaque, responseFuture);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            channel.writeAndFlush(request).addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void operationComplete(ChannelFuture f) throws Exception &#123;</div><div class=\"line\">                    if (f.isSuccess()) &#123;</div><div class=\"line\">                        responseFuture.setSendRequestOK(true);</div><div class=\"line\">                        return;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        responseFuture.setSendRequestOK(false);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    responseFuture.putResponse(null);</div><div class=\"line\">                    responseTable.remove(opaque);</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                    \t //执行回调函数InvokeCallback</div><div class=\"line\">                        responseFuture.executeInvokeCallback();</div><div class=\"line\">                    &#125; catch (Throwable e) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t....</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出是采用的异步模式，注册监听器，收到响应结果后调用回调函数InvokeCallback。而在InvokeCallback中调用了DefaultMQPushConsumerImpl中的PullCallback回调函数的onSuccess、onException，分别就返回成功结果和失败结果执行对应操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">PullCallback核心代码：  </div><div class=\"line\">@Override</div><div class=\"line\">public void onSuccess(PullResult pullResult) &#123;</div><div class=\"line\">\tswitch (pullResult.getPullStatus()) &#123;</div><div class=\"line\">\tcase FOUND:</div><div class=\"line\">\t\t...</div><div class=\"line\">\t\t//将拉取到的消息放入processQueue</div><div class=\"line\">\t    boolean dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</div><div class=\"line\">\t    //向消息服务consumeMessageService提交消息消费请求</div><div class=\"line\">\t    DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(//</div><div class=\"line\">\t            pullResult.getMsgFoundList(), //</div><div class=\"line\">\t            processQueue, //</div><div class=\"line\">\t            pullRequest.getMessageQueue(), //</div><div class=\"line\">\t            dispathToConsume);</div><div class=\"line\">...</div><div class=\"line\">\t</div><div class=\"line\">\t</div><div class=\"line\">@Override</div><div class=\"line\">public void onException(Throwable e) &#123;</div><div class=\"line\">    if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\">        log.warn(&quot;execute the pull request exception&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//提交到线程池，稍后执行</div><div class=\"line\">    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, PullTimeDelayMillsWhenException);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-消息消费服务-ConsumeMessageService\"><a href=\"#3-2-消息消费服务-ConsumeMessageService\" class=\"headerlink\" title=\"3.2 消息消费服务-ConsumeMessageService\"></a>3.2 消息消费服务-ConsumeMessageService</h2><p>Pull消息拉取服务拉取消息成功之后，向ConsumeMessageService提交消息消费请求，由后者完成具体的消费过程。具体逻辑在下一篇文章中讲解。 </p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/11/17/RocketMQ源码学习之四-PushConsumer/\">http://xiajunhust.github.io/2016/11/17/RocketMQ源码学习之四-PushConsumer/</a></p>"},{"title":"《Soft skills》读书笔记（一）-这本书与其他书籍有何不同","date":"2016-07-16T09:52:57.000Z","_content":"\n偶然间在网上看到这本书《Soft Skills-The software developer's life manual》，目前只有英文版，中文版还在预售。书名翻译成中文是：[亚马逊](https://www.amazon.com/Soft-Skills-software-developers-manual/dp/1617292397)上是五星好评。这本书与其他书籍有明显区别，那就是他不是讲如何去更好的写代码，而是谈的是如何做一个更优秀的软件开发者：关于规划职业生涯、达到目标以及享受生活的乐趣。这本书不是关于我们能做哪些事情，而是关于我们本身：职业生涯、生活、身体、心智以及灵魂。作者认为作为一个程序员，远不仅仅是写代码，还有众多 其他事情。\n\n<!-- more -->\n\n作者认为如果我们想成为更优秀的程序员，那么应该把注意力集中在整个生涯中，而不仅仅是生命中的一段或者是几段时间。\n\n本书氛围七部分，每一章聚焦程序员生活中的一个方面。将其分类，可以分为：职业生涯、心智、身体、心灵。\n\n本书从职业生涯开始谈起，作者发现很少部分程序员会真正花大的精力去积极规划自己的职业生涯。在第一章中，作者将会帮助大家补救这个问题，会教我们如何积极规划职业生涯以达到自己的目标，不管这个目标是在企业中扶摇直上，还是自己从事咨询工作抑甚至是成为企业家打造自己的产品。这是哪个方面作者都谈到了。作者面试过无数程序员，提供了大量反面案例，我们能从中学习并少走很多弯路。作者同时也会提到职业生涯中的一些重要技能，比如写一份耀眼的简历、面试技巧、远程办公以及从其他优秀的人身上学习他们的优点。\n\n在第二章-营销自己，作者谈到的话题是推销自己。大多数程序员看到这个词恐怕没有什么好感，但是当看完这个章节后，会对这个词有全新的认识并且认识到它的重要性。每个人都是推销者，在本章中作者将会教大家如何成为更好的推销者以及明确自己在推销的是什么。同时给出了一些实际的建议：如何打造个人品牌、如何建立成功的博客、以及通过演讲、写作等一系列方式提高自己的名声。有了这些技巧，才能去获得更好的结果。\n\n第三章开始讲心智：学习。学习是程序员生活中最重要的一方面。学会如何学习以及如何自学是最有价值的技能之一。因为有了自学能力，我们就有可能去做任何事情。\n\n第四章继续讲心智：生产率-如何变得更有生产率。生产率是很多人拼搏想获取的，同时也是通往成功之路的最大的绊脚石之一。如果不能克服拖延症、混乱状态以及懒惰，将寸步难行。\n\n在第五章-理财，作者会谈到一个更重要的并且平时经常被完全忽略的一个话题：个人理财。也许一个人能够成为世界上最成功的程序员，但是如果不能有效的管理好自己的财产，某一天可能会沦落街头。本章作者将会带领我们遨游在经济、个人理财的世界并且教授一些在做出明智的理财决定所必须的基础知识。作者从18岁开始是一个专业的房地产投资者，在本书中这个话题不会太深入，因为要讲的深入足以写整整一本书，但是会覆盖以下基础知识：管理自己的收入、股市是如何运作的、怎么做房地产投资以及避免债务。此外，作为会分享自己如何运用这些知识并在33岁退休的故事。\n\n接下来进入轻松娱乐的部分，焦点在自己的身体。第六章，健身，作者将会谈如何减肥、增肌以及塑形。大多数程序员存在肥胖、健康状态差的情况，并且没有动力做上述几件事情。作者作为在健身运动方面非常成功的程序员，将为我们分享这方面的必备知识。\n\n第七章，精神。作者在本章中会针对影响我们情感状态和态度的方面给出实际的建议。主要聚焦在如何保持积极的态度。同时也会覆盖爱情和友情，这对程序员来讲恐怕是比较难的领域了。最后会给出一个私人成功书单。\n","source":"_posts/《Soft-skills》读书笔记（一）-这本书与其他书籍有何不同.md","raw":"---\ntitle: 《Soft skills》读书笔记（一）-这本书与其他书籍有何不同\ndate: 2016-07-16 17:52:57\ntags: 思考&读书笔记\n---\n\n偶然间在网上看到这本书《Soft Skills-The software developer's life manual》，目前只有英文版，中文版还在预售。书名翻译成中文是：[亚马逊](https://www.amazon.com/Soft-Skills-software-developers-manual/dp/1617292397)上是五星好评。这本书与其他书籍有明显区别，那就是他不是讲如何去更好的写代码，而是谈的是如何做一个更优秀的软件开发者：关于规划职业生涯、达到目标以及享受生活的乐趣。这本书不是关于我们能做哪些事情，而是关于我们本身：职业生涯、生活、身体、心智以及灵魂。作者认为作为一个程序员，远不仅仅是写代码，还有众多 其他事情。\n\n<!-- more -->\n\n作者认为如果我们想成为更优秀的程序员，那么应该把注意力集中在整个生涯中，而不仅仅是生命中的一段或者是几段时间。\n\n本书氛围七部分，每一章聚焦程序员生活中的一个方面。将其分类，可以分为：职业生涯、心智、身体、心灵。\n\n本书从职业生涯开始谈起，作者发现很少部分程序员会真正花大的精力去积极规划自己的职业生涯。在第一章中，作者将会帮助大家补救这个问题，会教我们如何积极规划职业生涯以达到自己的目标，不管这个目标是在企业中扶摇直上，还是自己从事咨询工作抑甚至是成为企业家打造自己的产品。这是哪个方面作者都谈到了。作者面试过无数程序员，提供了大量反面案例，我们能从中学习并少走很多弯路。作者同时也会提到职业生涯中的一些重要技能，比如写一份耀眼的简历、面试技巧、远程办公以及从其他优秀的人身上学习他们的优点。\n\n在第二章-营销自己，作者谈到的话题是推销自己。大多数程序员看到这个词恐怕没有什么好感，但是当看完这个章节后，会对这个词有全新的认识并且认识到它的重要性。每个人都是推销者，在本章中作者将会教大家如何成为更好的推销者以及明确自己在推销的是什么。同时给出了一些实际的建议：如何打造个人品牌、如何建立成功的博客、以及通过演讲、写作等一系列方式提高自己的名声。有了这些技巧，才能去获得更好的结果。\n\n第三章开始讲心智：学习。学习是程序员生活中最重要的一方面。学会如何学习以及如何自学是最有价值的技能之一。因为有了自学能力，我们就有可能去做任何事情。\n\n第四章继续讲心智：生产率-如何变得更有生产率。生产率是很多人拼搏想获取的，同时也是通往成功之路的最大的绊脚石之一。如果不能克服拖延症、混乱状态以及懒惰，将寸步难行。\n\n在第五章-理财，作者会谈到一个更重要的并且平时经常被完全忽略的一个话题：个人理财。也许一个人能够成为世界上最成功的程序员，但是如果不能有效的管理好自己的财产，某一天可能会沦落街头。本章作者将会带领我们遨游在经济、个人理财的世界并且教授一些在做出明智的理财决定所必须的基础知识。作者从18岁开始是一个专业的房地产投资者，在本书中这个话题不会太深入，因为要讲的深入足以写整整一本书，但是会覆盖以下基础知识：管理自己的收入、股市是如何运作的、怎么做房地产投资以及避免债务。此外，作为会分享自己如何运用这些知识并在33岁退休的故事。\n\n接下来进入轻松娱乐的部分，焦点在自己的身体。第六章，健身，作者将会谈如何减肥、增肌以及塑形。大多数程序员存在肥胖、健康状态差的情况，并且没有动力做上述几件事情。作者作为在健身运动方面非常成功的程序员，将为我们分享这方面的必备知识。\n\n第七章，精神。作者在本章中会针对影响我们情感状态和态度的方面给出实际的建议。主要聚焦在如何保持积极的态度。同时也会覆盖爱情和友情，这对程序员来讲恐怕是比较难的领域了。最后会给出一个私人成功书单。\n","slug":"《Soft-skills》读书笔记（一）-这本书与其他书籍有何不同","published":1,"updated":"2016-09-07T08:02:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsc2000l2hwfay2f6kg5","content":"<p>偶然间在网上看到这本书《Soft Skills-The software developer’s life manual》，目前只有英文版，中文版还在预售。书名翻译成中文是：<a href=\"https://www.amazon.com/Soft-Skills-software-developers-manual/dp/1617292397\" target=\"_blank\" rel=\"external\">亚马逊</a>上是五星好评。这本书与其他书籍有明显区别，那就是他不是讲如何去更好的写代码，而是谈的是如何做一个更优秀的软件开发者：关于规划职业生涯、达到目标以及享受生活的乐趣。这本书不是关于我们能做哪些事情，而是关于我们本身：职业生涯、生活、身体、心智以及灵魂。作者认为作为一个程序员，远不仅仅是写代码，还有众多 其他事情。</p>\n<a id=\"more\"></a>\n<p>作者认为如果我们想成为更优秀的程序员，那么应该把注意力集中在整个生涯中，而不仅仅是生命中的一段或者是几段时间。</p>\n<p>本书氛围七部分，每一章聚焦程序员生活中的一个方面。将其分类，可以分为：职业生涯、心智、身体、心灵。</p>\n<p>本书从职业生涯开始谈起，作者发现很少部分程序员会真正花大的精力去积极规划自己的职业生涯。在第一章中，作者将会帮助大家补救这个问题，会教我们如何积极规划职业生涯以达到自己的目标，不管这个目标是在企业中扶摇直上，还是自己从事咨询工作抑甚至是成为企业家打造自己的产品。这是哪个方面作者都谈到了。作者面试过无数程序员，提供了大量反面案例，我们能从中学习并少走很多弯路。作者同时也会提到职业生涯中的一些重要技能，比如写一份耀眼的简历、面试技巧、远程办公以及从其他优秀的人身上学习他们的优点。</p>\n<p>在第二章-营销自己，作者谈到的话题是推销自己。大多数程序员看到这个词恐怕没有什么好感，但是当看完这个章节后，会对这个词有全新的认识并且认识到它的重要性。每个人都是推销者，在本章中作者将会教大家如何成为更好的推销者以及明确自己在推销的是什么。同时给出了一些实际的建议：如何打造个人品牌、如何建立成功的博客、以及通过演讲、写作等一系列方式提高自己的名声。有了这些技巧，才能去获得更好的结果。</p>\n<p>第三章开始讲心智：学习。学习是程序员生活中最重要的一方面。学会如何学习以及如何自学是最有价值的技能之一。因为有了自学能力，我们就有可能去做任何事情。</p>\n<p>第四章继续讲心智：生产率-如何变得更有生产率。生产率是很多人拼搏想获取的，同时也是通往成功之路的最大的绊脚石之一。如果不能克服拖延症、混乱状态以及懒惰，将寸步难行。</p>\n<p>在第五章-理财，作者会谈到一个更重要的并且平时经常被完全忽略的一个话题：个人理财。也许一个人能够成为世界上最成功的程序员，但是如果不能有效的管理好自己的财产，某一天可能会沦落街头。本章作者将会带领我们遨游在经济、个人理财的世界并且教授一些在做出明智的理财决定所必须的基础知识。作者从18岁开始是一个专业的房地产投资者，在本书中这个话题不会太深入，因为要讲的深入足以写整整一本书，但是会覆盖以下基础知识：管理自己的收入、股市是如何运作的、怎么做房地产投资以及避免债务。此外，作为会分享自己如何运用这些知识并在33岁退休的故事。</p>\n<p>接下来进入轻松娱乐的部分，焦点在自己的身体。第六章，健身，作者将会谈如何减肥、增肌以及塑形。大多数程序员存在肥胖、健康状态差的情况，并且没有动力做上述几件事情。作者作为在健身运动方面非常成功的程序员，将为我们分享这方面的必备知识。</p>\n<p>第七章，精神。作者在本章中会针对影响我们情感状态和态度的方面给出实际的建议。主要聚焦在如何保持积极的态度。同时也会覆盖爱情和友情，这对程序员来讲恐怕是比较难的领域了。最后会给出一个私人成功书单。</p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/07/16/《Soft-skills》读书笔记（一）-这本书与其他书籍有何不同/\">http://xiajunhust.github.io/2016/07/16/《Soft-skills》读书笔记（一）-这本书与其他书籍有何不同/</a></p>\n","excerpt":"<p>偶然间在网上看到这本书《Soft Skills-The software developer’s life manual》，目前只有英文版，中文版还在预售。书名翻译成中文是：<a href=\"https://www.amazon.com/Soft-Skills-software-developers-manual/dp/1617292397\">亚马逊</a>上是五星好评。这本书与其他书籍有明显区别，那就是他不是讲如何去更好的写代码，而是谈的是如何做一个更优秀的软件开发者：关于规划职业生涯、达到目标以及享受生活的乐趣。这本书不是关于我们能做哪些事情，而是关于我们本身：职业生涯、生活、身体、心智以及灵魂。作者认为作为一个程序员，远不仅仅是写代码，还有众多 其他事情。</p>","more":"<p>作者认为如果我们想成为更优秀的程序员，那么应该把注意力集中在整个生涯中，而不仅仅是生命中的一段或者是几段时间。</p>\n<p>本书氛围七部分，每一章聚焦程序员生活中的一个方面。将其分类，可以分为：职业生涯、心智、身体、心灵。</p>\n<p>本书从职业生涯开始谈起，作者发现很少部分程序员会真正花大的精力去积极规划自己的职业生涯。在第一章中，作者将会帮助大家补救这个问题，会教我们如何积极规划职业生涯以达到自己的目标，不管这个目标是在企业中扶摇直上，还是自己从事咨询工作抑甚至是成为企业家打造自己的产品。这是哪个方面作者都谈到了。作者面试过无数程序员，提供了大量反面案例，我们能从中学习并少走很多弯路。作者同时也会提到职业生涯中的一些重要技能，比如写一份耀眼的简历、面试技巧、远程办公以及从其他优秀的人身上学习他们的优点。</p>\n<p>在第二章-营销自己，作者谈到的话题是推销自己。大多数程序员看到这个词恐怕没有什么好感，但是当看完这个章节后，会对这个词有全新的认识并且认识到它的重要性。每个人都是推销者，在本章中作者将会教大家如何成为更好的推销者以及明确自己在推销的是什么。同时给出了一些实际的建议：如何打造个人品牌、如何建立成功的博客、以及通过演讲、写作等一系列方式提高自己的名声。有了这些技巧，才能去获得更好的结果。</p>\n<p>第三章开始讲心智：学习。学习是程序员生活中最重要的一方面。学会如何学习以及如何自学是最有价值的技能之一。因为有了自学能力，我们就有可能去做任何事情。</p>\n<p>第四章继续讲心智：生产率-如何变得更有生产率。生产率是很多人拼搏想获取的，同时也是通往成功之路的最大的绊脚石之一。如果不能克服拖延症、混乱状态以及懒惰，将寸步难行。</p>\n<p>在第五章-理财，作者会谈到一个更重要的并且平时经常被完全忽略的一个话题：个人理财。也许一个人能够成为世界上最成功的程序员，但是如果不能有效的管理好自己的财产，某一天可能会沦落街头。本章作者将会带领我们遨游在经济、个人理财的世界并且教授一些在做出明智的理财决定所必须的基础知识。作者从18岁开始是一个专业的房地产投资者，在本书中这个话题不会太深入，因为要讲的深入足以写整整一本书，但是会覆盖以下基础知识：管理自己的收入、股市是如何运作的、怎么做房地产投资以及避免债务。此外，作为会分享自己如何运用这些知识并在33岁退休的故事。</p>\n<p>接下来进入轻松娱乐的部分，焦点在自己的身体。第六章，健身，作者将会谈如何减肥、增肌以及塑形。大多数程序员存在肥胖、健康状态差的情况，并且没有动力做上述几件事情。作者作为在健身运动方面非常成功的程序员，将为我们分享这方面的必备知识。</p>\n<p>第七章，精神。作者在本章中会针对影响我们情感状态和态度的方面给出实际的建议。主要聚焦在如何保持积极的态度。同时也会覆盖爱情和友情，这对程序员来讲恐怕是比较难的领域了。最后会给出一个私人成功书单。</p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/07/16/《Soft-skills》读书笔记（一）-这本书与其他书籍有何不同/\">http://xiajunhust.github.io/2016/07/16/《Soft-skills》读书笔记（一）-这本书与其他书籍有何不同/</a></p>"},{"title":"代码中的命名问题-命名太长了！","date":"2016-07-20T13:05:10.000Z","_content":"# 1 内容概要\n\n本文是一篇译文，翻译自：[Long Names Are Long](http://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/?from=timeline&isappinstalled=0)。主要介绍了编程过程中常见的命名过长的问题。\n\n# 2 正文内容\n## 2.1 选择一个好名字\n\n一个好名字需要具备以下两个特点：\n\n<!-- more -->\n\n- 含义清晰。一眼可以看出名字指代的含义。\n- 含义精确。能够从名字看出它不包含哪些含义。\n\n一个名字具备了以上2个特点之后，任何其他字符都是无用的。以下是我在编码过程中命名多得出的一些指导性准则。\n\n### 2.1.1 忽略掉表示变量或者参数类型的字符\n\n对于静态变量，使用者通常都知道变量的类型。方法体通常不会很长，这样，即便是需要通过查看变量定义进行推断的局部变量，也可以很容易得知变量类型。  \n考虑到这点，将类型作为变量名字的一部分是冗余的。我们抛弃掉Hungarian notation。\n\n```\n// Bad:\n\nString nameString;\nDockableModelessWindow dockableModelessWindow;\n\n// Better:\nString name;\nDockableModelessWindow window;\n```\n\n特别的，对于集合，使用复数名词更好，而不要用单独的一个表示集合的名词。\n\n```\n// Bad:\n\nList<DateTime> holidayDateList;\nMap<Employee, Role> employeeRoleHashMap;\n\n// Better:\nList<DateTime> holidays;\nMap<Employee, Role> employeeRoles;\n```\n\n这对于方法命名同样奏效。方法名称没必要体现参数类型-通过参数列表可以得知。\n\n```\n// Bad:\n\nmergeTableCells(List<TableCell> cells)\nsortEventsUsingComparator(List<Event> events,\n    Comparator<Event> comparator)\n\n// Better:\nmerge(List<TableCell> cells)\nsort(List<Event> events, Comparator<Event> comparator)\n```\n\n这将使得调用方法的代码可读性更好：\n\n```\nmergeTableCells(tableCells);\n\nsortEventsUsingComparator(events, comparator);\n```\n\n### 2.1.2 忽略掉会给命名带来歧义的字符\n\n有些人喜欢把所知道的关于变量或者方法的所有事情都添加到命名中去。记住，命名是一个标识符：它指向它被定义的地方。它不是读者可能想知道的关于这个变量的所有事情的一个完整目录。这部分事情由定义来完成。命名只是让读者能够跳转到定义处。  \n当我看到这样一个命名：recentlyUpdatedAnnualSalesBid，我脑海里会有这样的疑问：\n\n- 有不是最近更新的年销售额投标吗？\n- 有没更新过的最近的年销售额投标吗？\n- 等等\n\n```\n// Bad:\n\nfinalBattleMostDangerousBossMonster;\nweaklingFirstEncounterMonster;\n\n// Better:\nboss;\nfirstMonster;\n```\n\n### 2.1.3 忽略掉能够从上下文得知的信息的字符\n\n在这篇文章中，我能够使用“我”是因为读者能够看到这篇文章是由Bob Nystrom发布的。我不用再文章各处说明作者是Bob Nystrom。代码也是一样。方法或者变量都有各自的上下文，不需要再命名中重复上下文中的信息。\n\n```\n// Bad:\n\nclass AnnualHolidaySale {\n  int _annualSaleRebate;\n  void promoteHolidaySale() { ... }\n}\n\n// Better:\nclass AnnualHolidaySale {\n  int _rebate;\n  void promote() { ... }\n}\n```\n\n### 2.1.4 忽略掉无任何含义的字符\n\n在很多场景下，一些字符不携带任何有意义的信息，常见的如下：\ndata, state, amount, value, manager, engine, object, entity, instance。\n一个好的命名能够在读者的脑海中绘制一幅画像。”manager”并不会让读者得知这个变量或者方法做了什么事情。\n我们可以尝试着问自己一个问题：若移除掉这个词，标识符的含义是否和之前一样？如果是这样，这个词就是无意义的，可以移除。\n\n2.2 准则的实际应用\n\n为了说明上述准则在实际中是如何使用的，下面看一个例子：\n\n```\nclass DeliciousBelgianWaffleObject {\n\n  void garnishDeliciousBelgianWaffleWithStrawberryList(\n      List<Strawberry> strawberryList) { ... }\n}\n```\n\n既然参数类型我们已经能够从参数列表得知，因此将其移除：\n\n```\nclass DeliciousBelgianWaffleObject {\n\n    void garnishDeliciousBelgianWaffle(\n        List<Strawberry> strawberries) { ... }\n}\n```\n\n除非我们有其他口味的华夫饼，或者是其他国家的华夫饼，否则可以继续移除掉一部分字符：\n\n```\nclass WaffleObject {\n\n  void garnishWaffle(List<Strawberry> strawberries) { ... }\n}\n```\n\n既然方法是在类WaffleObject中，因此我们知道它要装饰的对象，因此修改如下：\n\n```\nclass WaffleObject {\n\n  void garnish(List<Strawberry> strawberries) { ... }\n}\n```\n\n程序中，任何事务都是以对象的形式存在，因此类名可以移除掉Object：\n\n```\nclass Waffle {\n\n  void garnish(List<Strawberry> strawberries) { ... }\n}\n```\n\n现在看看，是不是好多了。","source":"_posts/代码中的命名问题-命名太长了！.md","raw":"---\ntitle: 代码中的命名问题-命名太长了！\ndate: 2016-07-20 21:05:10\ntags: 代码设计\n---\n# 1 内容概要\n\n本文是一篇译文，翻译自：[Long Names Are Long](http://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/?from=timeline&isappinstalled=0)。主要介绍了编程过程中常见的命名过长的问题。\n\n# 2 正文内容\n## 2.1 选择一个好名字\n\n一个好名字需要具备以下两个特点：\n\n<!-- more -->\n\n- 含义清晰。一眼可以看出名字指代的含义。\n- 含义精确。能够从名字看出它不包含哪些含义。\n\n一个名字具备了以上2个特点之后，任何其他字符都是无用的。以下是我在编码过程中命名多得出的一些指导性准则。\n\n### 2.1.1 忽略掉表示变量或者参数类型的字符\n\n对于静态变量，使用者通常都知道变量的类型。方法体通常不会很长，这样，即便是需要通过查看变量定义进行推断的局部变量，也可以很容易得知变量类型。  \n考虑到这点，将类型作为变量名字的一部分是冗余的。我们抛弃掉Hungarian notation。\n\n```\n// Bad:\n\nString nameString;\nDockableModelessWindow dockableModelessWindow;\n\n// Better:\nString name;\nDockableModelessWindow window;\n```\n\n特别的，对于集合，使用复数名词更好，而不要用单独的一个表示集合的名词。\n\n```\n// Bad:\n\nList<DateTime> holidayDateList;\nMap<Employee, Role> employeeRoleHashMap;\n\n// Better:\nList<DateTime> holidays;\nMap<Employee, Role> employeeRoles;\n```\n\n这对于方法命名同样奏效。方法名称没必要体现参数类型-通过参数列表可以得知。\n\n```\n// Bad:\n\nmergeTableCells(List<TableCell> cells)\nsortEventsUsingComparator(List<Event> events,\n    Comparator<Event> comparator)\n\n// Better:\nmerge(List<TableCell> cells)\nsort(List<Event> events, Comparator<Event> comparator)\n```\n\n这将使得调用方法的代码可读性更好：\n\n```\nmergeTableCells(tableCells);\n\nsortEventsUsingComparator(events, comparator);\n```\n\n### 2.1.2 忽略掉会给命名带来歧义的字符\n\n有些人喜欢把所知道的关于变量或者方法的所有事情都添加到命名中去。记住，命名是一个标识符：它指向它被定义的地方。它不是读者可能想知道的关于这个变量的所有事情的一个完整目录。这部分事情由定义来完成。命名只是让读者能够跳转到定义处。  \n当我看到这样一个命名：recentlyUpdatedAnnualSalesBid，我脑海里会有这样的疑问：\n\n- 有不是最近更新的年销售额投标吗？\n- 有没更新过的最近的年销售额投标吗？\n- 等等\n\n```\n// Bad:\n\nfinalBattleMostDangerousBossMonster;\nweaklingFirstEncounterMonster;\n\n// Better:\nboss;\nfirstMonster;\n```\n\n### 2.1.3 忽略掉能够从上下文得知的信息的字符\n\n在这篇文章中，我能够使用“我”是因为读者能够看到这篇文章是由Bob Nystrom发布的。我不用再文章各处说明作者是Bob Nystrom。代码也是一样。方法或者变量都有各自的上下文，不需要再命名中重复上下文中的信息。\n\n```\n// Bad:\n\nclass AnnualHolidaySale {\n  int _annualSaleRebate;\n  void promoteHolidaySale() { ... }\n}\n\n// Better:\nclass AnnualHolidaySale {\n  int _rebate;\n  void promote() { ... }\n}\n```\n\n### 2.1.4 忽略掉无任何含义的字符\n\n在很多场景下，一些字符不携带任何有意义的信息，常见的如下：\ndata, state, amount, value, manager, engine, object, entity, instance。\n一个好的命名能够在读者的脑海中绘制一幅画像。”manager”并不会让读者得知这个变量或者方法做了什么事情。\n我们可以尝试着问自己一个问题：若移除掉这个词，标识符的含义是否和之前一样？如果是这样，这个词就是无意义的，可以移除。\n\n2.2 准则的实际应用\n\n为了说明上述准则在实际中是如何使用的，下面看一个例子：\n\n```\nclass DeliciousBelgianWaffleObject {\n\n  void garnishDeliciousBelgianWaffleWithStrawberryList(\n      List<Strawberry> strawberryList) { ... }\n}\n```\n\n既然参数类型我们已经能够从参数列表得知，因此将其移除：\n\n```\nclass DeliciousBelgianWaffleObject {\n\n    void garnishDeliciousBelgianWaffle(\n        List<Strawberry> strawberries) { ... }\n}\n```\n\n除非我们有其他口味的华夫饼，或者是其他国家的华夫饼，否则可以继续移除掉一部分字符：\n\n```\nclass WaffleObject {\n\n  void garnishWaffle(List<Strawberry> strawberries) { ... }\n}\n```\n\n既然方法是在类WaffleObject中，因此我们知道它要装饰的对象，因此修改如下：\n\n```\nclass WaffleObject {\n\n  void garnish(List<Strawberry> strawberries) { ... }\n}\n```\n\n程序中，任何事务都是以对象的形式存在，因此类名可以移除掉Object：\n\n```\nclass Waffle {\n\n  void garnish(List<Strawberry> strawberries) { ... }\n}\n```\n\n现在看看，是不是好多了。","slug":"代码中的命名问题-命名太长了！","published":1,"updated":"2016-09-07T08:02:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsc9000n2hwf6njtzjyz","content":"<h1 id=\"1-内容概要\"><a href=\"#1-内容概要\" class=\"headerlink\" title=\"1 内容概要\"></a>1 内容概要</h1><p>本文是一篇译文，翻译自：<a href=\"http://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/?from=timeline&amp;isappinstalled=0\" target=\"_blank\" rel=\"external\">Long Names Are Long</a>。主要介绍了编程过程中常见的命名过长的问题。</p>\n<h1 id=\"2-正文内容\"><a href=\"#2-正文内容\" class=\"headerlink\" title=\"2 正文内容\"></a>2 正文内容</h1><h2 id=\"2-1-选择一个好名字\"><a href=\"#2-1-选择一个好名字\" class=\"headerlink\" title=\"2.1 选择一个好名字\"></a>2.1 选择一个好名字</h2><p>一个好名字需要具备以下两个特点：</p>\n<a id=\"more\"></a>\n<ul>\n<li>含义清晰。一眼可以看出名字指代的含义。</li>\n<li>含义精确。能够从名字看出它不包含哪些含义。</li>\n</ul>\n<p>一个名字具备了以上2个特点之后，任何其他字符都是无用的。以下是我在编码过程中命名多得出的一些指导性准则。</p>\n<h3 id=\"2-1-1-忽略掉表示变量或者参数类型的字符\"><a href=\"#2-1-1-忽略掉表示变量或者参数类型的字符\" class=\"headerlink\" title=\"2.1.1 忽略掉表示变量或者参数类型的字符\"></a>2.1.1 忽略掉表示变量或者参数类型的字符</h3><p>对于静态变量，使用者通常都知道变量的类型。方法体通常不会很长，这样，即便是需要通过查看变量定义进行推断的局部变量，也可以很容易得知变量类型。<br>考虑到这点，将类型作为变量名字的一部分是冗余的。我们抛弃掉Hungarian notation。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Bad:</div><div class=\"line\"></div><div class=\"line\">String nameString;</div><div class=\"line\">DockableModelessWindow dockableModelessWindow;</div><div class=\"line\"></div><div class=\"line\">// Better:</div><div class=\"line\">String name;</div><div class=\"line\">DockableModelessWindow window;</div></pre></td></tr></table></figure>\n<p>特别的，对于集合，使用复数名词更好，而不要用单独的一个表示集合的名词。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Bad:</div><div class=\"line\"></div><div class=\"line\">List&lt;DateTime&gt; holidayDateList;</div><div class=\"line\">Map&lt;Employee, Role&gt; employeeRoleHashMap;</div><div class=\"line\"></div><div class=\"line\">// Better:</div><div class=\"line\">List&lt;DateTime&gt; holidays;</div><div class=\"line\">Map&lt;Employee, Role&gt; employeeRoles;</div></pre></td></tr></table></figure>\n<p>这对于方法命名同样奏效。方法名称没必要体现参数类型-通过参数列表可以得知。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Bad:</div><div class=\"line\"></div><div class=\"line\">mergeTableCells(List&lt;TableCell&gt; cells)</div><div class=\"line\">sortEventsUsingComparator(List&lt;Event&gt; events,</div><div class=\"line\">    Comparator&lt;Event&gt; comparator)</div><div class=\"line\"></div><div class=\"line\">// Better:</div><div class=\"line\">merge(List&lt;TableCell&gt; cells)</div><div class=\"line\">sort(List&lt;Event&gt; events, Comparator&lt;Event&gt; comparator)</div></pre></td></tr></table></figure>\n<p>这将使得调用方法的代码可读性更好：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mergeTableCells(tableCells);</div><div class=\"line\"></div><div class=\"line\">sortEventsUsingComparator(events, comparator);</div></pre></td></tr></table></figure>\n<h3 id=\"2-1-2-忽略掉会给命名带来歧义的字符\"><a href=\"#2-1-2-忽略掉会给命名带来歧义的字符\" class=\"headerlink\" title=\"2.1.2 忽略掉会给命名带来歧义的字符\"></a>2.1.2 忽略掉会给命名带来歧义的字符</h3><p>有些人喜欢把所知道的关于变量或者方法的所有事情都添加到命名中去。记住，命名是一个标识符：它指向它被定义的地方。它不是读者可能想知道的关于这个变量的所有事情的一个完整目录。这部分事情由定义来完成。命名只是让读者能够跳转到定义处。<br>当我看到这样一个命名：recentlyUpdatedAnnualSalesBid，我脑海里会有这样的疑问：</p>\n<ul>\n<li>有不是最近更新的年销售额投标吗？</li>\n<li>有没更新过的最近的年销售额投标吗？</li>\n<li>等等</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Bad:</div><div class=\"line\"></div><div class=\"line\">finalBattleMostDangerousBossMonster;</div><div class=\"line\">weaklingFirstEncounterMonster;</div><div class=\"line\"></div><div class=\"line\">// Better:</div><div class=\"line\">boss;</div><div class=\"line\">firstMonster;</div></pre></td></tr></table></figure>\n<h3 id=\"2-1-3-忽略掉能够从上下文得知的信息的字符\"><a href=\"#2-1-3-忽略掉能够从上下文得知的信息的字符\" class=\"headerlink\" title=\"2.1.3 忽略掉能够从上下文得知的信息的字符\"></a>2.1.3 忽略掉能够从上下文得知的信息的字符</h3><p>在这篇文章中，我能够使用“我”是因为读者能够看到这篇文章是由Bob Nystrom发布的。我不用再文章各处说明作者是Bob Nystrom。代码也是一样。方法或者变量都有各自的上下文，不需要再命名中重复上下文中的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Bad:</div><div class=\"line\"></div><div class=\"line\">class AnnualHolidaySale &#123;</div><div class=\"line\">  int _annualSaleRebate;</div><div class=\"line\">  void promoteHolidaySale() &#123; ... &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Better:</div><div class=\"line\">class AnnualHolidaySale &#123;</div><div class=\"line\">  int _rebate;</div><div class=\"line\">  void promote() &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-1-4-忽略掉无任何含义的字符\"><a href=\"#2-1-4-忽略掉无任何含义的字符\" class=\"headerlink\" title=\"2.1.4 忽略掉无任何含义的字符\"></a>2.1.4 忽略掉无任何含义的字符</h3><p>在很多场景下，一些字符不携带任何有意义的信息，常见的如下：<br>data, state, amount, value, manager, engine, object, entity, instance。<br>一个好的命名能够在读者的脑海中绘制一幅画像。”manager”并不会让读者得知这个变量或者方法做了什么事情。<br>我们可以尝试着问自己一个问题：若移除掉这个词，标识符的含义是否和之前一样？如果是这样，这个词就是无意义的，可以移除。</p>\n<p>2.2 准则的实际应用</p>\n<p>为了说明上述准则在实际中是如何使用的，下面看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class DeliciousBelgianWaffleObject &#123;</div><div class=\"line\"></div><div class=\"line\">  void garnishDeliciousBelgianWaffleWithStrawberryList(</div><div class=\"line\">      List&lt;Strawberry&gt; strawberryList) &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>既然参数类型我们已经能够从参数列表得知，因此将其移除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class DeliciousBelgianWaffleObject &#123;</div><div class=\"line\"></div><div class=\"line\">    void garnishDeliciousBelgianWaffle(</div><div class=\"line\">        List&lt;Strawberry&gt; strawberries) &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除非我们有其他口味的华夫饼，或者是其他国家的华夫饼，否则可以继续移除掉一部分字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">class WaffleObject &#123;</div><div class=\"line\"></div><div class=\"line\">  void garnishWaffle(List&lt;Strawberry&gt; strawberries) &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>既然方法是在类WaffleObject中，因此我们知道它要装饰的对象，因此修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">class WaffleObject &#123;</div><div class=\"line\"></div><div class=\"line\">  void garnish(List&lt;Strawberry&gt; strawberries) &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>程序中，任何事务都是以对象的形式存在，因此类名可以移除掉Object：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Waffle &#123;</div><div class=\"line\"></div><div class=\"line\">  void garnish(List&lt;Strawberry&gt; strawberries) &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在看看，是不是好多了。</p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/07/20/代码中的命名问题-命名太长了！/\">http://xiajunhust.github.io/2016/07/20/代码中的命名问题-命名太长了！/</a></p>\n","excerpt":"<h1 id=\"1-内容概要\"><a href=\"#1-内容概要\" class=\"headerlink\" title=\"1 内容概要\"></a>1 内容概要</h1><p>本文是一篇译文，翻译自：<a href=\"http://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/?from=timeline&amp;isappinstalled=0\">Long Names Are Long</a>。主要介绍了编程过程中常见的命名过长的问题。</p>\n<h1 id=\"2-正文内容\"><a href=\"#2-正文内容\" class=\"headerlink\" title=\"2 正文内容\"></a>2 正文内容</h1><h2 id=\"2-1-选择一个好名字\"><a href=\"#2-1-选择一个好名字\" class=\"headerlink\" title=\"2.1 选择一个好名字\"></a>2.1 选择一个好名字</h2><p>一个好名字需要具备以下两个特点：</p>","more":"<ul>\n<li>含义清晰。一眼可以看出名字指代的含义。</li>\n<li>含义精确。能够从名字看出它不包含哪些含义。</li>\n</ul>\n<p>一个名字具备了以上2个特点之后，任何其他字符都是无用的。以下是我在编码过程中命名多得出的一些指导性准则。</p>\n<h3 id=\"2-1-1-忽略掉表示变量或者参数类型的字符\"><a href=\"#2-1-1-忽略掉表示变量或者参数类型的字符\" class=\"headerlink\" title=\"2.1.1 忽略掉表示变量或者参数类型的字符\"></a>2.1.1 忽略掉表示变量或者参数类型的字符</h3><p>对于静态变量，使用者通常都知道变量的类型。方法体通常不会很长，这样，即便是需要通过查看变量定义进行推断的局部变量，也可以很容易得知变量类型。<br>考虑到这点，将类型作为变量名字的一部分是冗余的。我们抛弃掉Hungarian notation。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Bad:</div><div class=\"line\"></div><div class=\"line\">String nameString;</div><div class=\"line\">DockableModelessWindow dockableModelessWindow;</div><div class=\"line\"></div><div class=\"line\">// Better:</div><div class=\"line\">String name;</div><div class=\"line\">DockableModelessWindow window;</div></pre></td></tr></table></figure>\n<p>特别的，对于集合，使用复数名词更好，而不要用单独的一个表示集合的名词。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Bad:</div><div class=\"line\"></div><div class=\"line\">List&lt;DateTime&gt; holidayDateList;</div><div class=\"line\">Map&lt;Employee, Role&gt; employeeRoleHashMap;</div><div class=\"line\"></div><div class=\"line\">// Better:</div><div class=\"line\">List&lt;DateTime&gt; holidays;</div><div class=\"line\">Map&lt;Employee, Role&gt; employeeRoles;</div></pre></td></tr></table></figure>\n<p>这对于方法命名同样奏效。方法名称没必要体现参数类型-通过参数列表可以得知。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Bad:</div><div class=\"line\"></div><div class=\"line\">mergeTableCells(List&lt;TableCell&gt; cells)</div><div class=\"line\">sortEventsUsingComparator(List&lt;Event&gt; events,</div><div class=\"line\">    Comparator&lt;Event&gt; comparator)</div><div class=\"line\"></div><div class=\"line\">// Better:</div><div class=\"line\">merge(List&lt;TableCell&gt; cells)</div><div class=\"line\">sort(List&lt;Event&gt; events, Comparator&lt;Event&gt; comparator)</div></pre></td></tr></table></figure>\n<p>这将使得调用方法的代码可读性更好：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">mergeTableCells(tableCells);</div><div class=\"line\"></div><div class=\"line\">sortEventsUsingComparator(events, comparator);</div></pre></td></tr></table></figure>\n<h3 id=\"2-1-2-忽略掉会给命名带来歧义的字符\"><a href=\"#2-1-2-忽略掉会给命名带来歧义的字符\" class=\"headerlink\" title=\"2.1.2 忽略掉会给命名带来歧义的字符\"></a>2.1.2 忽略掉会给命名带来歧义的字符</h3><p>有些人喜欢把所知道的关于变量或者方法的所有事情都添加到命名中去。记住，命名是一个标识符：它指向它被定义的地方。它不是读者可能想知道的关于这个变量的所有事情的一个完整目录。这部分事情由定义来完成。命名只是让读者能够跳转到定义处。<br>当我看到这样一个命名：recentlyUpdatedAnnualSalesBid，我脑海里会有这样的疑问：</p>\n<ul>\n<li>有不是最近更新的年销售额投标吗？</li>\n<li>有没更新过的最近的年销售额投标吗？</li>\n<li>等等</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Bad:</div><div class=\"line\"></div><div class=\"line\">finalBattleMostDangerousBossMonster;</div><div class=\"line\">weaklingFirstEncounterMonster;</div><div class=\"line\"></div><div class=\"line\">// Better:</div><div class=\"line\">boss;</div><div class=\"line\">firstMonster;</div></pre></td></tr></table></figure>\n<h3 id=\"2-1-3-忽略掉能够从上下文得知的信息的字符\"><a href=\"#2-1-3-忽略掉能够从上下文得知的信息的字符\" class=\"headerlink\" title=\"2.1.3 忽略掉能够从上下文得知的信息的字符\"></a>2.1.3 忽略掉能够从上下文得知的信息的字符</h3><p>在这篇文章中，我能够使用“我”是因为读者能够看到这篇文章是由Bob Nystrom发布的。我不用再文章各处说明作者是Bob Nystrom。代码也是一样。方法或者变量都有各自的上下文，不需要再命名中重复上下文中的信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Bad:</div><div class=\"line\"></div><div class=\"line\">class AnnualHolidaySale &#123;</div><div class=\"line\">  int _annualSaleRebate;</div><div class=\"line\">  void promoteHolidaySale() &#123; ... &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Better:</div><div class=\"line\">class AnnualHolidaySale &#123;</div><div class=\"line\">  int _rebate;</div><div class=\"line\">  void promote() &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-1-4-忽略掉无任何含义的字符\"><a href=\"#2-1-4-忽略掉无任何含义的字符\" class=\"headerlink\" title=\"2.1.4 忽略掉无任何含义的字符\"></a>2.1.4 忽略掉无任何含义的字符</h3><p>在很多场景下，一些字符不携带任何有意义的信息，常见的如下：<br>data, state, amount, value, manager, engine, object, entity, instance。<br>一个好的命名能够在读者的脑海中绘制一幅画像。”manager”并不会让读者得知这个变量或者方法做了什么事情。<br>我们可以尝试着问自己一个问题：若移除掉这个词，标识符的含义是否和之前一样？如果是这样，这个词就是无意义的，可以移除。</p>\n<p>2.2 准则的实际应用</p>\n<p>为了说明上述准则在实际中是如何使用的，下面看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class DeliciousBelgianWaffleObject &#123;</div><div class=\"line\"></div><div class=\"line\">  void garnishDeliciousBelgianWaffleWithStrawberryList(</div><div class=\"line\">      List&lt;Strawberry&gt; strawberryList) &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>既然参数类型我们已经能够从参数列表得知，因此将其移除：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">class DeliciousBelgianWaffleObject &#123;</div><div class=\"line\"></div><div class=\"line\">    void garnishDeliciousBelgianWaffle(</div><div class=\"line\">        List&lt;Strawberry&gt; strawberries) &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>除非我们有其他口味的华夫饼，或者是其他国家的华夫饼，否则可以继续移除掉一部分字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">class WaffleObject &#123;</div><div class=\"line\"></div><div class=\"line\">  void garnishWaffle(List&lt;Strawberry&gt; strawberries) &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>既然方法是在类WaffleObject中，因此我们知道它要装饰的对象，因此修改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">class WaffleObject &#123;</div><div class=\"line\"></div><div class=\"line\">  void garnish(List&lt;Strawberry&gt; strawberries) &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>程序中，任何事务都是以对象的形式存在，因此类名可以移除掉Object：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Waffle &#123;</div><div class=\"line\"></div><div class=\"line\">  void garnish(List&lt;Strawberry&gt; strawberries) &#123; ... &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在看看，是不是好多了。</p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/07/20/代码中的命名问题-命名太长了！/\">http://xiajunhust.github.io/2016/07/20/代码中的命名问题-命名太长了！/</a></p>"},{"title":"从Hystrix DashboardData看ReativeX的使用","date":"2016-12-18T06:23:43.000Z","_content":"\n最近在将系统中服务降级框架[Hystrix](https://github.com/Netflix/Hystrix)的运行时的一些指标数据接入到监控平台，需要获取Hystrix的Dashboard数据。发现用到了[ReactiveX](http://reactivex.io/)的知识，因此总结下。\n\n## 1 如何获取Hystrix的Dashboard数据  \n获取Hystrix的Dashboard数据比较简单，实现一个观察者即可接收Dashboard数据，如下代码：\n\n```\nObservable<HystrixDashboardStream.DashboardData> \n       dashboardDataObservable = HystrixDashboardStream.getInstance().observe();\n   \ndashboardDataObservable.subscribe(new Action1<HystrixDashboardStream.DashboardData>() {\n\t@Override\n\tpublic void call(HystrixDashboardStream.DashboardData dashboardData) {\n\t\n\t//do something\n\t}\n});\n```\n\n## 2 HystrixDashboard设计 \n\n<!-- more -->\n\nHystrix Dashboard数据获取的核心类：HystrixDashboardStream。\n\n## 2.1 Hystrix Dashboard数据结构  \nHystrix Dashboard数据结构封装类是HystrixDashboardStream.DashboardData:  \n\n```\npublic static class DashboardData {\n    final Collection<HystrixCommandMetrics> commandMetrics;\n    final Collection<HystrixThreadPoolMetrics> threadPoolMetrics;\n    final Collection<HystrixCollapserMetrics> collapserMetrics;\n\n    public DashboardData(Collection<HystrixCommandMetrics> commandMetrics, Collection<HystrixThreadPoolMetrics> threadPoolMetrics, Collection<HystrixCollapserMetrics> collapserMetrics) {\n        this.commandMetrics = commandMetrics;\n        this.threadPoolMetrics = threadPoolMetrics;\n        this.collapserMetrics = collapserMetrics;\n    }\n\n    public Collection<HystrixCommandMetrics> getCommandMetrics() {\n        return commandMetrics;\n    }\n\n    public Collection<HystrixThreadPoolMetrics> getThreadPoolMetrics() {\n        return threadPoolMetrics;\n    }\n\n    public Collection<HystrixCollapserMetrics> getCollapserMetrics() {\n        return collapserMetrics;\n    }\n}\n```\n\n包括了三类数据： \n\n- 每个Command的metrics  \n比如当前并发执行的数量、执行时间、执行的成功数、失败数以及失败率。\n- 每个线程池的metrics  \n比如总共执行的、总共被拒绝的、当前活跃的线程数目等等。\n- 请求合并调用\n\n如下是一个数据输出示例：\n\n```\n2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - HystrixDashboardStream.DashboardData:\n2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - commandMetrics:\n2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=GoodsPostageCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 2 : 0%] ,TotalTimeMean=0\n2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=DeliverySettingCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 3 : 0%] ,TotalTimeMean=0\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=GoodsBriefInfoCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 5 : 0%] ,TotalTimeMean=0\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=UmpBillPreferenceCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 3 : 0%] ,TotalTimeMean=0\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=LocalDeliveryCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 1 : 0%] ,TotalTimeMean=0\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - threadPoolMetrics:\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=DeliveryGroup,CumulativeCountThreadsExecuted=1,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=4,CurrentCorePoolSize=15,CurrentPoolSize=4,CurrentQueueSize=0,CurrentTaskCount=4\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=UmpServiceGroup,CumulativeCountThreadsExecuted=1,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=3,CurrentCorePoolSize=15,CurrentPoolSize=3,CurrentQueueSize=0,CurrentTaskCount=3\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=GoodsServiceGroup,CumulativeCountThreadsExecuted=4,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=7,CurrentCorePoolSize=15,CurrentPoolSize=7,CurrentQueueSize=0,CurrentTaskCount=7\n```\n\n## 2.2 设计思路  \n这里采用了ReactiveX，创建了一个被观察者Observable，欲监控Dashboard数据，只需创建观察者Observer，接收Observable发射出来的数据即可。  \n\n### 2.2.1 什么是ReactiveX  \n微软给的定义是，Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序，使用Rx，开发者可以用Observables表示异步数据流，用LINQ操作符查询异步数据流， 用Schedulers参数化异步数据流的并发处理，Rx可以这样定义：Rx = Observables + LINQ + Schedulers。\n\nReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。\n\n### 2.2.2 使用ReactiveX的好处  \n使用观察者模式可以  \n\n- 创建：Rx可以方便的创建事件流和数据流  \n- 组合：Rx使用查询式的操作符组合和变换数据流  \n- 监听：Rx可以订阅任何可观察的数据流并执行操作  \n\n带来如下好处：  \n\n- 函数式风格：对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态\n- 简化代码：Rx的操作符通通常可以将复杂的难题简化为很少的几行代码\n- 异步错误处理：传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制\n- 轻松使用并发：Rx的Observables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题\n\nJava中对ReactiveX的实现是RxJava。\n\n### 2.2.2 Hystrix Dashboard对ReactiveX的使用\n在HystrixDashboardStream的构造函数中创建了Observable：\n\n```\nprivate static final DynamicIntProperty dataEmissionIntervalInMs =\n            DynamicPropertyFactory.getInstance().getIntProperty(\"hystrix.stream.dashboard.intervalInMilliseconds\", 500);\n\nprivate HystrixDashboardStream(int delayInMs) {\n    this.delayInMs = delayInMs;\n    this.singleSource = Observable.interval(delayInMs, TimeUnit.MILLISECONDS)\n            .map(new Func1<Long, DashboardData>() {\n                @Override\n                public DashboardData call(Long timestamp) {\n                    return new DashboardData(\n                            HystrixCommandMetrics.getInstances(),\n                            HystrixThreadPoolMetrics.getInstances(),\n                            HystrixCollapserMetrics.getInstances()\n                    );\n                }\n            })\n            .doOnSubscribe(new Action0() {\n                @Override\n                public void call() {\n                    isSourceCurrentlySubscribed.set(true);\n                }\n            })\n            .doOnUnsubscribe(new Action0() {\n                @Override\n                public void call() {\n                    isSourceCurrentlySubscribed.set(false);\n                }\n            })\n            .share()\n            .onBackpressureDrop();\n}\n```\n\n这里创建一个按固定时间间隔发射整数序列的Observable，默认间隔时间是500ms。\n\n![operators.interval](https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/interval.png)\n\nRxJava中[Observable.interval](http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20java.util.concurrent.TimeUnit)).\n\n创建了Observable之后，紧接着调用了变换函数Map。  \n\n![operators.map](https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/map.png)\n\n它对Observable发射的每一项数据应用一个函数，执行变换操作。这里的函数是调用HystrixCommandMetrics、HystrixThreadPoolMetrics、HystrixCollapserMetrics的实例获取方法，返回对应的Dashboard数据。\n\ndoOnSubscribe-当被订阅的时候，执行对应的操作。  \ndoOnUnsubscribe-当没有订阅者的时候，执行对应的操作。\n\n# 3 参考资料  \n- [ReactiveX官方网站](http://reactivex.io/)\n- [RxJava](https://github.com/ReactiveX/RxJava)\n","source":"_posts/从Hystrix-DashboardData看ReativeX的使用.md","raw":"---\ntitle: 从Hystrix DashboardData看ReativeX的使用\ndate: 2016-12-18 14:23:43\ntags: [ReactiveX,Hystrix]\n---\n\n最近在将系统中服务降级框架[Hystrix](https://github.com/Netflix/Hystrix)的运行时的一些指标数据接入到监控平台，需要获取Hystrix的Dashboard数据。发现用到了[ReactiveX](http://reactivex.io/)的知识，因此总结下。\n\n## 1 如何获取Hystrix的Dashboard数据  \n获取Hystrix的Dashboard数据比较简单，实现一个观察者即可接收Dashboard数据，如下代码：\n\n```\nObservable<HystrixDashboardStream.DashboardData> \n       dashboardDataObservable = HystrixDashboardStream.getInstance().observe();\n   \ndashboardDataObservable.subscribe(new Action1<HystrixDashboardStream.DashboardData>() {\n\t@Override\n\tpublic void call(HystrixDashboardStream.DashboardData dashboardData) {\n\t\n\t//do something\n\t}\n});\n```\n\n## 2 HystrixDashboard设计 \n\n<!-- more -->\n\nHystrix Dashboard数据获取的核心类：HystrixDashboardStream。\n\n## 2.1 Hystrix Dashboard数据结构  \nHystrix Dashboard数据结构封装类是HystrixDashboardStream.DashboardData:  \n\n```\npublic static class DashboardData {\n    final Collection<HystrixCommandMetrics> commandMetrics;\n    final Collection<HystrixThreadPoolMetrics> threadPoolMetrics;\n    final Collection<HystrixCollapserMetrics> collapserMetrics;\n\n    public DashboardData(Collection<HystrixCommandMetrics> commandMetrics, Collection<HystrixThreadPoolMetrics> threadPoolMetrics, Collection<HystrixCollapserMetrics> collapserMetrics) {\n        this.commandMetrics = commandMetrics;\n        this.threadPoolMetrics = threadPoolMetrics;\n        this.collapserMetrics = collapserMetrics;\n    }\n\n    public Collection<HystrixCommandMetrics> getCommandMetrics() {\n        return commandMetrics;\n    }\n\n    public Collection<HystrixThreadPoolMetrics> getThreadPoolMetrics() {\n        return threadPoolMetrics;\n    }\n\n    public Collection<HystrixCollapserMetrics> getCollapserMetrics() {\n        return collapserMetrics;\n    }\n}\n```\n\n包括了三类数据： \n\n- 每个Command的metrics  \n比如当前并发执行的数量、执行时间、执行的成功数、失败数以及失败率。\n- 每个线程池的metrics  \n比如总共执行的、总共被拒绝的、当前活跃的线程数目等等。\n- 请求合并调用\n\n如下是一个数据输出示例：\n\n```\n2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - HystrixDashboardStream.DashboardData:\n2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - commandMetrics:\n2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=GoodsPostageCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 2 : 0%] ,TotalTimeMean=0\n2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=DeliverySettingCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 3 : 0%] ,TotalTimeMean=0\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=GoodsBriefInfoCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 5 : 0%] ,TotalTimeMean=0\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=UmpBillPreferenceCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 3 : 0%] ,TotalTimeMean=0\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=LocalDeliveryCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 1 : 0%] ,TotalTimeMean=0\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - threadPoolMetrics:\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=DeliveryGroup,CumulativeCountThreadsExecuted=1,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=4,CurrentCorePoolSize=15,CurrentPoolSize=4,CurrentQueueSize=0,CurrentTaskCount=4\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=UmpServiceGroup,CumulativeCountThreadsExecuted=1,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=3,CurrentCorePoolSize=15,CurrentPoolSize=3,CurrentQueueSize=0,CurrentTaskCount=3\n2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=GoodsServiceGroup,CumulativeCountThreadsExecuted=4,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=7,CurrentCorePoolSize=15,CurrentPoolSize=7,CurrentQueueSize=0,CurrentTaskCount=7\n```\n\n## 2.2 设计思路  \n这里采用了ReactiveX，创建了一个被观察者Observable，欲监控Dashboard数据，只需创建观察者Observer，接收Observable发射出来的数据即可。  \n\n### 2.2.1 什么是ReactiveX  \n微软给的定义是，Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序，使用Rx，开发者可以用Observables表示异步数据流，用LINQ操作符查询异步数据流， 用Schedulers参数化异步数据流的并发处理，Rx可以这样定义：Rx = Observables + LINQ + Schedulers。\n\nReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。\n\n### 2.2.2 使用ReactiveX的好处  \n使用观察者模式可以  \n\n- 创建：Rx可以方便的创建事件流和数据流  \n- 组合：Rx使用查询式的操作符组合和变换数据流  \n- 监听：Rx可以订阅任何可观察的数据流并执行操作  \n\n带来如下好处：  \n\n- 函数式风格：对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态\n- 简化代码：Rx的操作符通通常可以将复杂的难题简化为很少的几行代码\n- 异步错误处理：传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制\n- 轻松使用并发：Rx的Observables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题\n\nJava中对ReactiveX的实现是RxJava。\n\n### 2.2.2 Hystrix Dashboard对ReactiveX的使用\n在HystrixDashboardStream的构造函数中创建了Observable：\n\n```\nprivate static final DynamicIntProperty dataEmissionIntervalInMs =\n            DynamicPropertyFactory.getInstance().getIntProperty(\"hystrix.stream.dashboard.intervalInMilliseconds\", 500);\n\nprivate HystrixDashboardStream(int delayInMs) {\n    this.delayInMs = delayInMs;\n    this.singleSource = Observable.interval(delayInMs, TimeUnit.MILLISECONDS)\n            .map(new Func1<Long, DashboardData>() {\n                @Override\n                public DashboardData call(Long timestamp) {\n                    return new DashboardData(\n                            HystrixCommandMetrics.getInstances(),\n                            HystrixThreadPoolMetrics.getInstances(),\n                            HystrixCollapserMetrics.getInstances()\n                    );\n                }\n            })\n            .doOnSubscribe(new Action0() {\n                @Override\n                public void call() {\n                    isSourceCurrentlySubscribed.set(true);\n                }\n            })\n            .doOnUnsubscribe(new Action0() {\n                @Override\n                public void call() {\n                    isSourceCurrentlySubscribed.set(false);\n                }\n            })\n            .share()\n            .onBackpressureDrop();\n}\n```\n\n这里创建一个按固定时间间隔发射整数序列的Observable，默认间隔时间是500ms。\n\n![operators.interval](https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/interval.png)\n\nRxJava中[Observable.interval](http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20java.util.concurrent.TimeUnit)).\n\n创建了Observable之后，紧接着调用了变换函数Map。  \n\n![operators.map](https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/map.png)\n\n它对Observable发射的每一项数据应用一个函数，执行变换操作。这里的函数是调用HystrixCommandMetrics、HystrixThreadPoolMetrics、HystrixCollapserMetrics的实例获取方法，返回对应的Dashboard数据。\n\ndoOnSubscribe-当被订阅的时候，执行对应的操作。  \ndoOnUnsubscribe-当没有订阅者的时候，执行对应的操作。\n\n# 3 参考资料  \n- [ReactiveX官方网站](http://reactivex.io/)\n- [RxJava](https://github.com/ReactiveX/RxJava)\n","slug":"从Hystrix-DashboardData看ReativeX的使用","published":1,"updated":"2016-12-18T07:16:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjscc000p2hwf00ilawmk","content":"<p>最近在将系统中服务降级框架<a href=\"https://github.com/Netflix/Hystrix\" target=\"_blank\" rel=\"external\">Hystrix</a>的运行时的一些指标数据接入到监控平台，需要获取Hystrix的Dashboard数据。发现用到了<a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"external\">ReactiveX</a>的知识，因此总结下。</p>\n<h2 id=\"1-如何获取Hystrix的Dashboard数据\"><a href=\"#1-如何获取Hystrix的Dashboard数据\" class=\"headerlink\" title=\"1 如何获取Hystrix的Dashboard数据\"></a>1 如何获取Hystrix的Dashboard数据</h2><p>获取Hystrix的Dashboard数据比较简单，实现一个观察者即可接收Dashboard数据，如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;HystrixDashboardStream.DashboardData&gt; </div><div class=\"line\">       dashboardDataObservable = HystrixDashboardStream.getInstance().observe();</div><div class=\"line\">   </div><div class=\"line\">dashboardDataObservable.subscribe(new Action1&lt;HystrixDashboardStream.DashboardData&gt;() &#123;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void call(HystrixDashboardStream.DashboardData dashboardData) &#123;</div><div class=\"line\">\t</div><div class=\"line\">\t//do something</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"2-HystrixDashboard设计\"><a href=\"#2-HystrixDashboard设计\" class=\"headerlink\" title=\"2 HystrixDashboard设计\"></a>2 HystrixDashboard设计</h2><a id=\"more\"></a>\n<p>Hystrix Dashboard数据获取的核心类：HystrixDashboardStream。</p>\n<h2 id=\"2-1-Hystrix-Dashboard数据结构\"><a href=\"#2-1-Hystrix-Dashboard数据结构\" class=\"headerlink\" title=\"2.1 Hystrix Dashboard数据结构\"></a>2.1 Hystrix Dashboard数据结构</h2><p>Hystrix Dashboard数据结构封装类是HystrixDashboardStream.DashboardData:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static class DashboardData &#123;</div><div class=\"line\">    final Collection&lt;HystrixCommandMetrics&gt; commandMetrics;</div><div class=\"line\">    final Collection&lt;HystrixThreadPoolMetrics&gt; threadPoolMetrics;</div><div class=\"line\">    final Collection&lt;HystrixCollapserMetrics&gt; collapserMetrics;</div><div class=\"line\"></div><div class=\"line\">    public DashboardData(Collection&lt;HystrixCommandMetrics&gt; commandMetrics, Collection&lt;HystrixThreadPoolMetrics&gt; threadPoolMetrics, Collection&lt;HystrixCollapserMetrics&gt; collapserMetrics) &#123;</div><div class=\"line\">        this.commandMetrics = commandMetrics;</div><div class=\"line\">        this.threadPoolMetrics = threadPoolMetrics;</div><div class=\"line\">        this.collapserMetrics = collapserMetrics;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public Collection&lt;HystrixCommandMetrics&gt; getCommandMetrics() &#123;</div><div class=\"line\">        return commandMetrics;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public Collection&lt;HystrixThreadPoolMetrics&gt; getThreadPoolMetrics() &#123;</div><div class=\"line\">        return threadPoolMetrics;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public Collection&lt;HystrixCollapserMetrics&gt; getCollapserMetrics() &#123;</div><div class=\"line\">        return collapserMetrics;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>包括了三类数据： </p>\n<ul>\n<li>每个Command的metrics<br>比如当前并发执行的数量、执行时间、执行的成功数、失败数以及失败率。</li>\n<li>每个线程池的metrics<br>比如总共执行的、总共被拒绝的、当前活跃的线程数目等等。</li>\n<li>请求合并调用</li>\n</ul>\n<p>如下是一个数据输出示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - HystrixDashboardStream.DashboardData:</div><div class=\"line\">2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - commandMetrics:</div><div class=\"line\">2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=GoodsPostageCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 2 : 0%] ,TotalTimeMean=0</div><div class=\"line\">2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=DeliverySettingCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 3 : 0%] ,TotalTimeMean=0</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=GoodsBriefInfoCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 5 : 0%] ,TotalTimeMean=0</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=UmpBillPreferenceCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 3 : 0%] ,TotalTimeMean=0</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=LocalDeliveryCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 1 : 0%] ,TotalTimeMean=0</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - threadPoolMetrics:</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=DeliveryGroup,CumulativeCountThreadsExecuted=1,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=4,CurrentCorePoolSize=15,CurrentPoolSize=4,CurrentQueueSize=0,CurrentTaskCount=4</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=UmpServiceGroup,CumulativeCountThreadsExecuted=1,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=3,CurrentCorePoolSize=15,CurrentPoolSize=3,CurrentQueueSize=0,CurrentTaskCount=3</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=GoodsServiceGroup,CumulativeCountThreadsExecuted=4,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=7,CurrentCorePoolSize=15,CurrentPoolSize=7,CurrentQueueSize=0,CurrentTaskCount=7</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-设计思路\"><a href=\"#2-2-设计思路\" class=\"headerlink\" title=\"2.2 设计思路\"></a>2.2 设计思路</h2><p>这里采用了ReactiveX，创建了一个被观察者Observable，欲监控Dashboard数据，只需创建观察者Observer，接收Observable发射出来的数据即可。  </p>\n<h3 id=\"2-2-1-什么是ReactiveX\"><a href=\"#2-2-1-什么是ReactiveX\" class=\"headerlink\" title=\"2.2.1 什么是ReactiveX\"></a>2.2.1 什么是ReactiveX</h3><p>微软给的定义是，Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序，使用Rx，开发者可以用Observables表示异步数据流，用LINQ操作符查询异步数据流， 用Schedulers参数化异步数据流的并发处理，Rx可以这样定义：Rx = Observables + LINQ + Schedulers。</p>\n<p>ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。</p>\n<h3 id=\"2-2-2-使用ReactiveX的好处\"><a href=\"#2-2-2-使用ReactiveX的好处\" class=\"headerlink\" title=\"2.2.2 使用ReactiveX的好处\"></a>2.2.2 使用ReactiveX的好处</h3><p>使用观察者模式可以  </p>\n<ul>\n<li>创建：Rx可以方便的创建事件流和数据流  </li>\n<li>组合：Rx使用查询式的操作符组合和变换数据流  </li>\n<li>监听：Rx可以订阅任何可观察的数据流并执行操作  </li>\n</ul>\n<p>带来如下好处：  </p>\n<ul>\n<li>函数式风格：对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态</li>\n<li>简化代码：Rx的操作符通通常可以将复杂的难题简化为很少的几行代码</li>\n<li>异步错误处理：传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制</li>\n<li>轻松使用并发：Rx的Observables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题</li>\n</ul>\n<p>Java中对ReactiveX的实现是RxJava。</p>\n<h3 id=\"2-2-2-Hystrix-Dashboard对ReactiveX的使用\"><a href=\"#2-2-2-Hystrix-Dashboard对ReactiveX的使用\" class=\"headerlink\" title=\"2.2.2 Hystrix Dashboard对ReactiveX的使用\"></a>2.2.2 Hystrix Dashboard对ReactiveX的使用</h3><p>在HystrixDashboardStream的构造函数中创建了Observable：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final DynamicIntProperty dataEmissionIntervalInMs =</div><div class=\"line\">            DynamicPropertyFactory.getInstance().getIntProperty(&quot;hystrix.stream.dashboard.intervalInMilliseconds&quot;, 500);</div><div class=\"line\"></div><div class=\"line\">private HystrixDashboardStream(int delayInMs) &#123;</div><div class=\"line\">    this.delayInMs = delayInMs;</div><div class=\"line\">    this.singleSource = Observable.interval(delayInMs, TimeUnit.MILLISECONDS)</div><div class=\"line\">            .map(new Func1&lt;Long, DashboardData&gt;() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public DashboardData call(Long timestamp) &#123;</div><div class=\"line\">                    return new DashboardData(</div><div class=\"line\">                            HystrixCommandMetrics.getInstances(),</div><div class=\"line\">                            HystrixThreadPoolMetrics.getInstances(),</div><div class=\"line\">                            HystrixCollapserMetrics.getInstances()</div><div class=\"line\">                    );</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .doOnSubscribe(new Action0() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void call() &#123;</div><div class=\"line\">                    isSourceCurrentlySubscribed.set(true);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .doOnUnsubscribe(new Action0() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void call() &#123;</div><div class=\"line\">                    isSourceCurrentlySubscribed.set(false);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .share()</div><div class=\"line\">            .onBackpressureDrop();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里创建一个按固定时间间隔发射整数序列的Observable，默认间隔时间是500ms。</p>\n<p><img src=\"https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/interval.png\" alt=\"operators.interval\"></p>\n<p>RxJava中<a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20java.util.concurrent.TimeUnit\" target=\"_blank\" rel=\"external\">Observable.interval</a>).</p>\n<p>创建了Observable之后，紧接着调用了变换函数Map。  </p>\n<p><img src=\"https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/map.png\" alt=\"operators.map\"></p>\n<p>它对Observable发射的每一项数据应用一个函数，执行变换操作。这里的函数是调用HystrixCommandMetrics、HystrixThreadPoolMetrics、HystrixCollapserMetrics的实例获取方法，返回对应的Dashboard数据。</p>\n<p>doOnSubscribe-当被订阅的时候，执行对应的操作。<br>doOnUnsubscribe-当没有订阅者的时候，执行对应的操作。</p>\n<h1 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3 参考资料\"></a>3 参考资料</h1><ul>\n<li><a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"external\">ReactiveX官方网站</a></li>\n<li><a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"external\">RxJava</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/12/18/从Hystrix-DashboardData看ReativeX的使用/\">http://xiajunhust.github.io/2016/12/18/从Hystrix-DashboardData看ReativeX的使用/</a></p>\n","excerpt":"<p>最近在将系统中服务降级框架<a href=\"https://github.com/Netflix/Hystrix\">Hystrix</a>的运行时的一些指标数据接入到监控平台，需要获取Hystrix的Dashboard数据。发现用到了<a href=\"http://reactivex.io/\">ReactiveX</a>的知识，因此总结下。</p>\n<h2 id=\"1-如何获取Hystrix的Dashboard数据\"><a href=\"#1-如何获取Hystrix的Dashboard数据\" class=\"headerlink\" title=\"1 如何获取Hystrix的Dashboard数据\"></a>1 如何获取Hystrix的Dashboard数据</h2><p>获取Hystrix的Dashboard数据比较简单，实现一个观察者即可接收Dashboard数据，如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;HystrixDashboardStream.DashboardData&gt; </div><div class=\"line\">       dashboardDataObservable = HystrixDashboardStream.getInstance().observe();</div><div class=\"line\">   </div><div class=\"line\">dashboardDataObservable.subscribe(new Action1&lt;HystrixDashboardStream.DashboardData&gt;() &#123;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void call(HystrixDashboardStream.DashboardData dashboardData) &#123;</div><div class=\"line\">\t</div><div class=\"line\">\t//do something</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"2-HystrixDashboard设计\"><a href=\"#2-HystrixDashboard设计\" class=\"headerlink\" title=\"2 HystrixDashboard设计\"></a>2 HystrixDashboard设计</h2>","more":"<p>Hystrix Dashboard数据获取的核心类：HystrixDashboardStream。</p>\n<h2 id=\"2-1-Hystrix-Dashboard数据结构\"><a href=\"#2-1-Hystrix-Dashboard数据结构\" class=\"headerlink\" title=\"2.1 Hystrix Dashboard数据结构\"></a>2.1 Hystrix Dashboard数据结构</h2><p>Hystrix Dashboard数据结构封装类是HystrixDashboardStream.DashboardData:  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static class DashboardData &#123;</div><div class=\"line\">    final Collection&lt;HystrixCommandMetrics&gt; commandMetrics;</div><div class=\"line\">    final Collection&lt;HystrixThreadPoolMetrics&gt; threadPoolMetrics;</div><div class=\"line\">    final Collection&lt;HystrixCollapserMetrics&gt; collapserMetrics;</div><div class=\"line\"></div><div class=\"line\">    public DashboardData(Collection&lt;HystrixCommandMetrics&gt; commandMetrics, Collection&lt;HystrixThreadPoolMetrics&gt; threadPoolMetrics, Collection&lt;HystrixCollapserMetrics&gt; collapserMetrics) &#123;</div><div class=\"line\">        this.commandMetrics = commandMetrics;</div><div class=\"line\">        this.threadPoolMetrics = threadPoolMetrics;</div><div class=\"line\">        this.collapserMetrics = collapserMetrics;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public Collection&lt;HystrixCommandMetrics&gt; getCommandMetrics() &#123;</div><div class=\"line\">        return commandMetrics;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public Collection&lt;HystrixThreadPoolMetrics&gt; getThreadPoolMetrics() &#123;</div><div class=\"line\">        return threadPoolMetrics;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public Collection&lt;HystrixCollapserMetrics&gt; getCollapserMetrics() &#123;</div><div class=\"line\">        return collapserMetrics;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>包括了三类数据： </p>\n<ul>\n<li>每个Command的metrics<br>比如当前并发执行的数量、执行时间、执行的成功数、失败数以及失败率。</li>\n<li>每个线程池的metrics<br>比如总共执行的、总共被拒绝的、当前活跃的线程数目等等。</li>\n<li>请求合并调用</li>\n</ul>\n<p>如下是一个数据输出示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - HystrixDashboardStream.DashboardData:</div><div class=\"line\">2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - commandMetrics:</div><div class=\"line\">2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=GoodsPostageCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 2 : 0%] ,TotalTimeMean=0</div><div class=\"line\">2016-12-16 10:28:08.809 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=DeliverySettingCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 3 : 0%] ,TotalTimeMean=0</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=GoodsBriefInfoCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 5 : 0%] ,TotalTimeMean=0</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=UmpBillPreferenceCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 3 : 0%] ,TotalTimeMean=0</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - Properties.circuitBreakerEnabled=true,CommandKey=LocalDeliveryCommand,CurrentConcurrentExecutionCount=0,ExecutionTimeMean=0,HealthCounts=HealthCounts[0 / 1 : 0%] ,TotalTimeMean=0</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - threadPoolMetrics:</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=DeliveryGroup,CumulativeCountThreadsExecuted=1,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=4,CurrentCorePoolSize=15,CurrentPoolSize=4,CurrentQueueSize=0,CurrentTaskCount=4</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=UmpServiceGroup,CumulativeCountThreadsExecuted=1,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=3,CurrentCorePoolSize=15,CurrentPoolSize=3,CurrentQueueSize=0,CurrentTaskCount=3</div><div class=\"line\">2016-12-16 10:28:08.810 [] [] [] INFO  c.y.t.t.MonitorHystrixJob - ThreadPoolKey=GoodsServiceGroup,CumulativeCountThreadsExecuted=4,CumulativeCountThreadsRejected=0,CurrentActiveCount=0,CurrentCompletedTaskCount=7,CurrentCorePoolSize=15,CurrentPoolSize=7,CurrentQueueSize=0,CurrentTaskCount=7</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-设计思路\"><a href=\"#2-2-设计思路\" class=\"headerlink\" title=\"2.2 设计思路\"></a>2.2 设计思路</h2><p>这里采用了ReactiveX，创建了一个被观察者Observable，欲监控Dashboard数据，只需创建观察者Observer，接收Observable发射出来的数据即可。  </p>\n<h3 id=\"2-2-1-什么是ReactiveX\"><a href=\"#2-2-1-什么是ReactiveX\" class=\"headerlink\" title=\"2.2.1 什么是ReactiveX\"></a>2.2.1 什么是ReactiveX</h3><p>微软给的定义是，Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序，使用Rx，开发者可以用Observables表示异步数据流，用LINQ操作符查询异步数据流， 用Schedulers参数化异步数据流的并发处理，Rx可以这样定义：Rx = Observables + LINQ + Schedulers。</p>\n<p>ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。</p>\n<h3 id=\"2-2-2-使用ReactiveX的好处\"><a href=\"#2-2-2-使用ReactiveX的好处\" class=\"headerlink\" title=\"2.2.2 使用ReactiveX的好处\"></a>2.2.2 使用ReactiveX的好处</h3><p>使用观察者模式可以  </p>\n<ul>\n<li>创建：Rx可以方便的创建事件流和数据流  </li>\n<li>组合：Rx使用查询式的操作符组合和变换数据流  </li>\n<li>监听：Rx可以订阅任何可观察的数据流并执行操作  </li>\n</ul>\n<p>带来如下好处：  </p>\n<ul>\n<li>函数式风格：对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态</li>\n<li>简化代码：Rx的操作符通通常可以将复杂的难题简化为很少的几行代码</li>\n<li>异步错误处理：传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制</li>\n<li>轻松使用并发：Rx的Observables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题</li>\n</ul>\n<p>Java中对ReactiveX的实现是RxJava。</p>\n<h3 id=\"2-2-2-Hystrix-Dashboard对ReactiveX的使用\"><a href=\"#2-2-2-Hystrix-Dashboard对ReactiveX的使用\" class=\"headerlink\" title=\"2.2.2 Hystrix Dashboard对ReactiveX的使用\"></a>2.2.2 Hystrix Dashboard对ReactiveX的使用</h3><p>在HystrixDashboardStream的构造函数中创建了Observable：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final DynamicIntProperty dataEmissionIntervalInMs =</div><div class=\"line\">            DynamicPropertyFactory.getInstance().getIntProperty(&quot;hystrix.stream.dashboard.intervalInMilliseconds&quot;, 500);</div><div class=\"line\"></div><div class=\"line\">private HystrixDashboardStream(int delayInMs) &#123;</div><div class=\"line\">    this.delayInMs = delayInMs;</div><div class=\"line\">    this.singleSource = Observable.interval(delayInMs, TimeUnit.MILLISECONDS)</div><div class=\"line\">            .map(new Func1&lt;Long, DashboardData&gt;() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public DashboardData call(Long timestamp) &#123;</div><div class=\"line\">                    return new DashboardData(</div><div class=\"line\">                            HystrixCommandMetrics.getInstances(),</div><div class=\"line\">                            HystrixThreadPoolMetrics.getInstances(),</div><div class=\"line\">                            HystrixCollapserMetrics.getInstances()</div><div class=\"line\">                    );</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .doOnSubscribe(new Action0() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void call() &#123;</div><div class=\"line\">                    isSourceCurrentlySubscribed.set(true);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .doOnUnsubscribe(new Action0() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void call() &#123;</div><div class=\"line\">                    isSourceCurrentlySubscribed.set(false);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .share()</div><div class=\"line\">            .onBackpressureDrop();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里创建一个按固定时间间隔发射整数序列的Observable，默认间隔时间是500ms。</p>\n<p><img src=\"https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/interval.png\" alt=\"operators.interval\"></p>\n<p>RxJava中<a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.html#interval(long,%20java.util.concurrent.TimeUnit\">Observable.interval</a>).</p>\n<p>创建了Observable之后，紧接着调用了变换函数Map。  </p>\n<p><img src=\"https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/map.png\" alt=\"operators.map\"></p>\n<p>它对Observable发射的每一项数据应用一个函数，执行变换操作。这里的函数是调用HystrixCommandMetrics、HystrixThreadPoolMetrics、HystrixCollapserMetrics的实例获取方法，返回对应的Dashboard数据。</p>\n<p>doOnSubscribe-当被订阅的时候，执行对应的操作。<br>doOnUnsubscribe-当没有订阅者的时候，执行对应的操作。</p>\n<h1 id=\"3-参考资料\"><a href=\"#3-参考资料\" class=\"headerlink\" title=\"3 参考资料\"></a>3 参考资料</h1><ul>\n<li><a href=\"http://reactivex.io/\">ReactiveX官方网站</a></li>\n<li><a href=\"https://github.com/ReactiveX/RxJava\">RxJava</a></li>\n</ul>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/12/18/从Hystrix-DashboardData看ReativeX的使用/\">http://xiajunhust.github.io/2016/12/18/从Hystrix-DashboardData看ReativeX的使用/</a></p>"},{"title":"技术分享-MySQL InnoDB locks and deadlocks","date":"2016-08-27T08:01:34.000Z","_content":"\n本文是在组内技术分享的ppt：《MySQL InnoDB locks and deadlocks》。与大家分享，如有问题，欢迎来信交流。\n\n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-00.png)  \n\n<!-- more -->\n\n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-02.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-03.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-04.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-05.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-06.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-07.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-08.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-09.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-10.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-11.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-12.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-13.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-14.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-15.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-16.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-17.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-18.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-19.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-20.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-21.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-22.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-23.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-24.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-25.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-26.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-29.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-28.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-29.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-30.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-31.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-32.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-33.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-34.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-35.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-36.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-37.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-38.png)  ","source":"_posts/技术分享-MySQL-InnoDB-locks-and-deadlocks.md","raw":"---\ntitle: 技术分享-MySQL InnoDB locks and deadlocks\ndate: 2016-08-27 16:01:34\ntags: MySQL\n---\n\n本文是在组内技术分享的ppt：《MySQL InnoDB locks and deadlocks》。与大家分享，如有问题，欢迎来信交流。\n\n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-00.png)  \n\n<!-- more -->\n\n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-02.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-03.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-04.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-05.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-06.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-07.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-08.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-09.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-10.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-11.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-12.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-13.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-14.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-15.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-16.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-17.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-18.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-19.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-20.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-21.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-22.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-23.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-24.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-25.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-26.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-29.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-28.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-29.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-30.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-31.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-32.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-33.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-34.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-35.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-36.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-37.png)  \n![](http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-38.png)  ","slug":"技术分享-MySQL-InnoDB-locks-and-deadlocks","published":1,"updated":"2016-09-07T08:01:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciwubjsch000r2hwfcvkhyzym","content":"<p>本文是在组内技术分享的ppt：《MySQL InnoDB locks and deadlocks》。与大家分享，如有问题，欢迎来信交流。</p>\n<p><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-00.png\" alt=\"\">  </p>\n<a id=\"more\"></a>\n<p><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-02.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-03.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-04.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-05.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-06.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-07.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-08.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-09.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-10.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-11.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-12.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-13.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-14.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-15.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-16.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-17.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-18.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-19.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-20.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-21.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-22.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-23.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-24.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-25.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-26.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-29.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-28.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-29.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-30.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-31.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-32.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-33.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-34.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-35.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-36.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-37.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-38.png\" alt=\"\">  </p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/08/27/技术分享-MySQL-InnoDB-locks-and-deadlocks/\">http://xiajunhust.github.io/2016/08/27/技术分享-MySQL-InnoDB-locks-and-deadlocks/</a></p>\n","excerpt":"<p>本文是在组内技术分享的ppt：《MySQL InnoDB locks and deadlocks》。与大家分享，如有问题，欢迎来信交流。</p>\n<p><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-00.png\" alt=\"\">  </p>","more":"<p><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-02.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-03.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-04.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-05.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-06.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-07.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-08.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-09.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-10.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-11.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-12.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-13.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-14.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-15.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-16.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-17.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-18.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-19.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-20.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-21.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-22.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-23.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-24.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-25.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-26.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-29.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-28.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-29.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-30.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-31.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-32.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-33.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-34.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-35.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-36.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-37.png\" alt=\"\"><br><img src=\"http://o8sltkx20.bkt.clouddn.com/mysql-innodb-locks-38.png\" alt=\"\">  </p>\n<h2 id=\"版权声明\"><a href=\"#版权声明\" class=\"headerlink\" title=\"版权声明\"></a>版权声明</h2><p>本文首发于<a href=\"http://xiajunhust.github.io/\">江南烟雨的个人博客</a>博客（ <a href=\"http://xiajunhust.github.io/\">http://xiajunhust.github.io/</a> ），版权所有，侵权必究。<br>本文永久链接：<a href=\"http://xiajunhust.github.io/2016/08/27/技术分享-MySQL-InnoDB-locks-and-deadlocks/\">http://xiajunhust.github.io/2016/08/27/技术分享-MySQL-InnoDB-locks-and-deadlocks/</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciwubjsai00002hwfpuouc3kx","tag_id":"ciwubjsb800032hwf2zofoxir","_id":"ciwubjsbn00082hwfo0x8g739"},{"post_id":"ciwubjsas00022hwfu99jgghz","tag_id":"ciwubjsbl00062hwf1o4vm57x","_id":"ciwubjsbu000c2hwfg5bpozn7"},{"post_id":"ciwubjsbb00042hwf30piewaw","tag_id":"ciwubjsbt000b2hwfa4g8nkdp","_id":"ciwubjsbz000h2hwfb2fi6bkc"},{"post_id":"ciwubjsbw000e2hwf95t0j40v","tag_id":"ciwubjsbl00062hwf1o4vm57x","_id":"ciwubjsc0000j2hwfdoottt9o"},{"post_id":"ciwubjsbh00052hwf9favs0fs","tag_id":"ciwubjsbt000b2hwfa4g8nkdp","_id":"ciwubjsc6000m2hwf5sbyh0lk"},{"post_id":"ciwubjsbl00072hwfihn9cegj","tag_id":"ciwubjsc1000k2hwfeh440457","_id":"ciwubjscf000q2hwftsbsf1v5"},{"post_id":"ciwubjsch000r2hwfcvkhyzym","tag_id":"ciwubjsc1000k2hwfeh440457","_id":"ciwubjscl000t2hwfwdjahkxu"},{"post_id":"ciwubjsbn00092hwfbni7qztt","tag_id":"ciwubjscb000o2hwf2btdpibq","_id":"ciwubjscm000u2hwfnhlflgmy"},{"post_id":"ciwubjsbs000a2hwfoqhkplop","tag_id":"ciwubjscj000s2hwfaxsjrik4","_id":"ciwubjscq000w2hwfwgwt8z4e"},{"post_id":"ciwubjsbu000d2hwfg0z5hf7q","tag_id":"ciwubjscb000o2hwf2btdpibq","_id":"ciwubjscs000y2hwfncp441ws"},{"post_id":"ciwubjsby000g2hwf6ax2zvr8","tag_id":"ciwubjscb000o2hwf2btdpibq","_id":"ciwubjsct00102hwffxcsub21"},{"post_id":"ciwubjsbz000i2hwfcwx14owr","tag_id":"ciwubjscb000o2hwf2btdpibq","_id":"ciwubjscx00122hwftgza9g2w"},{"post_id":"ciwubjsc2000l2hwfay2f6kg5","tag_id":"ciwubjscw00112hwf96d1i3e3","_id":"ciwubjsd000142hwf9hbi7xju"},{"post_id":"ciwubjsc9000n2hwf6njtzjyz","tag_id":"ciwubjscz00132hwffn5kbzwo","_id":"ciwubjsd200162hwf9d6562ce"},{"post_id":"ciwubjscc000p2hwf00ilawmk","tag_id":"ciwubjsd100152hwfq82bmf46","_id":"ciwubjsd400182hwfz1pu38ml"},{"post_id":"ciwubjscc000p2hwf00ilawmk","tag_id":"ciwubjsd200172hwff71gx944","_id":"ciwubjsd400192hwf4gc0j09v"}],"Tag":[{"name":"测试技术","_id":"ciwubjsb800032hwf2zofoxir"},{"name":"Java","_id":"ciwubjsbl00062hwf1o4vm57x"},{"name":"开发工具","_id":"ciwubjsbt000b2hwfa4g8nkdp"},{"name":"MySQL","_id":"ciwubjsc1000k2hwfeh440457"},{"name":"RocketMQ","_id":"ciwubjscb000o2hwf2btdpibq"},{"name":"InfluxDB","_id":"ciwubjscj000s2hwfaxsjrik4"},{"name":"思考&读书笔记","_id":"ciwubjscw00112hwf96d1i3e3"},{"name":"代码设计","_id":"ciwubjscz00132hwffn5kbzwo"},{"name":"ReactiveX","_id":"ciwubjsd100152hwfq82bmf46"},{"name":"Hystrix","_id":"ciwubjsd200172hwff71gx944"}]}}